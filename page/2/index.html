<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lujianyun06.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录学习生活，力求每日进步">
<meta property="og:type" content="website">
<meta property="og:title" content="RockMaster&#39;s Blog">
<meta property="og:url" content="https://lujianyun06.github.io/page/2/index.html">
<meta property="og:site_name" content="RockMaster&#39;s Blog">
<meta property="og:description" content="记录学习生活，力求每日进步">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="RockMaster~Lu">
<meta property="article:tag" content="java">
<meta property="article:tag" content="后台开发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lujianyun06.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>RockMaster's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RockMaster's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">31</span></a>

  </li>
        
            
  <li class="menu-item menu-item-docs">

    <a href="/docs/" rel="section"><i class="fa fa-book fa-fw"></i>Docs</a>

  </li>


      
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A14/" class="post-title-link" itemprop="url">Android 音视频任务4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：16:08:27" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任务4. 学习 Android 平台的 MediaExtractor 和 MediaMuxer API，知道如何解析和封装 mp4 文件</p>
<ul>
<li>MediaMuxer和MediaCodec算是比较年轻的，它们是JB 4.1和JB 4.3才引入的。前者用于将音频和视频进行混合生成多媒体文件。缺点是目前只能支持一个audio track和一个video track，目前支持mp4,3gp,webm输出</li>
<li>MediaCodec用于将音视频进行压缩编码，它有个比较牛X的地方是可以对Surface内容进行编码，如KK 4.4中屏幕录像功能就是用它实现的。</li>
<li>MediaFormat用于描述多媒体数据的格式。</li>
<li>MediaRecorder用于录像+压缩编码，生成编码好的文件如mp4, 3gpp，视频主要是用于录制Camera preview。</li>
<li>MediaPlayer用于播放压缩编码后的音视频文件。</li>
<li>AudioRecord用于录制PCM数据。</li>
<li>AudioTrack用于播放PCM数据。PCM即原始音频采样数据，可以用如vlc播放器播放。</li>
</ul>
<p>MediaExtractor可以从数据源中提取解复用的，编码后的媒体数据。MediaExtractor用于音视频分路,比如从一个视频中分别提取音频(音轨)和视频(视频轨)<br>它既可以从视频里提取视频轨或音频轨，也可以单从音频里提取音频轨</p>
<p>//如下使用`</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MediaExtractor extractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line"> extractor.setDataSource(…);</span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line"> <span class="keyword">int</span> numTracks = extractor.getTrackCount(); <span class="comment">//当前视频中有几个轨道</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numTracks; ++i) &#123;</span><br><span class="line">   MediaFormat format = extractor.getTrackFormat(i);</span><br><span class="line">   String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">   <span class="keyword">boolean</span> isVideoTrack = mime.startsWith(<span class="string">"video/“); //当前是不是视频轨，视频轨的MIME以”video/“开头，音频轨的MIME以“audio/”开头</span></span><br><span class="line"><span class="string">   if (isVideoTrack) &#123;</span></span><br><span class="line"><span class="string">     extractor.selectTrack(i);   //选择视轨,当确定感兴趣的轨道时，一定要选取！</span></span><br><span class="line"><span class="string">     int index = mediaMuxer.addTrack(format) //如果要进行这个视轨的合成合成器除了需要数据，也需要mediaMuxer需要设置当前视轨的format，在写入的时候也需要视轨的index</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> ByteBuffer inputBuffer = ByteBuffer.allocate(…)  //这个容量必须大一点，否则下面readSampleData会崩，实测是1000*1024可以</span></span><br><span class="line"><span class="string">//下面readSampleData会自动更新buffer的limit和postion，就和read，write一样</span></span><br><span class="line"><span class="string"> while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) &#123;</span></span><br><span class="line"><span class="string">   int trackIndex = extractor.getSampleTrackIndex();</span></span><br><span class="line"><span class="string">   long presentationTimeUs = extractor.getSampleTime();</span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   extractor.advance(); //前进到下一个样本(下一个视频帧或音频帧)；readSampleData看起来不会自动更新读过的数据所以需要这个</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> extractor.release();</span></span><br><span class="line"><span class="string"> extractor = null;</span></span><br></pre></td></tr></table></figure>

<p>MediaMuxer可以复用基本流。 目前MediaMuxer支持MP4，Webm和3GP文件作为输出。 它还支持自Android Nougat以来在MP4中复用B帧。是extractor的反作用类型，用于把视频轨和音频轨进行合成,和MediaExtractor正好是反过程。<br>不支持mp3，wav音频源（AAC支持）<br>只能支持一个audio track和一个video track，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下使用</span></span><br><span class="line">MediaMuxer muxer = <span class="keyword">new</span> MediaMuxer(<span class="string">"temp.mp4"</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line">mediaMuxer.setOrientationHint(<span class="number">90</span>); <span class="comment">//设置混合后视频的旋转角度</span></span><br><span class="line"> <span class="comment">// More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat()</span></span><br><span class="line"> <span class="comment">// or MediaExtractor.getTrackFormat().</span></span><br><span class="line"> MediaFormat audioFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"> MediaFormat videoFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"> <span class="keyword">int</span> audioTrackIndex = muxer.addTrack(audioFormat); <span class="comment">//返回的是混合器里的轨道号，也就是新文件里的轨道号</span></span><br><span class="line"> <span class="keyword">int</span> videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line"> ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);</span><br><span class="line"> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"> BufferInfo bufferInfo = <span class="keyword">new</span> BufferInfo();</span><br><span class="line"></span><br><span class="line"> muxer.start(); <span class="comment">//开始混合</span></span><br><span class="line"> <span class="keyword">while</span>(!finished) &#123;</span><br><span class="line">   <span class="comment">// getInputBuffer() will fill the inputBuffer with one frame of encoded</span></span><br><span class="line">   <span class="comment">/* sample from either MediaCodec or MediaExtractor, set isAudioSample to true when the sample is audio data, set up all the fields of bufferInfo,and return true if there are no more samples.*/</span></span><br><span class="line">   finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);</span><br><span class="line">   <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">     <span class="keyword">int</span> currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bufferInfo.presentationTimeUs = extractor.getSampleTime(); //直接从extractor获取</span></span><br><span class="line"><span class="comment">bufferInfo.offset = 0;  //如果没有特殊需求一般是0</span></span><br><span class="line"><span class="comment">bufferInfo.flags = extractor.getSampleFlags();</span></span><br><span class="line"><span class="comment">bufferInfo.size = size;  //本次写入的数据量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo); <span class="comment">//每次写入数据都要同时写入index和info，info要明确如上面几点，注意这里的index是新合成的视频的相应轨道，应该是由addTrack返回的值</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> muxer.stop();</span><br><span class="line"> muxer.release();</span><br></pre></td></tr></table></figure>

<p>元数据跟踪<br>每帧元数据用于携带与视频或音频相关的额外信息以便于离线处理，例如，来自传感器的陀螺仪信号可以在进行离线处理时帮助稳定视频。仅在MP4容器中支持元数据跟踪。添加新元数据轨道时，轨道的mime格式必须以前缀“application /”开头，例如“application/gyro”。元数据的格式/布局将由应用程序定义。写入元数据与编写视频/音频数据几乎相同，只是数据不会来自mediacodec。应用程序只需要将包含元数据的字节缓冲区以及相关的时间戳传递给writeSampleData（int，ByteBuffer，MediaCodec.BufferInfo）api。时间戳必须与视频和音频的时间基准相同。生成的MP4文件使用ISOBMFF的第12.3.3.2节中定义的TextMetaDataSampleEntry来表示元数据的mime格式。当使用MediaExtractor提取具有元数据轨道的文件时，元数据的mime格式将被提取到MediaFormat中。<br>//如下例，把陀螺仪信息也传给生成的MP4</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">MediaMuxer muxer = <span class="keyword">new</span> MediaMuxer(<span class="string">"temp.mp4"</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SetUp Video/Audio Tracks.</span></span><br><span class="line"></span><br><span class="line">   MediaFormat audioFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   MediaFormat videoFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> audioTrackIndex = muxer.addTrack(audioFormat);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Setup Metadata Track</span></span><br><span class="line"></span><br><span class="line">   MediaFormat metadataFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   metadataFormat.setString(KEY_MIME, <span class="string">"application/gyro"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> metadataTrackIndex = muxer.addTrack(metadataFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   muxer.start();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(..) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Allocate bytebuffer and write gyro data(x,y,z) into it.</span></span><br><span class="line"></span><br><span class="line">       ByteBuffer metaData = ByteBuffer.allocate(bufferSize);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(x);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(y);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(z);</span><br><span class="line"></span><br><span class="line">       BufferInfo metaInfo = <span class="keyword">new</span> BufferInfo();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Associate this metadata with the video frame by setting</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// the same timestamp as the video frame.</span></span><br><span class="line"></span><br><span class="line">       metaInfo.presentationTimeUs = currentVideoTrackTimeUs;</span><br><span class="line"></span><br><span class="line">       metaInfo.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       metaInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       metaInfo.size = bufferSize;</span><br><span class="line"></span><br><span class="line">       muxer.writeSampleData(metadataTrackIndex, metaData, metaInfo);</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   muxer.stop();</span><br><span class="line"></span><br><span class="line">   muxer.release();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>MediaCodec类可用于访问低级媒体编解码器，即编码器/解码器组件。 它是Android低级多媒体支持基础架构的一部分（通常与MediaExtractor，MediaSync，MediaMuxer，MediaCrypto，MediaDrm，Image，Surface和AudioTrack一起使用。）</p>
<p>从广义上讲，编解码器处理输入数据以生成输出数据。它异步处理数据并使用一组输入和输出缓冲区。在简单的级别，您请求（或接收）一个空的输入缓冲区，用数据填充它并将其发送到编解码器进行处理。编解码器使用数据并将其转换到它的空输出缓冲区之一。最后，您请求（或接收）到一个填充了数据的输出缓冲区，使用其内容并将其释放回编解码器。</p>
<p>数据类型<br>编解码器对三种数据进行操作：压缩数据，原始音频数据和原始视频数据。可以使用ByteBuffers处理所有三种数据，但是您应该使用Surface for raw视频数据来提高编解码器性能。 Surface使用本机视频缓冲区而不映射或将它们复制到ByteBuffers;因此，效率更高。使用Surface时通常无法访问原始视频数据，但您可以使用ImageReader类访问不安全的解码（原始）视频帧。这可能仍然比使用ByteBuffers更有效，因为一些本机缓冲区可能会映射到直接ByteBuffers。使用ByteBuffer模式时，可以使用Image类和getInput / OutputImage（int）访问原始视频帧。</p>
<p>原始音频缓冲区<br>原始音频缓冲区包含整个PCM音频数据帧，这是通道顺序中每个通道的一个样本。 每个样本都是本机字节顺序的16位有符号整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>[] getSamplesForChannel(MediaCodec codec, <span class="keyword">int</span> bufferId, <span class="keyword">int</span> channelIx) &#123;</span><br><span class="line"></span><br><span class="line">  ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);</span><br><span class="line"></span><br><span class="line">  MediaFormat format = codec.getOutputFormat(bufferId);</span><br><span class="line"></span><br><span class="line">  ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numChannels = formet.getInteger(MediaFormat.KEY_CHANNEL_COUNT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (channelIx &lt; <span class="number">0</span> || channelIx &gt;= numChannels) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">short</span>[] res = <span class="keyword">new</span> <span class="keyword">short</span>[samples.remaining() / numChannels];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    res[i] = samples.get(i * numChannels + channelIx);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//音频抽取后的format信息</span></span><br><span class="line"><span class="number">0</span> = &#123;HashMap$HashMapEntry@4594&#125; <span class="string">"mime"</span> -&gt; <span class="string">"audio/mp4a-latm"</span></span><br><span class="line"><span class="number">1</span> = &#123;HashMap$HashMapEntry@4595&#125; <span class="string">"aac-profile"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">2</span> = &#123;HashMap$HashMapEntry@4596&#125; <span class="string">"channel-count"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span> = &#123;HashMap$HashMapEntry@4597&#125; <span class="string">"track-id"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">4</span> = &#123;HashMap$HashMapEntry@4598&#125; <span class="string">"durationUs"</span> -&gt; <span class="string">"192911760"</span></span><br><span class="line"><span class="number">5</span> = &#123;HashMap$HashMapEntry@4599&#125; <span class="string">"csd-0"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=2 cap=2]"</span></span><br><span class="line"><span class="number">6</span> = &#123;HashMap$HashMapEntry@4600&#125; <span class="string">"sample-rate"</span> -&gt; <span class="string">"44100"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频抽取后的format信息</span></span><br><span class="line"><span class="number">0</span> = &#123;HashMap$HashMapEntry@4620&#125; <span class="string">"csd-1"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=8 cap=8]"</span></span><br><span class="line"><span class="number">1</span> = &#123;HashMap$HashMapEntry@4621&#125; <span class="string">"rotation-degrees"</span> -&gt; <span class="string">"90"</span></span><br><span class="line"><span class="number">2</span> = &#123;HashMap$HashMapEntry@4622&#125; <span class="string">"track-id"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span> = &#123;HashMap$HashMapEntry@4623&#125; <span class="string">"height"</span> -&gt; <span class="string">"1200"</span></span><br><span class="line"><span class="number">4</span> = &#123;HashMap$HashMapEntry@4624&#125; <span class="string">"profile"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">5</span> = &#123;HashMap$HashMapEntry@4625&#125; <span class="string">"color-standard"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">6</span> = &#123;HashMap$HashMapEntry@4626&#125; <span class="string">"durationUs"</span> -&gt; <span class="string">"2157877"</span></span><br><span class="line"><span class="number">7</span> = &#123;HashMap$HashMapEntry@4627&#125; <span class="string">"color-transfer"</span> -&gt; <span class="string">"3"</span></span><br><span class="line"><span class="number">8</span> = &#123;HashMap$HashMapEntry@4628&#125; <span class="string">"mime"</span> -&gt; <span class="string">"video/avc"</span></span><br><span class="line"><span class="number">9</span> = &#123;HashMap$HashMapEntry@4629&#125; <span class="string">"frame-rate"</span> -&gt; <span class="string">"30"</span></span><br><span class="line"><span class="number">10</span> = &#123;HashMap$HashMapEntry@4630&#125; <span class="string">"width"</span> -&gt; <span class="string">"1600"</span></span><br><span class="line"><span class="number">11</span> = &#123;HashMap$HashMapEntry@4631&#125; <span class="string">"color-range"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">12</span> = &#123;HashMap$HashMapEntry@4632&#125; <span class="string">"max-input-size"</span> -&gt; <span class="string">"123106"</span></span><br><span class="line"><span class="number">13</span> = &#123;HashMap$HashMapEntry@4633&#125; <span class="string">"csd-0"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=21 cap=21]"</span></span><br><span class="line"><span class="number">14</span> = &#123;HashMap$HashMapEntry@4634&#125; <span class="string">"level"</span> -&gt; <span class="string">"2048"</span></span><br></pre></td></tr></table></figure>
<p>这里要注意的是，要分清楚原视频中的视/音轨号和新合成的视频中的视/音轨号，一般来说前者是为了让extractor选中相应的轨道，而后者是在合成视频写数据的时候需要。这里犯了一个错就是提取视频轨的时候，视频轨在视频中的轨道号是0，提取音频帧时，音轨在音频中的轨道号也是0，实际给muxer添加轨道的时候，视轨被添加到了新视频的轨道0，音轨被添加到了新视频的轨道1。但写音频数据的时候仍往0号轨道写，就崩掉了报错：stop muxer failed</p>
<p>具体工程代码见 <a href="https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/task4" target="_blank" rel="noopener">https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/task4</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A17/" class="post-title-link" itemprop="url">Android 音视频任务7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：16:09:45" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先做任务7，是因为做完任务4感觉想要稍微深入了解一下MediaCodec，感觉这样更能把刚学到的知识连贯一下。</p>
<p>任务7. 学习 MediaCodec API，完成音频 AAC 硬编、硬解</p>
<p>MediaCodec的作用是转换编码或解码文件，支持已编码的特定格式转成原始raw数据，<br>原始raw数据转成特定编码的格式<br>解码时，mediaCodec设定的格式是输入文件的格式，输出原始raw数据<br>编码时，mediaCodec设定的格式是输出文件的格式，输入为原始raw数据</p>
<p>解码时文件的格式和解码器设置的格式一定要一样，否则报错</p>
<h2 id="音频编解码："><a href="#音频编解码：" class="headerlink" title="音频编解码："></a>音频编解码：</h2><h3 id="解码："><a href="#解码：" class="headerlink" title="解码："></a>解码：</h3><ul>
<li>解码是吧audio/XXX给变成audio/raw，即pcm文件，最原始的未经压缩编码处理的文件。所以解码后的文件一般会比被压缩文件大得多<br>流程：</li>
<li>首先要使用MediaExtractor把音轨从文件中提取出来，把format也提取出来，根据要解码的mime创建codec：<br>mDCodec = MediaCodec.createDecoderByType(srcMIMTType);</li>
<li>把format设置到codec：mDCodec.configure(mFormat, null, null, 0); //视频文件如果要播放解码出的数据，则第二个参数选择要用于播放的surface</li>
<li>数据回调监听：mDCodec.setCallback(mDecodeCallback); （异步处理，感觉异步的好一点）</li>
<li>开始解码：mDCodec.start();<br>callback中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="comment">//onInputBufferAvailable：当有可用的缓冲区时，会转到这里，在该函数中往可用的缓冲区写入要解码的数据，然后把缓冲区加入待处理队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得可用的缓冲</span></span><br><span class="line">            ByteBuffer inputBuffer = codec.getInputBuffer(index);</span><br><span class="line"></span><br><span class="line">            MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = mExtractor.readSampleData(inputBuffer, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> flag = mExtractor.getSampleFlags();</span><br><span class="line">            <span class="keyword">long</span> presentation = mExtractor.getSampleTime();</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"size= "</span> + size + <span class="string">" flag="</span> + flag + <span class="string">" presentation="</span> + presentation);</span><br><span class="line"><span class="comment">//要对文件是否读到末尾单独处理，若读到末尾了，size,presentation都要置为0，flag要标注为 MediaCodec.BUFFER_FLAG_END_OF_STREAM</span></span><br><span class="line">            <span class="keyword">if</span> (size != -<span class="number">1</span>) &#123;</span><br><span class="line">                inputSize += size;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">                mExtractor.advance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//当文件达到末尾时，用flag</span></span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                presentation = <span class="number">0</span>;</span><br><span class="line">                flag = MediaCodec.BUFFER_FLAG_END_OF_STREAM;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//onOutputBufferAvailable：当有待处理数据完成解码时，会放入输出缓冲区，并转到这里，在该函数中获得解码后的raw数据，并且每次读出数据后要release当前缓冲，让它能够继续被使用，否则就那么一点缓冲区，不释放的话几下就没了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MediaFormat format = codec.getOutputFormat(index);</span><br><span class="line">        Log.d(tag, <span class="string">"out format="</span> + format.getString(MediaFormat.KEY_MIME));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得可用的输出缓冲区（也就是解码好的数据）</span></span><br><span class="line">        ByteBuffer outputBuffer = codec.getOutputBuffer(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果直接定义 data =  new byte[100 * 1024]; 然后调用outputBuffer.get(data),</span></span><br><span class="line">        <span class="comment">// 则会使用data的长度去操作buffer，但buffer没这么大，导致BufferUnderflowException</span></span><br><span class="line">        <span class="comment">//所以下面两种方式选一种</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[outputBuffer.limit()];</span><br><span class="line">        outputBuffer.get(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] data = new byte[100 * 1024];</span></span><br><span class="line"><span class="comment">//        outputBuffer.get(data,0, outputBuffer.limit());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        outputSize += data.length;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.write(data); <span class="comment">//写入流中</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(tag, <span class="string">"flag="</span> + info.flags);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize= "</span> + outputSize);</span><br><span class="line">        <span class="comment">//用完后释放这个buffer，使其可以接着被使用</span></span><br><span class="line">        codec.releaseOutputBuffer(index, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//当到达末尾时，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">            Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            stopAndrealseCodec();</span><br><span class="line">            exPCM2WAV();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDCodec.release();</span><br><span class="line">        mDCodec = <span class="keyword">null</span>;</span><br><span class="line">        mExtractor.release();</span><br><span class="line">        mExtractor = <span class="keyword">null</span>;</span><br><span class="line">        Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pcm文件加入wav头变成wav文件，wav文件会被识别成audio/raw，而原始的pcm文件会被识别错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exPCM2WAV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为什么从视频里(只试了mp4和3gp)剥离出来的要 原本的sampleRate/2才是正常速度？</span></span><br><span class="line">    <span class="keyword">int</span> sampleRate = mFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE);</span><br><span class="line">    PcmToWavUtil util = <span class="keyword">new</span> PcmToWavUtil(sampleRate, mFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT),</span><br><span class="line">            AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line">    Log.d(tag, <span class="string">"sampleRate="</span> + sampleRate);</span><br><span class="line">    util.pcmToWav(outputFileName, outputFileName + <span class="string">".wav"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h3><p>编码是吧audio/raw给变成audio/XXX，是对原始数据压缩编码，但这个有一个问题要注意的是硬件是否支持这种编码方式，比如nexus6p，由于mp3格式编码是不开源的，所以不能编码成mp3文件。下面以把wav的原生格式编码成aac<br>流程：<br><em>编码要比解码多一个步骤，就是设置要编码的格式的各项数据，比如</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">outFormat = MediaFormat.createAudioFormat(desMIMEType, SAMPLE_RATE, CHANNEL_COUNT); <span class="comment">//根据编码格式，采样率，声道数创建format</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>); <span class="comment">//比特率</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_AAC_PROFILE,  MediaCodecInfo.CodecProfileLevel.AACObjectLC);  <span class="comment">//aac特有的profile</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, <span class="number">100</span> * <span class="number">1024</span>);<span class="comment">//输入缓存的最大值，设置这个防止一帧的数据量太大而超过默认的buffer大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加aac的csd-0，如果是视频，则csd-0和csd-1都要有（这个是干什么的还不清楚）</span></span><br><span class="line">ByteBuffer csd = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((aacObjLC &lt;&lt; <span class="number">3</span>) | (sampleIndex &gt;&gt; <span class="number">1</span>)));</span><br><span class="line">csd.position(<span class="number">1</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((<span class="keyword">byte</span>) ((sampleIndex &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x80</span>) | (channelCount &lt;&lt; <span class="number">3</span>)));</span><br><span class="line">csd.flip();</span><br><span class="line">outFormat.setByteBuffer(<span class="string">"csd-0"</span>, csd); <span class="comment">// add csd-0</span></span><br><span class="line">System.out.println(Arrays.toString(csd.array()) + <span class="string">"===++”);</span></span><br><span class="line"><span class="string">查看设备支持的编码和解码器：</span></span><br><span class="line"><span class="string">MediaCodecList list = new MediaCodecList(MediaCodecList.ALL_CODECS);</span></span><br><span class="line"><span class="string">MediaCodecInfo[] infos = list.getCodecInfos();</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; infos.length; i++) &#123;</span></span><br><span class="line"><span class="string">    String name = infos[i].getName();</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>i=<span class="string">" + i + "</span> name=<span class="string">" + name);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">根据format创建相应的编码器</span></span><br><span class="line"><span class="string">//根据相应的格式找到是否有合适的编码器，如果有则返回其名称，然后创建相应的编码器</span></span><br><span class="line"><span class="string">String encodeName = list.findEncoderForFormat(outFormat);</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>encodeName=<span class="string">" + encodeName);</span></span><br><span class="line"><span class="string">    mECodec = MediaCodec.createByCodecName(encodeName);</span></span><br><span class="line"><span class="string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="string">    e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">mECodec.setCallback(mEncodeCallback); //设置回调</span></span><br><span class="line"><span class="string">mECodec.configure(outFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);  //编码配置，编码时要设置最后一个参数</span></span><br><span class="line"><span class="string">mECodec.start();  //开始编码</span></span><br></pre></td></tr></table></figure>
<p>callback中：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span>InputBufferAvailable和解码器的并无不同，都是由MediaExtractor读出数据放到缓存队列里等待处理</span><br></pre></td></tr></table></figure>

<p>onOutputBufferAvailable和默认流程和解码器类似，都是从缓冲队列中取出已经处理好的数据（每次取一帧），但编码器不同的一点是，这个数据只是真实数据流的编码，仅仅有这些没办法封装成可读的格式，还必须要加上可识别的部分，比如wav文件是在所有数据头部加上wav头，aac文件是在每一帧数据前面加上adts头，<br>adts见 <a href="https://www.cnblogs.com/lihaiping/p/5284547.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihaiping/p/5284547.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> outIndex = index;</span><br><span class="line">            MediaFormat format = codec.getOutputFormat(outIndex);</span><br><span class="line"></span><br><span class="line">            ByteBuffer outputBuffer = codec.getOutputBuffer(outIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = outputBuffer.limit();</span><br><span class="line">            outputSize += size;</span><br><span class="line">            <span class="keyword">byte</span>[] packedData = <span class="keyword">new</span> <span class="keyword">byte</span>[size + <span class="number">7</span>];</span><br><span class="line">            addADTStoPacket(packedData, packedData.length);</span><br><span class="line">            outputBuffer.get(packedData, <span class="number">7</span>, size);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.write(packedData);</span><br><span class="line">                fos.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用完后释放这个buffer，使其可以接着被使用，如果一直不释放，如果文件太大则会导致缓冲区不够用</span></span><br><span class="line">            outputBuffer.clear();</span><br><span class="line">            codec.releaseOutputBuffer(outIndex, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">                stopAndrealseCodec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一帧前面都要加上ADTS头，可以看做是每一个AAC帧的帧头</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>;  <span class="comment">//AAC LC</span></span><br><span class="line">        <span class="comment">//39=MediaCodecInfo.CodecProfileLevel.AACObjectELD;</span></span><br><span class="line">        <span class="keyword">int</span> freqIdx = <span class="number">4</span>;  <span class="comment">//44.1KHz</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">2</span>;  <span class="comment">//CPE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] packet1 = new byte[packetLen];</span></span><br><span class="line">        <span class="comment">// fill in ADTS data</span></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (freqIdx &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //把这些清晰的放出来，但最好还是用上面的方式</span></span><br><span class="line"><span class="comment">//        //syncword</span></span><br><span class="line"><span class="comment">//        packet[0] = (byte) 0xFF;</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0xF &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //id</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1 &lt;&lt; 3;</span></span><br><span class="line"><span class="comment">//        //layer</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x00 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //protection_abscent</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1;</span></span><br><span class="line"><span class="comment">//        //profile</span></span><br><span class="line"><span class="comment">//        packet[2] |= (profile -1) &lt;&lt; 6;</span></span><br><span class="line"><span class="comment">//        //sampling_frequency_index</span></span><br><span class="line"><span class="comment">//        packet[2] |= freqIdx &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //private bit</span></span><br><span class="line"><span class="comment">//        packet[2] |= 0x0 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //channel_config</span></span><br><span class="line"><span class="comment">//        packet[2] |= chanCfg &gt;&gt; 2;  //高1位</span></span><br><span class="line"><span class="comment">//        packet[3] |= chanCfg &lt;&lt; 6;   //低2位</span></span><br><span class="line"><span class="comment">//        //copy and home;</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //cib and cis</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //frame_length,单位是字节。不用管int是几个字节，把它当13位就行了,一帧的长度一般不可能超过13位能表达的最大值(8KB),</span></span><br><span class="line"><span class="comment">//        packet[3] |= packetLen &gt;&gt; 11;</span></span><br><span class="line"><span class="comment">//        packet[4] = (byte) (packetLen &gt;&gt; 3);</span></span><br><span class="line"><span class="comment">//        int x = packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//        packet[5] |= packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        packet[5] |= 0x7FF &gt;&gt; 6;</span></span><br><span class="line"><span class="comment">//        packet[6] |= 0x7FF &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mECodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mECodec.release();</span><br><span class="line">            mECodec = <span class="keyword">null</span>;</span><br><span class="line">            mExtractor.release();</span><br><span class="line">            mExtractor = <span class="keyword">null</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">            Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">            Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码见 <a href="https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7" target="_blank" rel="noopener">https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Android如何替换原生应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：15:46:35" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有个需求是把原生的日历app换成修改源码后编译生成的新app<br>尝试进入adb，须有root权限（完整的root权限）<br>用以下代码删除原生的calendar</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">pm uninstall -k --user 0 com.android.calendar</span><br></pre></td></tr></table></figure>

<p>然后要把/system挂载成可读写的（rw，一开始是只读的ro）<br>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount</span></span><br></pre></td></tr></table></figure>
<p>可以发现/system是只读的 ro<br>然后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">mount -o rw,remount /system</span><br><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>可以看到/system 是可读写的：rw<br>此时退出adb shell，把已经编译好的新的日历apk push进手机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push ~/newapk/Calendar.apk /system/app/Calendar</span><br><span class="line">adb shell   </span><br><span class="line">reboot   //重启手机</span><br></pre></td></tr></table></figure>
<p>此时就可以使用改后的calendar了<br>————————————————<br>版权声明：本文为CSDN博主「TheRockMaster」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43752854/article/details/84647709" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43752854/article/details/84647709</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/onMeasure()%E5%92%8ConLayout()%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/onMeasure()%E5%92%8ConLayout()%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">onMeasure()和onLayout()总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：15:56:56" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自 <a href="https://www.cnblogs.com/xqxacm/p/6673469.html" target="_blank" rel="noopener">https://www.cnblogs.com/xqxacm/p/6673469.html</a><br>和 <a href="https://blog.csdn.net/superxukai88/article/details/78675686" target="_blank" rel="noopener">https://blog.csdn.net/superxukai88/article/details/78675686</a></p>
<p>并写了一些自己的总结<br>前言：<br>　　自定义控件的三大方法：</p>
<ol>
<li>测量： onMeasure()：  测量自己的大小，为正式布局提供建议 </li>
<li>布局： onLayout():   使用layout()函数对所有子控件布局</li>
<li>绘制： onDraw():     根据布局的位置绘图 </li>
</ol>
<p>onDraw() 里面是绘制的操作，可以看下其他的文章，下面来了解 onMeasure()和onLayout()方法。</p>
<h1 id="一、onMeasure-、测量"><a href="#一、onMeasure-、测量" class="headerlink" title="一、onMeasure()、测量"></a>一、onMeasure()、测量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<p>参数即父类传过来的两个宽高的”建议值”，即把当前view的高设置为：heightMeasureSpec ;宽设置为：widthMeasureSpec<br>这个参数不是简单的整数类型，而是2位整数(模式类型)和30位整数(实际数值) 的组合</p>
<p>其中模式分为三种:</p>
<p>①、UNSPECIFIED(未指定)，父元素不对自元素施加任何束缚，子元素可以得到任意想要的大小；UNSPECIFIED=00000000000000000000000000000000</p>
<p>②、EXACTLY(完全)，父元素决定自元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；EXACTLY =01000000000000000000000000000000<br>③、AT_MOST(至多)，子元素至多达到指定大小的值。 他们对应的二进制值分别是： AT_MOST =10000000000000000000000000000000 </p>
<p>最前面两位代表模式，分别对应十进制的0，1，2；</p>
<p>获取模式int值 和 获取数值int值的方法：</p>
<blockquote>
<ol>
<li>int measureWidth = MeasureSpec.getSize(widthMeasureSpec);  </li>
<li>int measureHeight = MeasureSpec.getSize(heightMeasureSpec);  </li>
<li>int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);  </li>
<li>int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);<br>模式的值有：<br>MeasureSpec.AT_MOST       = 2<br>MeasureSpec.EXACTLY       = 1<br>MeasureSpec.UNSPECIFIED   = 0</li>
</ol>
</blockquote>
<p>上面我们知道了 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法参数的意义<br>下面了解参数对应的三个模式分别对应的意义：<br>每一个模式都对应的xml布局中的一个值<br>wrap_content — MeasureSpec.AT_MOST<br>match_parent — MeasureSpec.EXACTLY<br>具体值 — MeasureSpec.UNSPECIFIED</p>
<p>注意：<br>—当模式是MeasureSpec.AT_MOST时，即wrap_content时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上就是父亲建议的尺寸数值,（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议.</p>
<p>PS: 但需要注意的是，如果直接自定义一个View，宽高为wrap_content, 则最后绘制的时候view是占满整个父View的(假设父view只有这一个儿子)，这是因为上面说的，传过来的是父亲的尺寸，但如果自定义View继承了像TextView之类的，最后还调用了super.onMeasure，则显示的时候大小是根据其内容显示的，这是因为这些TextView在自己的onMeasure里又做了处理，使得其根据内容的大小而变化。</p>
<p>—当模式是MeasureSpec.EXACTLY时，即match_parent时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上也是父亲建议的尺寸数值（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议</p>
<p>PS:（AT_MOST与EXACTLY：如果在onMeasure中不做任何处理而调用setMeasureDimension(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.getSize(heightMeasureSpec))）来设置尺寸，，或者在基类的onMeasure中不做任何额外处理而调用super.onMeasure().那么这两个模式没有任何区别（都是用父亲建议的大小设置自己的大小，而且两个模式父亲建议的大小都一样）。因此若使用AT_MOST一般都要在onMeasure中根据mode不同而设置view尺寸为不同的大小（如同TextView做的那样）</p>
<p>—当模式是MeasureSpec.UNSPECIFIED时，即具体数值时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际是具体指定的数字，因此在onMeasure里不做其他操作，子view会符合父亲的建议，即变成它自己设定的尺寸，尽管这里的数字大小是不做限制的，但当绘制的时候，父亲会clip掉自己尺寸之外的子view的部分。要避免的话，需设置子view的顶级祖先ViewGroup的clipChildren属性为false，而且它的父亲必须不是RelativeLayout（即不clip有两个条件，1.顶级祖先view设置clipChildren=false。2.父view必须不是RelativeLayout，PS：父view设置不设置clipChildren无所谓，顶级祖先必须设置）</p>
<h1 id="二、onLayout-、-布局"><a href="#二、onLayout-、-布局" class="headerlink" title="二、onLayout() 、 布局"></a>二、onLayout() 、 布局</h1><p>onLayout方法是ViewGroup中子View的布局方法，用于放置子View的位置。放置子View很简单，只需在重写onLayout方法，然后获取子View的实例，调用子View的layout方法实现布局。在实际开发中，一般要配合onMeasure测量方法一起使用。</p>
<h2 id="onLayout方法："><a href="#onLayout方法：" class="headerlink" title="onLayout方法："></a>onLayout方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span>  <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法在ViewGroup中定义是抽象函数，继承该类必须实现onLayout方法，而ViewGroup的onMeasure并非必须重写的。View的放置都是根据一个矩形空间放置的，onLayout传下来的l,t,r,b分别是放置父控件的矩形可用空间（除去margin和padding的空间）的左上角的left、top以及右下角right、bottom值。</p>
<h2 id="layout方法："><a href="#layout方法：" class="headerlink" title="layout方法："></a>layout方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法是View的放置方法，在View类实现。调用该方法需要传入放置View的矩形空间左上角left、top值和右下角right、bottom值。这四个值是相对于父控件而言的。例如传入的是（10, 10, 100, 100），则该View在距离父控件的左上角位置(10, 10)处显示，显示的大小是宽高是90(参数r,b是相对左上角的)，这有点像绝对布局。</p>
<p>平常开发所用到RelativeLayout、LinearLayout、FrameLayout…这些都是继承ViewGroup的布局。这些布局的实现都是通过都实现ViewGroup的onLayout方法，只是实现方法不一样而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/linux/Ubuntu16%E4%B8%8B%20pip%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8D%B8%E8%BD%BD%E3%80%81%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/linux/Ubuntu16%E4%B8%8B%20pip%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8D%B8%E8%BD%BD%E3%80%81%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">Ubuntu16下 pip安装，卸载、升级，报错</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：16:48:11" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>新装的ubuntu16，自带的python2.7，使用pip升级后，报错，修改记录如下：</p>
<h2 id="如何彻底卸载pip？"><a href="#如何彻底卸载pip？" class="headerlink" title="如何彻底卸载pip？"></a>如何彻底卸载pip？</h2><p>sudo python -m pip uninstall pip</p>
<h2 id="如何安装pip"><a href="#如何安装pip" class="headerlink" title="如何安装pip"></a>如何安装pip</h2><p>sudo apt install python-pip</p>
<h2 id="如何安装指定版本的pip"><a href="#如何安装指定版本的pip" class="headerlink" title="如何安装指定版本的pip"></a>如何安装指定版本的pip</h2><p>python -m pip install pip==18.1(换成你想要的版本编号)</p>
<h2 id="pip安装软件过程中报错："><a href="#pip安装软件过程中报错：" class="headerlink" title="pip安装软件过程中报错："></a>pip安装软件过程中报错：</h2><p>Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-BqMhb7/matplotlib/</p>
<ol>
<li>安装并升级setuptools<br>pip install –upgrade setuptools</li>
<li>升级pip<br>pip install –upgrade pip</li>
</ol>
<h2 id="pip升级后报错"><a href="#pip升级后报错" class="headerlink" title="pip升级后报错"></a>pip升级后报错</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/usr/bin/pip", line 9, in &lt;module&gt;</span><br><span class="line">    from pip import main</span><br><span class="line">ImportError: cannot import name 'main'</span><br><span class="line">修改/usr/bin/pip如下：</span><br><span class="line">//修改前</span><br><span class="line">from pip import main  </span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(main()) </span><br><span class="line">修改后</span><br><span class="line">from pip import __main__  //这行也要修改</span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(__main__._main())//增加__main__._  （注意最后main()前面有个_）</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/linux/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3linux%E6%8C%82%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/linux/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3linux%E6%8C%82%E8%BD%BD/" class="post-title-link" itemprop="url">如何理解linux挂载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：16:00:26" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据树结构去理解整个文件系统的挂载和挂载点还是有点困难，所以自己做了些总结，有不对的地方还请指正</p>
<p>df -h命令后</p>
<p>Filesystem 这里的文件系统表示的是目录的层次结构，而不是所谓的像ext4，fat那种真正的文件系统类型<br>一个具体的设备文件(或分区) ，或许是一块硬盘上的一个分区，或许是u盘上的一个分区</p>
<p>目录就相当于门<br>整个linux中的文件系统就像一个世界接着一个世界，不同的世界代表不同的被挂载的文件系统，挂载点就相当于任意门（特殊的门），各个被挂载的文件系统之间是独立的，但是要进入其中一个需要一个一个进入任意门去穿梭，整个世界的第一个门是 / ，它里面的世界是第一个文件系统，这个世界里又有很多个门，有的门背后的世界和这个世界是同一个，则他们是在同一个文件系统里，而当有其他的分区被挂载到一个目录的时候，例如<br>对一个目录 /home/lll，要到达这个门后的世界，要穿过 / 和 home/ （这个门在 / 后面的世界里） 和 lll/ （这个门在 home/ 后面的世界里），形象的描述为：</p>
<p>/ —》 世界A （包含 home/ —-》 世界B （包含 lll/ —》 世界C ）如果不做任何其他挂载，世界A、B、C是同一个世界）当要把/dev/sda1这个id所指向的分区挂载到 /home/lll 则相当于把 /home/lll/ 这个门变成任意门，它通往的世界变成了sda1的世界空间，自然的，只要进了这个世界，如果再不挂载其他的，则所有对 /home/lll/… 的操作都在sda1的世界里，而对这个门前面的世界的操作，如对/home/aaa的操作，仍然在一开始的那个世界里<br>把挂载点想象成一个任意门，进入第一个任意门是世界A，里面还有一个任意门通往世界B，虽然只有进了第一个任意门才能进第二个任意门，但世界A和世界B是毫无关系彼此独立的（挂载的文件系统之间彼此独立）<br>挂载绑定：把一个目录挂载到另一个目录，比如 mount –bind dir1 dir2 则是相当于对dir2这个门做了特殊处理，让dir2和dir1通往同一个世界的同一个位置，而dir2原本通往的那个位置里面的东西会被遮盖掉，当解除挂载后，dir2会恢复它原本通往的世界和位置，且里面的东西还在</p>
<p>当把目录A挂载到目录B，= mount –bind A B ; 其中B是新的挂载点 ，就是让门B通往的地方和门A通往的地方一毛一样<br>把设备A挂载到目录B = mount A B ; 其中B是新的挂载点，就是让门B通往的地方是A的世界空间。<br>挂载点必须是目录（门）</p>
<p>可以对同一个目录多次挂载，最后生效的结果是最后一次挂载，此时卸载，则倒数第二次挂载生效，再卸载，则倒数第三次挂载生效</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/Concurrent%20mode%20failure%E5%92%8C%20promotion%20failed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/Concurrent%20mode%20failure%E5%92%8C%20promotion%20failed/" class="post-title-link" itemprop="url">Concurrent mode failure和 promotion failed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:54:47" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>：（两种错误刚好就是三种进入老年代的方法引起的）</p>
<h2 id="一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"><a href="#一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）" class="headerlink" title="一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"></a>一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）</h2><p>原因有两种：<br>    1.年轻代提升太快，老年代的处理速度跟不上新生代的提升速度；或者新生代空间太小，放不下新产生的对象而直接转入老年代，但老年代也空间不够<br>        解决办法：<br>        ①.调大新生代空间 -Xmn<br>        ②.加大新生代晋升的阈值 -XX:MaxTenuringThreshold<br>    2.老年代碎片过多<br>        解决办法：<br>        ①.调大老年代的比例  –XX:NewRatio<br>        ②.降低老年代进行垃圾回收的阈值，<br>        -XX:CMSInitiatingOccupancyFraction=60（默认是 68）<br>        -XX:+UseCMSInitiatingOccupancyOnly<br>当老年代碎片过多时，这个过程注意cms的性能会比较差，退化成只有一个线程来收集垃圾，耗时可能有几秒或十几秒。</p>
<h2 id="二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"><a href="#二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）" class="headerlink" title="二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"></a>二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）</h2><p>一个Survivor 区不能容纳eden和另外一个survivor里面的存活对象，多余的对象进入老年代，这样就会导致老年代里面的存放大量的短暂存活的对象，<br>而我们知道，如果老年代里面没有可用空间就会发生full gc，这样就造成扫描整个堆，造成提升失败（promotion failed）。</p>
<pre><code>解决办法：增加survivor
    ①.增加年轻代的大小 -Xmn
    ②.调整survivor和eden的比例  -XX:SurvivorRatio 默认是8 ， 各占比 s0：s1 ：eden =1：1：8 ， 减小这个值也就加大了survivor。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/IoC%E5%92%8CAOP%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/IoC%E5%92%8CAOP%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">IoC和AOP的简单总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:03:14" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="IoC："><a href="#IoC：" class="headerlink" title="IoC："></a>IoC：</h2><hr>
<p>context是总管家。总领全局<br>    context创建一个bean工厂，一个解析工具（如xmlReader）。先让解析工具去完成对xml或者注解中bean的解析，对于每个bean节点，提取出其中的名称，类型、属性来构建出一个beandefinition(bd)，并存放到解析工具的map中，之后创建这个map中的bd全部移到bean工厂的map中，然后扫描出所有类型为bean初始化前置/后置处理器的bean，此时就要把它们创建好，并把它们都加到bean工厂的前置/后置处理列表中。<br>此时bean工厂中有了所有的bean的bd（但bean本身还没创建，除了前置/后置处理器bean）<br>（tiny中是全部bean都在这里创建，而在spring中，bean创建可以等到用户第一次getbean时，再触发下面的动作）<br>之后进行bean的创建，进行context的onrefresh，在bean工厂中遍历map，创建bean的实例，并且对每个bean实例做如下工作：<br>    创建后把bean实例和它的bd绑定起来（把它赋给bd的一个属性），并且从bd中取出之前设定的一些属性，给bean赋上。然后对从bean工厂中取出之前加入到前置处理器列表中的bean，使用这些处理器bean对当前的这个bean做前置处理；然后进行这个bean的初始化方法（指定的init-method），然后取出之前加入到后置处理器列表中的bean，使用这些处理器bean对当前的这个bean做后置处理（比如aop就是在这一步发挥作用，检测这个bean的类型是不是符合要拦截处理的类型，如果是，则创建用一个该类代理类型的bean代替当前的这个bean返回）； 做完前置/后置处理后都会返回bean(这个bean可能已经被修改了)，再次把这个最终经过前后置处理的bean重新与bd绑定（之前绑定的就作废了）。（真正的spring中还有给每个bean设置关于容器感知，名称感知，context感知之类的功能）<br>（如果对于特定类型的bean要执行特定的前置/后置处理，只需在处理器中判断bean的类型，满足再处理，否则就把传入的bean原样返回即可）<br>此时，bean的初始化就完成了，获取bean的话，就通过context得到bean工厂，再从bean工厂中通过要获取的bean的类型或名称得到bd，再从bd得到与之绑定的bean。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>有一个后置处理器叫AspectJAwareAdvisorAutoProxyCreator（简称apc），它的作用是在bean的后置处理时如果需要创建代理，则创建代理来代替原始bean返回<br>有一个类叫TargetSource，它可以封装一个其他类的实例对象，类型，以及它实现和继承的类型/接口集合，相当于是某个实例对象的信息组合。<br>一个类叫AdvisedSupport（具体实现是proxyFactory），它是一个aop的核心类型，它有targetsource的成员变量，有方法拦截器的成员变量，有方法匹配器的成员变量。<br>advisors实际上是包含所有需要代理的类的名单，需要拦截的方法的名单，以及所有的方法拦截器。<br>advisors由多个advisor组成，每个advisor包含一个pointcut成员，一个advice成员。<br>    pointcut定义了一组规则，包括符合条件的类型名规则，符合拦截的方法名规则。（术语是切点）<br>    advice就是一个方法拦截器.(其实就是执行额外的逻辑代码的工具) （术语是通知）<br>（这里advisor的术语就是aspect，即切面，实际上就是切点和通知的综合体）<br>每个advisor也是一个bean，它在spring中实际上就是注解了@AspectJ的类的实例，其pointcut和advice可能都是自己。（而且为了保证advisor必须在其他实例创建之前就创建好，每次有一个bean进入创建代理的后置处理器时，会从容器获得所有的advisor(利用getBeansForType)，如果有某个advisor还没创建，则优先创建它。因此会保证如果一个bean需要被代理，则其advisor一定在它用之前就创建好）</p>
<p>当有一个bean要进行apc的后置处理的时候，遍历所有的advisor，如果不符合所有的advisor类型规则，则直接返回bean；如果发现符合其中一个advisor的类型规则，进入下一步：（真正的spring中使用拦截链，也就是说可以有多个advisor匹配当前的bean，调用方法的时候会一个挨一个调用）<br>创建一个advisedSupport<br>  ·根据这个bean去创建一个它的targetSource，并且把这个targetSource设置给advisedSupport的成员<br>  ·把当前的advisor的方法规则（方法匹配器）设置给advisedSupport<br>  ·把当前advisor的方法拦截规则（方法拦截器）设置给advisedSupport</p>
<p>使用advisedSupport生成一个代理工厂，该代理工厂拥有advisedSupport的成员变量，并且这个代理工厂是一个调用处理器(InvocationHandler)。<br>    使用代理工厂去生成一个当前这个bean的代理对象。如果用jdk动态代理的话，使用<br>Proxy.newProxyInstance(当前类的类型加载器, bean的所有实现和继承的类型/接口集合, 调用处理器(也就是生成它的代理工厂)）来得到一个代理对象，这个代理对象拥有所有bean的同名方法，当调用代理对象的一个方法时，会调用它的调研处理器的invoke方法，并且会把bean的原本该名称的方法、bean对象，参数都传入invoke<br>，在调用处理器（即代理工厂）的invoke方法中，使用它的成员advisedSupport的方法匹配规则来判断当前调用的这个方法是不是需要拦截的，如果不是则直接调用bean的原来的方法；如果是需要拦截的，则使用advisedSupport的方法拦截器，去执行具体的拦截器的额外逻辑代码（这里还涉及到一个MethodInvocation，但它实际上就是对一个方法、对象、参数的包装，只是为了方便打包传递，从调用处理器传递到拦截器，没有额外的用途），当然这个额外的逻辑代码中也可以调用bean原来的方法，也可以去做一些额外的操作。<br>生成代理后返回，则此时代理对象就取代了原本的bean成为了bean容器中针对原来的bean类型的合法代言人了，别的地方不论是通过原本的类型，还是设置的名称，获得的都是这个代理，而原来的bean就只存在于代理对象的调用处理器中的advisedSupport中的targetSource中（层层包裹，外部是无法得到这个bean的）。</p>
<p>另：<br>生成代理对象的方式有jdk动态代理，还有其他一些，如Cglib2等，但原理都是一样的。</p>
<blockquote>
<p>注意，jdk动态代理生成的对象只能转成实际类实现的接口类型的对象，而无法转成实在的类的对象（而cglib能）<br>例如，A implements I<br>jdk动态代理创建好的代理proxy只能强转成I类型的，而不能强转成A类型的。</p>
</blockquote>
<blockquote>
<p>注意，InvocationHandler的invoke方法，传递过来的是proxy，而不是原始对象，所以如果要运行原本实例的方法(method.invoke)，需要在InvocationHandler中保存原本的实例</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E4%B8%ADparallel%20scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDCMS%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E4%B8%ADparallel%20scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDCMS%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">垃圾收集器GC中parallel scavenge收集器为什么不能CMS配合使用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:11:40" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先看一下收集器的分布：</p>
<p><img src="http://img.blog.csdn.net/20170102225015393" alt="垃圾收集器"></p>
<p>1.解答parallel scavenge收集器为什么不能CMS配合使用？<br>首先讲一下Hotspot，HotSpot VM里多个GC有部分共享的代码。有一个分代式GC框架，Serial/Serial Old/ParNew/CMS都在这个框架内；在该框架内的young collector和old collector可以任意搭配使用，所谓的“mix-and-match”。<br>而ParallelScavenge与G1则不在这个框架内，而是各自采用了自己特别的框架。这是因为新的GC实现时发现原本的分代式GC框架用起来不顺手。</p>
<p>ParallelScavenge（PS）的young collector就如其名字所示，是并行的拷贝式收集器。本来这个young collector就是“Parallel Scavenge”所指，但因为它不兼容原本的分代式GC框架，为了凸显出它是不同的，所以它的young collector带上了PS前缀，全名变成PS Scavenge。对应的，它的old collector的名字也带上了PS前缀，叫做PS MarkSweep。</p>
<p>这个PS MarkSweep默认的实现实际上是一层皮，它底下真正做mark-sweep-compact工作的代码是跟分代式GC框架里的serial old（这个collector名字叫做MarkSweepCompact）是共用同一份代码的。也就是说实际上PS MarkSweep与MarkSweepCompact在HotSpot VM里是同一个collector实现，包了两张不同的皮；这个collector是串行的。</p>
<p>最后：<br>重点就是Parallel Scavenge没有使用原本HotSpot其它GC通用的那个GC框架，所以不能跟使用了那个框架的CMS搭配使用。</p>
<p>新生代：使用复制算法进行GC。<br>老年代：使用标记-整理算法。</p>
<p>并发：（concurrent）用户线程与垃圾收集器同时执行（但不一定并行的，可能会交替执行）<br>并行：（parallel）多条垃圾手机线程并行，用户线程仍然等待。</p>
<p>1.新生代收集器<br>serial收集器：是新生代的一个单线程的GC，，进行GC时，停掉所有用户线程，直至回收结束，“stop-the-world”。但是其单线程的简单高效，没有线程交互的开销，常被JVM运行在client模式下的默认新生代收集器。</p>
<p>ParNew：并行收集器，是serial收集器的多线程的版本。是运行在server模式下的首先的新生代的收集器。</p>
<p>parallel scavenge ：新生代收集器，多线程，并行收集。<br>此收集器与之前的收集器目的不同：（特点）达到一个可控制的吞吐量。吞吐量=运行用户代码时间/CPU总执行时间。<br>用于精确吞吐量的两个参数：1.控制最大垃圾收集停顿时间参数 2.直接设置吞吐量大小的参数。Parallel scavenge收集器与ParNew收集器重要区别是： 垃圾自适应调节策略。</p>
<p>2.老年代收集器<br>serial old：老年代收集器版本，单线程。<br>用途：1.在JDK1.5版本之前与parallel scavenge 收集器搭配使用。<br>2.作为CMS收集器的后备预案。</p>
<p>Parallel Old ：使用多线程收集。吞吐量优先。</p>
<p>CMS：</p>
<ol>
<li>目标是：尽量缩短垃圾回收时间和用户线程的停顿时间</li>
<li>严格意义上第一款并发垃圾回收器</li>
<li>主要场景在 互联网 B/S 架构上</li>
<li>使用标记清除算法</li>
<li>步骤<br> 5.1 初始标记：STW、快；GC Root 能直接关联的对象<br> 5.2 并发标记：并发；GC Root Tracing 的过程<br> 5.3 重新标记：STW、快；修复并发标记阶段 用户线程运行时变动的对象<br> 5.4 并发清除：并发</li>
<li>因为整个过程中耗时最长的 “并发标记”和“并发清除”是和用户线程并发执行的，所以可认为CMS回收器是和用户线程并发执行的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">并发机制底层实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:02:33" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.volatile<br>    volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<p>volatile两条实现原则：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。<br> 在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。（补足64个字节，使得缓存中的头尾节点不会被读到一个缓存行中，也就不能相互锁定）<br>不应该追加字节的场景：</li>
</ol>
<ul>
<li>缓存行非64字节宽的处理器。</li>
<li>共享变量不会被频繁地写。</li>
</ul>
<p>1.synchronized<br>    用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ul>
<li>·对于普通同步方法，锁是当前实例对象。</li>
<li>·对于静态同步方法，锁是当前类的Class对象。</li>
<li>·对于同步方法块，锁是Synchonized括号里配置的对象。<br>  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br>（synchronized本质上是去获取对象对应的monitor的所有权）<br>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，<br>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。<br>》偏向锁<br>  大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</li>
</ul>
<blockquote>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>    简单说就算获得它的线程退出后先不释放锁，下一次如果还是这个线程进入的话就不用再获取锁了， 只是去比较一下是否是偏向锁且锁的markword中的线程ID是否是当前ID，<br>    如果是的话，都不用CAS，就直接进入同步块了。 如果有别的线程来竞争的话，就撤销偏向锁标志了。</p>
</blockquote>
<p>》轻量级锁</p>
<blockquote>
<p>如果当前不是偏向锁，且线程通过CAS修改锁的markword成功了，则就将其标志为轻量级锁<br>如果CAS没成功，则一直自旋CAS，如果失败到一定程度，则认为膨胀为重量级锁，修改其锁标志，这个自旋的线程再进入阻塞状态。<br>任何去竞争对象锁的线程都有权利按照规则修改其对象头的锁标志（不管是否获取到锁），但对象头的markword中的指向的锁记录的栈帧所属的线程才是该线程获得锁的标志<br>如果有线程去尝试获得锁，发现是重量级锁，就不会自旋CAS了，而是直接进入阻塞</p>
</blockquote>
<p>在Java中可以通过锁和循环CAS的方式来实现原子操作。<br>(只有AtomicXXX才能使用CAS)</p>
<p>CAS实现原子操作的三大问题</p>
<ul>
<li>ABA问题，java中使用AtomicStampedReference解决，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作。这个时候就可以用锁</li>
</ul>
<p>》使用锁机制实现原子操作<br>    锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockMaster~Lu"
      src="/images/lu.jpg">
  <p class="site-author-name" itemprop="name">RockMaster~Lu</p>
  <div class="site-description" itemprop="description">记录学习生活，力求每日进步</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-cloud"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockMaster~Lu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

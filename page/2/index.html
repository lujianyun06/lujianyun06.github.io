<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lujianyun06.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录学习生活，力求每日进步">
<meta property="og:type" content="website">
<meta property="og:title" content="RockMaster&#39;s Blog">
<meta property="og:url" content="https://lujianyun06.github.io/page/2/index.html">
<meta property="og:site_name" content="RockMaster&#39;s Blog">
<meta property="og:description" content="记录学习生活，力求每日进步">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="RockMaster~Lu">
<meta property="article:tag" content="java">
<meta property="article:tag" content="后台开发">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://lujianyun06.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>RockMaster's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RockMaster's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">0</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">31</span></a>

  </li>
        
            
  <li class="menu-item menu-item-docs">

    <a href="/docs/" rel="section"><i class="fa fa-book fa-fw"></i>Docs</a>

  </li>


      
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">Android如何替换原生应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：15:46:35" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>有个需求是把原生的日历app换成修改源码后编译生成的新app<br>尝试进入adb，须有root权限（完整的root权限）<br>用以下代码删除原生的calendar</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">pm uninstall -k --user 0 com.android.calendar</span><br></pre></td></tr></table></figure>

<p>然后要把/system挂载成可读写的（rw，一开始是只读的ro）<br>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mount</span></span><br></pre></td></tr></table></figure>
<p>可以发现/system是只读的 ro<br>然后执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">mount -o rw,remount /system</span><br><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>可以看到/system 是可读写的：rw<br>此时退出adb shell，把已经编译好的新的日历apk push进手机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push ~/newapk/Calendar.apk /system/app/Calendar</span><br><span class="line">adb shell   </span><br><span class="line">reboot   //重启手机</span><br></pre></td></tr></table></figure>
<p>此时就可以使用改后的calendar了<br>————————————————<br>版权声明：本文为CSDN博主「TheRockMaster」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43752854/article/details/84647709" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43752854/article/details/84647709</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A17/" class="post-title-link" itemprop="url">Android 音视频任务7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：16:09:45" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先做任务7，是因为做完任务4感觉想要稍微深入了解一下MediaCodec，感觉这样更能把刚学到的知识连贯一下。</p>
<p>任务7. 学习 MediaCodec API，完成音频 AAC 硬编、硬解</p>
<p>MediaCodec的作用是转换编码或解码文件，支持已编码的特定格式转成原始raw数据，<br>原始raw数据转成特定编码的格式<br>解码时，mediaCodec设定的格式是输入文件的格式，输出原始raw数据<br>编码时，mediaCodec设定的格式是输出文件的格式，输入为原始raw数据</p>
<p>解码时文件的格式和解码器设置的格式一定要一样，否则报错</p>
<h2 id="音频编解码："><a href="#音频编解码：" class="headerlink" title="音频编解码："></a>音频编解码：</h2><h3 id="解码："><a href="#解码：" class="headerlink" title="解码："></a>解码：</h3><ul>
<li>解码是吧audio/XXX给变成audio/raw，即pcm文件，最原始的未经压缩编码处理的文件。所以解码后的文件一般会比被压缩文件大得多<br>流程：</li>
<li>首先要使用MediaExtractor把音轨从文件中提取出来，把format也提取出来，根据要解码的mime创建codec：<br>mDCodec = MediaCodec.createDecoderByType(srcMIMTType);</li>
<li>把format设置到codec：mDCodec.configure(mFormat, null, null, 0); //视频文件如果要播放解码出的数据，则第二个参数选择要用于播放的surface</li>
<li>数据回调监听：mDCodec.setCallback(mDecodeCallback); （异步处理，感觉异步的好一点）</li>
<li>开始解码：mDCodec.start();<br>callback中：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="comment">//onInputBufferAvailable：当有可用的缓冲区时，会转到这里，在该函数中往可用的缓冲区写入要解码的数据，然后把缓冲区加入待处理队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得可用的缓冲</span></span><br><span class="line">            ByteBuffer inputBuffer = codec.getInputBuffer(index);</span><br><span class="line"></span><br><span class="line">            MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = mExtractor.readSampleData(inputBuffer, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> flag = mExtractor.getSampleFlags();</span><br><span class="line">            <span class="keyword">long</span> presentation = mExtractor.getSampleTime();</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"size= "</span> + size + <span class="string">" flag="</span> + flag + <span class="string">" presentation="</span> + presentation);</span><br><span class="line"><span class="comment">//要对文件是否读到末尾单独处理，若读到末尾了，size,presentation都要置为0，flag要标注为 MediaCodec.BUFFER_FLAG_END_OF_STREAM</span></span><br><span class="line">            <span class="keyword">if</span> (size != -<span class="number">1</span>) &#123;</span><br><span class="line">                inputSize += size;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">                mExtractor.advance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//当文件达到末尾时，用flag</span></span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                presentation = <span class="number">0</span>;</span><br><span class="line">                flag = MediaCodec.BUFFER_FLAG_END_OF_STREAM;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//onOutputBufferAvailable：当有待处理数据完成解码时，会放入输出缓冲区，并转到这里，在该函数中获得解码后的raw数据，并且每次读出数据后要release当前缓冲，让它能够继续被使用，否则就那么一点缓冲区，不释放的话几下就没了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MediaFormat format = codec.getOutputFormat(index);</span><br><span class="line">        Log.d(tag, <span class="string">"out format="</span> + format.getString(MediaFormat.KEY_MIME));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得可用的输出缓冲区（也就是解码好的数据）</span></span><br><span class="line">        ByteBuffer outputBuffer = codec.getOutputBuffer(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果直接定义 data =  new byte[100 * 1024]; 然后调用outputBuffer.get(data),</span></span><br><span class="line">        <span class="comment">// 则会使用data的长度去操作buffer，但buffer没这么大，导致BufferUnderflowException</span></span><br><span class="line">        <span class="comment">//所以下面两种方式选一种</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[outputBuffer.limit()];</span><br><span class="line">        outputBuffer.get(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] data = new byte[100 * 1024];</span></span><br><span class="line"><span class="comment">//        outputBuffer.get(data,0, outputBuffer.limit());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        outputSize += data.length;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.write(data); <span class="comment">//写入流中</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(tag, <span class="string">"flag="</span> + info.flags);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize= "</span> + outputSize);</span><br><span class="line">        <span class="comment">//用完后释放这个buffer，使其可以接着被使用</span></span><br><span class="line">        codec.releaseOutputBuffer(index, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//当到达末尾时，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">            Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            stopAndrealseCodec();</span><br><span class="line">            exPCM2WAV();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDCodec.release();</span><br><span class="line">        mDCodec = <span class="keyword">null</span>;</span><br><span class="line">        mExtractor.release();</span><br><span class="line">        mExtractor = <span class="keyword">null</span>;</span><br><span class="line">        Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pcm文件加入wav头变成wav文件，wav文件会被识别成audio/raw，而原始的pcm文件会被识别错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exPCM2WAV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为什么从视频里(只试了mp4和3gp)剥离出来的要 原本的sampleRate/2才是正常速度？</span></span><br><span class="line">    <span class="keyword">int</span> sampleRate = mFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE);</span><br><span class="line">    PcmToWavUtil util = <span class="keyword">new</span> PcmToWavUtil(sampleRate, mFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT),</span><br><span class="line">            AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line">    Log.d(tag, <span class="string">"sampleRate="</span> + sampleRate);</span><br><span class="line">    util.pcmToWav(outputFileName, outputFileName + <span class="string">".wav"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h3><p>编码是吧audio/raw给变成audio/XXX，是对原始数据压缩编码，但这个有一个问题要注意的是硬件是否支持这种编码方式，比如nexus6p，由于mp3格式编码是不开源的，所以不能编码成mp3文件。下面以把wav的原生格式编码成aac<br>流程：<br><em>编码要比解码多一个步骤，就是设置要编码的格式的各项数据，比如</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">outFormat = MediaFormat.createAudioFormat(desMIMEType, SAMPLE_RATE, CHANNEL_COUNT); <span class="comment">//根据编码格式，采样率，声道数创建format</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>); <span class="comment">//比特率</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_AAC_PROFILE,  MediaCodecInfo.CodecProfileLevel.AACObjectLC);  <span class="comment">//aac特有的profile</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, <span class="number">100</span> * <span class="number">1024</span>);<span class="comment">//输入缓存的最大值，设置这个防止一帧的数据量太大而超过默认的buffer大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加aac的csd-0，如果是视频，则csd-0和csd-1都要有（这个是干什么的还不清楚）</span></span><br><span class="line">ByteBuffer csd = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((aacObjLC &lt;&lt; <span class="number">3</span>) | (sampleIndex &gt;&gt; <span class="number">1</span>)));</span><br><span class="line">csd.position(<span class="number">1</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((<span class="keyword">byte</span>) ((sampleIndex &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x80</span>) | (channelCount &lt;&lt; <span class="number">3</span>)));</span><br><span class="line">csd.flip();</span><br><span class="line">outFormat.setByteBuffer(<span class="string">"csd-0"</span>, csd); <span class="comment">// add csd-0</span></span><br><span class="line">System.out.println(Arrays.toString(csd.array()) + <span class="string">"===++”);</span></span><br><span class="line"><span class="string">查看设备支持的编码和解码器：</span></span><br><span class="line"><span class="string">MediaCodecList list = new MediaCodecList(MediaCodecList.ALL_CODECS);</span></span><br><span class="line"><span class="string">MediaCodecInfo[] infos = list.getCodecInfos();</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; infos.length; i++) &#123;</span></span><br><span class="line"><span class="string">    String name = infos[i].getName();</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>i=<span class="string">" + i + "</span> name=<span class="string">" + name);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">根据format创建相应的编码器</span></span><br><span class="line"><span class="string">//根据相应的格式找到是否有合适的编码器，如果有则返回其名称，然后创建相应的编码器</span></span><br><span class="line"><span class="string">String encodeName = list.findEncoderForFormat(outFormat);</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>encodeName=<span class="string">" + encodeName);</span></span><br><span class="line"><span class="string">    mECodec = MediaCodec.createByCodecName(encodeName);</span></span><br><span class="line"><span class="string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="string">    e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">mECodec.setCallback(mEncodeCallback); //设置回调</span></span><br><span class="line"><span class="string">mECodec.configure(outFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);  //编码配置，编码时要设置最后一个参数</span></span><br><span class="line"><span class="string">mECodec.start();  //开始编码</span></span><br></pre></td></tr></table></figure>
<p>callback中：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">on</span>InputBufferAvailable和解码器的并无不同，都是由MediaExtractor读出数据放到缓存队列里等待处理</span><br></pre></td></tr></table></figure>

<p>onOutputBufferAvailable和默认流程和解码器类似，都是从缓冲队列中取出已经处理好的数据（每次取一帧），但编码器不同的一点是，这个数据只是真实数据流的编码，仅仅有这些没办法封装成可读的格式，还必须要加上可识别的部分，比如wav文件是在所有数据头部加上wav头，aac文件是在每一帧数据前面加上adts头，<br>adts见 <a href="https://www.cnblogs.com/lihaiping/p/5284547.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihaiping/p/5284547.html</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> outIndex = index;</span><br><span class="line">            MediaFormat format = codec.getOutputFormat(outIndex);</span><br><span class="line"></span><br><span class="line">            ByteBuffer outputBuffer = codec.getOutputBuffer(outIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = outputBuffer.limit();</span><br><span class="line">            outputSize += size;</span><br><span class="line">            <span class="keyword">byte</span>[] packedData = <span class="keyword">new</span> <span class="keyword">byte</span>[size + <span class="number">7</span>];</span><br><span class="line">            addADTStoPacket(packedData, packedData.length);</span><br><span class="line">            outputBuffer.get(packedData, <span class="number">7</span>, size);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.write(packedData);</span><br><span class="line">                fos.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用完后释放这个buffer，使其可以接着被使用，如果一直不释放，如果文件太大则会导致缓冲区不够用</span></span><br><span class="line">            outputBuffer.clear();</span><br><span class="line">            codec.releaseOutputBuffer(outIndex, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">                stopAndrealseCodec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一帧前面都要加上ADTS头，可以看做是每一个AAC帧的帧头</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>;  <span class="comment">//AAC LC</span></span><br><span class="line">        <span class="comment">//39=MediaCodecInfo.CodecProfileLevel.AACObjectELD;</span></span><br><span class="line">        <span class="keyword">int</span> freqIdx = <span class="number">4</span>;  <span class="comment">//44.1KHz</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">2</span>;  <span class="comment">//CPE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] packet1 = new byte[packetLen];</span></span><br><span class="line">        <span class="comment">// fill in ADTS data</span></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (freqIdx &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //把这些清晰的放出来，但最好还是用上面的方式</span></span><br><span class="line"><span class="comment">//        //syncword</span></span><br><span class="line"><span class="comment">//        packet[0] = (byte) 0xFF;</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0xF &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //id</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1 &lt;&lt; 3;</span></span><br><span class="line"><span class="comment">//        //layer</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x00 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //protection_abscent</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1;</span></span><br><span class="line"><span class="comment">//        //profile</span></span><br><span class="line"><span class="comment">//        packet[2] |= (profile -1) &lt;&lt; 6;</span></span><br><span class="line"><span class="comment">//        //sampling_frequency_index</span></span><br><span class="line"><span class="comment">//        packet[2] |= freqIdx &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //private bit</span></span><br><span class="line"><span class="comment">//        packet[2] |= 0x0 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //channel_config</span></span><br><span class="line"><span class="comment">//        packet[2] |= chanCfg &gt;&gt; 2;  //高1位</span></span><br><span class="line"><span class="comment">//        packet[3] |= chanCfg &lt;&lt; 6;   //低2位</span></span><br><span class="line"><span class="comment">//        //copy and home;</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //cib and cis</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //frame_length,单位是字节。不用管int是几个字节，把它当13位就行了,一帧的长度一般不可能超过13位能表达的最大值(8KB),</span></span><br><span class="line"><span class="comment">//        packet[3] |= packetLen &gt;&gt; 11;</span></span><br><span class="line"><span class="comment">//        packet[4] = (byte) (packetLen &gt;&gt; 3);</span></span><br><span class="line"><span class="comment">//        int x = packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//        packet[5] |= packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        packet[5] |= 0x7FF &gt;&gt; 6;</span></span><br><span class="line"><span class="comment">//        packet[6] |= 0x7FF &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mECodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mECodec.release();</span><br><span class="line">            mECodec = <span class="keyword">null</span>;</span><br><span class="line">            mExtractor.release();</span><br><span class="line">            mExtractor = <span class="keyword">null</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">            Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">            Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码见 <a href="https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7" target="_blank" rel="noopener">https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A13/" class="post-title-link" itemprop="url">Android 音视频任务3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：16:04:48" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>任务3. 在 Android 平台使用 Camera API 进行视频的采集，分别使用 SurfaceView、TextureView 来预览 Camera 数据，取到 NV21 的数据回调</p>
<p>由于这次的任务牵涉面十分广，所以用了很久才搞懂了一些知识，以后的任务也应该会做的越来越慢，不过十分合理，慢工出细活，上来一会儿就完成的东西，要不就是含金量不高，要不就是没有深究，对于学习阶段，虽然说有时候要管中窥豹不要太深究，但有些事情不搞清楚就不能算掌握知识了对吧？</p>
<p>下面是使用CameraAPI进行拍照和录视频，当然还有预览的全过程。虽然CameraAPI在5.0后就被弃用了（原因之一是它不能同时预览和拍摄），取而代之的是camera2，但由于众所周知的原因，仍然要好好学习。</p>
<p>添加权限后，如果是android6以上的，必须在设置的应用里面手动打开申请的权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera.autofocus"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>相机的角度，如果不加调整的打开相机，默认的角度是0°，（这一点很奇怪。。）一般竖屏状态下是90度，横屏则为0或180度(应该是取决于传感器的方向)</p>
<h2 id="拍摄照片"><a href="#拍摄照片" class="headerlink" title="拍摄照片"></a>拍摄照片</h2><p>使用Camera拍摄照片的步骤：<br>要使用此类拍摄照片，请使用以下步骤：</p>
<ol>
<li>从open（int）获取Camera的实例。(首先使用以下方法获得设备摄像头数目)<br>int cameraNum = Camera.getNumberOfCameras();<br>//上面open的有效取值是 0 ~ cameraNum-1 代表了摄像头的设备id</li>
<li>使用getParameters（）获取现有（默认）设置。如有必要，修改返回的Camera.Parameters对象并调setParameters（Camera.Parameters）</li>
<li>调用setDisplayOrientation（int）以确保正确的预览方向。<br>  重要提示：将完全初始化的SurfaceHolder传递给    setPreviewDisplay（SurfaceHolder）。没有surface，相机将无法启动预览。<br> 重要说明：调用startPreview（）开始更新预览曲面。必须先开始预览才能拍照。</li>
<li>如果需要，可以调用takePicture（Camera.ShutterCallback，Camera.PictureCallback，Camera.PictureCallback，Camera.PictureCallback）来捕获照片。等待回调提供实际的图像数据。</li>
<li>拍照后，预览显示将停止。要拍摄更多照片，请先再次调用startPreview（）。</li>
<li>调用stopPreview（）以停止更新预览surface。<br>   重要提示：调用release（）以释放相机以供其他应用程序使用。应用程序应立即在Activity.onPause（）中释放相机（并在Activity.onResume（）中重新打开它）。</li>
</ol>
<p>一般自定义的来说，surface显示的图像都会被拉伸，或者压扁，反正就是图像比例不对，这是由于surfaceView和Camera.Size不匹配导致的，所以要根据surfaceView的宽高，在Camera所支持的Size里面找一个最合适的</p>
<p>在启用startPreview后，就可以通过Camera.takePicture()方法拍摄一张照片，返回的照片数据通过Callback接口获取。takePicture()接口可以获取三个类型的照片：</p>
<ul>
<li>第一个，ShutterCallback接口，在快门瞬间被回调，通常用于播放“咔嚓”这样的音效；</li>
<li>第二个，PictureCallback接口，返回未经压缩的RAW类型照片(字节数组)；</li>
<li>第三个，PictureCallback接口，返回经过压缩的JPEG类型照片(字节数组)；</li>
</ul>
<p>这三个都可以不实现，第一个一般没啥影响，但第二个第三个不实现则相当于拍的东西就没了。（第二第三个可以选一个实现）调用此方法后，在返回JPEG回调之前，不得调用startPreview（）或拍摄另一张照片。</p>
<p>camera.setDisplayOrientation(90); //设定的是预览的方向，预览和数据是独立的，如果只设置了DisplayOrientation，则在surfaceView中显示正常，但保存的数据仍然是0°的</p>
<p>修改拍摄数据角度的两种方法(以下均是竖屏情况，横屏情况不用额外处理，因为默认是横屏情况)：</p>
<ol>
<li>直接在设置camera参数的时候设置 parameters.setRotation(90); //这样拍摄出的data就是修正过后的数据，直接写到文件里即可<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        os.write(data);</span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCamera.startPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不设置相机的Rotation，这样得到的数据是横屏情况下的，要使用Matrix和Bitmap进行修正<br>parameters.setPreviewFormat(ImageFormat.NV21); //默认预览帧格式为NV21,注意很多格式设备可能不支持，程序就会崩,如nexus6p不支持YUY2</li>
</ol>
<h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><h4 id="使用surfaceView"><a href="#使用surfaceView" class="headerlink" title="使用surfaceView"></a>使用surfaceView</h4><ol>
<li>像上面一样获得camera的实例并初始化它，并开启preview</li>
<li>调用unlock()允许mediaRecorder的工作线程使用设定好参数的camera</li>
<li>把camera实例传给MediaRecorder.setCamera(Camera) </li>
<li>设置用于预览的surface：MediaRecorder.setPreviewDisplay（如果camera没绑定surface，则此步骤会替换camera的surface为本参数）<br>//以下为设置录制的参数<br>设置视频源setVideoSource： 一般为摄像头<br>设置音频源setAudioSource:一般是CAMCORDER(单纯录视频是没声音的)  如果是用mediaRecorder单录音频的话，一般用MIC<br>设置输出文件格式：setOutputFormat<br>设置视频的角度：setOrientationHint //预览角度在camera的参数里设置<br>//下面的必须要放在输出格式确定后<br>设置视频编码：setVideoEncoder<br>设置音频编码:setAudioEncoder<br>//下面的必须要放在编码确定后<br>设置视频分辨率：setVideoSize; 这里的分辨率必须要选择设备摄像头支持的分辨率,否则报错(Camera.getParameters().getSupportedPreviewSizes()的值之一)<br>设置录制视频的捕获帧速率：setVideoFrameRate(); //必须要选择摄像头支持的帧率，否则报错（mCamera.getParameters().getSupportedPreviewFrameRates()的值之一）<br>设置所录制视频的编码位率:setVideoEncodingBitRate(3 * 1024 * 1024);<br>设置记录会话的最大持续时间(毫秒)setMaxDuration(30 * 1000);<br>设置输出文件的路径：setOutputFile</li>
<li>当完成录制后，调用camera.reconnect把camera的使用权从mediaRecorder的工作线程转回到设置了它的本线程</li>
<li>调用mediaRecorder调用stop和release 释放资源<br>一些总结性的概述：<br>surfaceView 只是一个用来占位置的控件，是用来显示surface内容的，它会显示它绑定的SurfaceHolder所持有的surface， 真正用于显示的是surface(它是具体的要显示的数据)，surface的持有者是SurfaceHolder，每个surfaceView生来就有一个默认与其绑定的SurfaceHolder，通过getHolder来获取，SurfaceHolder会决定如何去显示surface，每个surface有且只有一个SurfaceHolder，<br>surfaceView:画布<br>surface：画的内容<br>surfaceHolder，画内容的持有者<br>surfaceView、surfaceHolder、surface三位一体，是一个不可分的整体</li>
</ol>
<blockquote>
<p>一个camera设置好参数，它本身是被本线程持有的，持有的话是被lock的，mediaRecorder的工作是在单独的线程中完成的<br>使用setCamera给mediarecorder设置一个被设置好相机。而如果不调用setCamera设置相机的话，分配给的是一个默认情况下的相机，也就是说什么参数都没有被设置，这样一般不可能满足拍摄需求，因此一般要给mediaRecorder设置camera<br><br>在mediaRecorder.start之前，它的camera必须要调用unlock(如果设置了的话)，因为mediaRecorder的工作是在单独的线程中完成的，而camera默认是被创建它的线程所持有的，这样mediaRecorder的工作线程无法使用它)，如果start顺利结束，则会自动调用lock归还camera，如果start调用失败，则要手动lock来回收camera的所有权</p>
<p>mediaRecorder.setPreviewDisplay(Surface s)<br>给mediaRecorder设置surface，surface是用来显示mediaRecorder的相机的预览。如果s已经被一个设置给了camera（只是设置给了，还没有被持有资源），而且这个camera已经通过mediaRecorder.setCamera被设置给了mediaRecorder，那么这个方法不需要调用。如果s已经被设置给了一个另一个camera，只是设置给了，还没有被持有资源），但这个camera没有被设置给mediaRecorder，那么这个s将会被设置给给mediaRecorder自己的camera（如果没设置，则是默认的camera）。此时mediaRecorder自己的camera和另一个camera被设置了同一个surface.<br>如果s为空，则完全不会发生任何事</p>
<p><br>camera.setHolder<br>给camera设置一个holder，即surface；但此时holder的surface资源并不为camera所持有，只有当开启预览(即startPreview)时，surface资源才会被camera所持有（下面所说的surface和相应的surfaceHolder都是绑定的，彼此一体，surface资源也就相当于holder的资源）</p>
<p>如果对一个camera持有一个surface的资源，再次让另一个camera再次去持有这个surface资源，则会报错(mediaRecorder.start中会调用类似于它自己的camera.startPreview,startPreview会试图去占有surface资源)也就是说，同一个surfaceHolder可以被多个camera设置，但同时只能有一个camera持有它的surface的资源，否则就会报错。可以对同一个camera连续多次试图持有资源（反正资源就是你的，反复持有还是这些）.<br><br>当用startPreview成功开启预览后,surface的资源就被camera持有，此时单纯调用stopPreview关闭预览并不能释放它所持有的surface资源，必须要用camera.release(完全释放camera)，或者直接setDisplayHolder（null）（只释放camera占有的surface资源，不改变camera的其他参数设置）才能释放它占用的surface资源。但不能直接把camera置为null来释放资源，因为这样只能减少它的引用计数，不是真正的释放资源。</p>
</blockquote>
<p>mediaRecorder 不会吧自己的surface主动连接到自己设置的camera, 除非是不设置camera而使用默认的camera，因为mediaRecorder会默认自己设置的camera有surface</p>
<p>camera.setDisplayOrientation设置相机预览的角度，mediaRecorder.setOrientationHini设置存储的视频的角度，两者互相独立</p>
<h4 id="使用TextureView"><a href="#使用TextureView" class="headerlink" title="使用TextureView"></a>使用TextureView</h4><p>TextureViewView:<br>TextureView可用于显示内容流。 这样的内容流可以例如是视频或OpenGL场景。 内容流可以来自应用程序的进程以及远程进程。</p>
<p>TextureView只能在硬件加速窗口中使用。 在软件中渲染时，TextureView将不会绘制任何内容。(例如在xml中给textureView设置背景色，就直接会报错)</p>
<p>与SurfaceView不同，TextureView不会创建单独的窗口，而是表现为常规View。 这个关键区别允许它进行移动，转换，动画等。例如，您可以通过调用myView.setAlpha（0.5f）使TextureView半透明。</p>
<p>使用TextureView很简单：您需要做的就是获得它的SurfaceTexture。 然后，把SurfaceTexture用来呈现内容。 以下示例演示如何将相机预览渲染到TextureView中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveCameraActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">TextureView</span>.<span class="title">SurfaceTextureListener</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> Camera mCamera;</span><br><span class="line">      <span class="keyword">private</span> TextureView mTextureView;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">          mTextureView = <span class="keyword">new</span> TextureView(<span class="keyword">this</span>);</span><br><span class="line">          mTextureView.setSurfaceTextureListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">          setContentView(mTextureView);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          mCamera = Camera.open();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mCamera.setPreviewTexture(surface);</span><br><span class="line">              mCamera.startPreview();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">              <span class="comment">// Something bad happened</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Ignored, Camera does all the work for us</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">          mCamera.stopPreview();</span><br><span class="line">          mCamera.release();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Invoked every time there's a new Camera preview frame</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过调用getSurfaceTexture（）或使用TextureView.SurfaceTextureListener来获取TextureView的SurfaceTexture。 重要的是要知道只有在将TextureView附加到窗口（并且已调用onAttachedToWindow（）之后）才能使用SurfaceTexture。因此，强烈建议您使用listener在SurfaceTexture可用时进行通知。</p>
<p>值得注意的是，只有一个生产者可以使用TextureView。 例如，如果使用TextureView显示相机预览，则无法使用lockCanvas（）同时绘制到TextureView。<br>如同surface一样，TextureView的surfaceTexture资源同一时间也只能被一个对象所持有</p>
<p>———————————————————————————————————————————————————————————————<br>SurfaceTexture:<br>从图像流中捕获帧作为OpenGL ES纹理。</p>
<p>图像流可以来自相机预览或视频解码。从SurfaceTexture创建的Surface可以用作android.hardware.camera2，MediaCodec，MediaPlayer和Allocation API的输出目标。调用updateTexImage（）时，将更新创建SurfaceTexture时指定的纹理对象的内容，以包含图像流中的最新图像。这可能导致跳过一些流的帧。</p>
<p>在指定旧版Camera API的输出目标时，也可以使用SurfaceTexture代替SurfaceHolder。这样做会导致图像流中的所有帧都被发送到SurfaceTexture对象而不是设备的显示。</p>
<p>从纹理中采样时，应首先使用通过getTransformMatrix（float []）查询的矩阵变换纹理坐标。每次调用updateTexImage（）时变换矩阵都会改变，因此每次更新纹理图像时都应该重新查询。该矩阵将形式为（s，t，0,1）的传统2D OpenGL ES纹理坐标列向量转换为包含区间[0,1]上的s和t到流式纹理中的适当采样位置。此变换可补偿图像流源的任何属性，使其看起来与传统的OpenGL ES纹理不同。例如，可以通过使用查询的矩阵变换列向量（0,0,0,1）来完成从图像左下角的采样，而从图像的右上角进行采样可以通过变换来完成（ 1,1,0,1）。</p>
<p>纹理对象使用GL_TEXTURE_EXTERNAL_OES纹理目标，该目标由GL_OES_EGL_image_external OpenGL ES扩展定义。这限制了纹理的使用方式。每次绑定纹理时，它必须绑定到GL_TEXTURE_EXTERNAL_OES目标而不是GL_TEXTURE_2D目标。此外，从纹理中采样的任何OpenGL ES 2.0着色器必须使用例如“#extension GL_OES_EGL_image_external：require”指令声明其对此扩展的使用。此类着色器还必须使用samplerExternalOES GLSL采样器类型访问纹理。</p>
<p>可以在任何线程上创建SurfaceTexture对象。 updateTexImage（）只能在包含纹理对象的OpenGL ES上下文的线程上调用。在任意线程上调用可用帧的回调，因此除非特别小心，否则不应直接从回调中调用updateTexImage（）。<br>———————————————————————————————————————————————————————————————</p>
<p>录制流程：<br>其他步骤均和surfaceView一样，只有第四步有区别,由于此时不能获得surfaceHolder，只要把TextureView的SurfaceTexture绑定到相机即可（给camera设置用于预览的surfaceTexture：camera.setPreviewTexture（代替camera.setPreviewDisplay)，同时而且也不需要给mediaRecorder调用setPreviewDisplay）</p>
<p>MediaRecorder：用来录制音频和视频，录制控制基于简单的状态机，如下图：<br><img src="https://img-blog.csdnimg.cn/20181205184528266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>使用MediaRecorder录制<strong>音频</strong>的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A common <span class="keyword">case</span> of using MediaRecorder to record audio works as follows:</span><br><span class="line">MediaRecorder recorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line"> recorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line"> recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class="line"> recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);</span><br><span class="line"> recorder.setOutputFile(PATH_NAME);</span><br><span class="line"> recorder.prepare();</span><br><span class="line"> recorder.start();   <span class="comment">// Recording is now started</span></span><br><span class="line"> ...</span><br><span class="line"> recorder.stop();</span><br><span class="line"> recorder.reset();   <span class="comment">// You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line"> recorder.release(); <span class="comment">// Now the object cannot be reused</span></span><br></pre></td></tr></table></figure>
<p>//这个不需要手动另开线程写数据，体积小使用方便，但很大的一个缺点就是录下的音质不太好。相比之下AudioRecord虽然麻烦一点，但录制的更像是无损音质</p>
<p>application可能希望注册信息和错误事件，以便在录制期间获知某些内部更新和可能的运行时错误。 通过设置适当的监听器（通过调用（到setOnInfoListener（OnInfoListener）setOnInfoListener和/或setOnErrorListener（OnErrorListener）setOnErrorListener）来注册此类事件。为了接收与这些侦听器关联的相应回调，应用程序需要在运行Looper的线程上创建MediaRecorder对象 （默认情况下，主UI线程已经运行了Looper）。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">使用MediaRecorder报错at android.media.MediaRecorder.start(Native <span class="function"><span class="keyword">Method</span>)：很可能是如下原因:</span> </span><br><span class="line"><span class="number">1</span>.使用下面两个函数但参数不被当前硬件所支持</span><br><span class="line">mediaRecorder.setVideoFrameRate()和mediaRecorder.setVideoSize(videoWidth, videoHeight)</span><br><span class="line"><span class="comment">//注释掉后，会使用硬件支持的默认的参数，就不会出错了,</span></span><br><span class="line">要获得硬件支持的参数用如下的函数：</span><br><span class="line">mCamera.getParameters().getSupportedPreviewSizes()的值之一</span><br><span class="line">mCamera.getParameters().getSupportedPreviewFrameRates()的值之一</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.已经有其他摄像头开启过预览，持有了SurfaceView或SurfaceTexture的surface资源，但停止预览后没有释放资源</span><br><span class="line"></span><br><span class="line">另：mediaRecorder.setVideoSize不能设置的太大，否则点击录像后画面会停住</span><br></pre></td></tr></table></figure>
<h5 id="相机预览数据的获取"><a href="#相机预览数据的获取" class="headerlink" title="相机预览数据的获取"></a>相机预览数据的获取</h5><p>转自：<a href="https://blog.csdn.net/lb377463323/article/details/53338045" target="_blank" rel="noopener">https://blog.csdn.net/lb377463323/article/details/53338045</a><br>首先定义一个类实现Camera.PreviewCallback接口，然后在它的onPreviewFrame(byte[] data, Camera camera)方法中即可接收到每一帧的预览数据，也就是参数data。<br>然后使用setPreviewCallback()、setOneShotPreviewCallback或setPreviewCallbackWithBuffer()注册回调接口，下面介绍一下这些方法： </p>
<pre><code>1，void setPreviewCallback (Camera.PreviewCallback cb) </code></pre><p>一旦使用此方法注册预览回调接口，onPreviewFrame()方法会一直被调用，直到camera preview销毁</p>
<p>注意，onPreviewFrame()方法跟Camera.open()是运行于同一个线程，所以为了防止onPreviewFrame()会阻塞UI线程，将Camera.open()放置在子线程中运行。</p>
<pre><code>2，void setOneShotPreviewCallback (Camera.PreviewCallback cb) </code></pre><p>使用此方法注册预览回调接口时，会将下一帧数据回调给onPreviewFrame()方法，调用完成后这个回调接口将被销毁。也就是只会回调一次预览帧数据。</p>
<pre><code>3，void setPreviewCallbackWithBuffer (Camera.PreviewCallback cb) </code></pre><p>它跟setPreviewCallback的工作方式一样，但是要求指定一个字节数组作为缓冲区，用于预览帧数据，这样能够更好的管理预览帧数据时使用的内存。它一般搭配addCallbackBuffer方法使用，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] mPreBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//首先分配一块内存作为缓冲区，size的计算方式见第四点中</span></span><br><span class="line">mCamera.addCallbackBuffer(mPreBuffer);</span><br><span class="line">mCamera.setPreviewCallbackWithBuffer(Camera.PreviewCallback cb);</span><br><span class="line">mCamera.startPreview();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPreBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPreBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    mCamera.addCallbackBuffer(mPreBuffer);<span class="comment">//将此缓冲区添加到预览回调缓冲区队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setPreviewCallbackWithBuffer需要在startPreview()之前调用，因为setPreviewCallbackWithBuffer使用时需要指定一个字节数组作为缓冲区，用于预览帧数据，所以我们需要在setPreviewCallbackWithBuffer之前调用addCallbackBuffer，这样onPreviewFrame的data才有值。</p>
<p>总结一下，设置addCallbackBuffer的地方有两个，一个是在startPreview之前，一个是在onPreviewFrame中，这两个都需要调用，如果在onPreviewFrame中不调用，那么预览帧数据就不会回调给onPreviewFrame了</p>
<pre><code>4，void addCallbackBuffer (byte[] callbackBuffer) </code></pre><p>添加一个预分配的缓冲区到预览回调缓冲区队列中。应用程序可一添加一个或多个缓冲器到这个队列中。当预览帧数据到达时并且缓冲区队列仍然有至少一个可用的缓冲区时，这个 缓冲区将会被消耗掉然后从队列中移除，然后这个缓冲区会调用预览回调接口。如果预览帧数据到达时没有剩余的缓冲区，这帧数据将会被丢弃。当缓冲区中的数据处理完成后，应用程序应该将这个缓冲区添加回缓冲区队列中。<br>对于非YV12的格式，缓冲区的Size是预览图像的宽、高和每个像素的字节数的乘积。宽高可以使用getPreviewSize()方法获取。每个像素的字节数可以使用ImageFormat.getBitsPerPixel(mCameraParameters.getPreviewFormat()) / 8获取。<br>对于YU12的格式，缓冲区的Size可以使用setPreviewFormat(int)里面的公式计算，具体详见官方文档。<br>这个方法只有在使用setPreviewCallbackWithBuffer(PreviewCallback)时才有必要使用。当使用setPreviewCallback(PreviewCallback) 或者setOneShotPreviewCallback(PreviewCallback)时，缓冲区会自动分配。当提供的缓冲区如果太小了，不能支持预览帧数据时，预览回调接口将会return null，然后从缓冲区队列中移除此缓冲区。</p>
<p>完整代码：只需在activity里面调用runTask3即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.SurfaceTexture;</span><br><span class="line"><span class="keyword">import</span> android.hardware.Camera;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaRecorder;</span><br><span class="line"><span class="keyword">import</span> android.os.AsyncTask;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceHolder;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceView;</span><br><span class="line"><span class="keyword">import</span> android.view.TextureView;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lll.va.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task3</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">TextureView</span>.<span class="title">SurfaceTextureListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SurfaceHolder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String tag = Task3<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line">    <span class="keyword">private</span> CameraUtil mCameraUtil;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> SurfaceView surfaceView;</span><br><span class="line">    <span class="keyword">private</span> TextureView textureView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Task3 task3;</span><br><span class="line">    <span class="keyword">private</span> Activity mActivity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSurfaceMode;  <span class="comment">//切换surfaceview和textureview的演示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String videoFileName = Environment.getExternalStorageDirectory() + <span class="string">"/test_vedio.mp4"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTask3</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        task3 = <span class="keyword">new</span> Task3(activity);</span><br><span class="line">        task3.initView();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task3</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mActivity = activity;</span><br><span class="line">        mContext = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mActivity.setContentView(R.layout.activity_task3);</span><br><span class="line"></span><br><span class="line">        surfaceView = mActivity.findViewById(R.id.sv_t3);</span><br><span class="line">        textureView = mActivity.findViewById(R.id.texture_view_1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了知道surface的生命周期，一般只有surface建好后才开始下一步动作</span></span><br><span class="line">        <span class="comment">//surfaceView必须给holder添加callback，TextureView必须给自己添加listener</span></span><br><span class="line">        <span class="keyword">if</span> (surfaceView.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            isSurfaceMode = <span class="keyword">true</span>;</span><br><span class="line">            surfaceView.getHolder().addCallback(<span class="keyword">this</span>);</span><br><span class="line">            mHolder = surfaceView.getHolder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isSurfaceMode = <span class="keyword">false</span>;</span><br><span class="line">            textureView.setSurfaceTextureListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Button btnTakePic = mActivity.findViewById(R.id.btn_take_pic);</span><br><span class="line">        Button btnStartVideo = mActivity.findViewById(R.id.btn_start_video);</span><br><span class="line">        Button btnStopVideo = mActivity.findViewById(R.id.btn_stop_video);</span><br><span class="line">        btnTakePic.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStartVideo.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStopVideo.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getWidthAndHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        width = isSurfaceMode ? surfaceView.getWidth() : textureView.getWidth();</span><br><span class="line">        height = isSurfaceMode ? surfaceView.getHeight() : textureView.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.release();</span><br><span class="line">            mCamera = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(tag, <span class="string">"is surfaceview = "</span> + isSurfaceMode);</span><br><span class="line">        mCameraUtil = CameraUtil.getInstance();</span><br><span class="line">        mCamera = mCameraUtil.openCamera(<span class="number">0</span>);</span><br><span class="line">        Bundle paramBundle = <span class="keyword">new</span> Bundle();  <span class="comment">//感觉干脆用bundle传参好了</span></span><br><span class="line">        getWidthAndHeight();</span><br><span class="line">        paramBundle.putInt(<span class="string">"width"</span>, width);</span><br><span class="line">        paramBundle.putInt(<span class="string">"height"</span>, height);</span><br><span class="line">        mCameraUtil.setCameraParamter(mContext, mCamera, paramBundle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据不同的view，选择不同的预览载体</span></span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                mCamera.setPreviewDisplay(surfaceView.getHolder());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.setPreviewTexture(textureView.getSurfaceTexture());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预览监听</span></span><br><span class="line">        mCamera.setPreviewCallback(mCameraCallback);</span><br><span class="line"><span class="comment">//        mCamera.setPreviewCallbackWithBuffer(mCameraCallback);</span></span><br><span class="line">        <span class="comment">//开始预览</span></span><br><span class="line">        mCamera.startPreview();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************  录视频部分   *******************************/</span></span><br><span class="line">    MediaRecorder mediaRecorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startVideoRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mediaRecorder = <span class="keyword">new</span> MediaRecorder();<span class="comment">// 创建mediarecorder对象</span></span><br><span class="line">        <span class="comment">// 设置录制视频源为设置好参数的Camera(相机)</span></span><br><span class="line">        mediaRecorder.setOnInfoListener(mediaCallbackListener);</span><br><span class="line">        mediaRecorder.setOnErrorListener(mediaCallbackListener);</span><br><span class="line">        mCamera.unlock();</span><br><span class="line"></span><br><span class="line">        mediaRecorder.setCamera(mCamera);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode)<span class="comment">//如果给camera设置了setPreviewDisplay，则这句可以不加</span></span><br><span class="line">            mediaRecorder.setPreviewDisplay(mHolder.getSurface());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"camera + "</span> + mCamera);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line">        mediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">        <span class="comment">// 设置录制完成后视频的封装格式THREE_GPP为3gp.MPEG_4为mp4</span></span><br><span class="line">        mediaRecorder</span><br><span class="line">                .setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">        <span class="comment">// 设置录制的视频编码h264</span></span><br><span class="line">        <span class="comment">//音频编码为AAC</span></span><br><span class="line">        mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">        mediaRecorder.setOrientationHint(<span class="number">90</span>);</span><br><span class="line">        <span class="comment">// 设置视频录制的分辨率。必须放在设置编码和格式的后面，否则报错</span></span><br><span class="line">        mediaRecorder.setVideoSize(<span class="number">1600</span>, <span class="number">1200</span>);</span><br><span class="line">        mediaRecorder.setVideoEncodingBitRate(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>);<span class="comment">// 设置编码位率,图像模糊的设置了这个图像就清晰了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置录制的视频帧率。必须放在设置编码和格式的后面，否则报错</span></span><br><span class="line">        mediaRecorder.setVideoFrameRate(<span class="number">24</span>);</span><br><span class="line"><span class="comment">//        mediaRecorder.setPreviewDisplay(mHolder.getSurface());</span></span><br><span class="line">        <span class="comment">// 设置视频文件输出的路径</span></span><br><span class="line">        mediaRecorder.setOutputFile(Task3.videoFileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备录制</span></span><br><span class="line">            mediaRecorder.prepare();</span><br><span class="line">            <span class="comment">// 开始录制</span></span><br><span class="line">            mediaRecorder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopVideoRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaRecorder == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        mediaRecorder.stop();</span><br><span class="line">        mediaRecorder.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera.lock();</span><br><span class="line">            mCamera.reconnect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这或许是camera的bug，预览的时候不能同时进行拍摄，如果拍摄结束后还需要预览</span></span><br><span class="line">            <span class="comment">//要再setPreviewCallback和startPreview，貌似在camera2中解决了</span></span><br><span class="line">            mCamera.setPreviewCallback(mCameraCallback);</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line"><span class="comment">//            mCamera.lock();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CameraCallback mCameraCallback = <span class="keyword">new</span> CameraCallback();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CameraCallback</span> <span class="keyword">implements</span> <span class="title">Camera</span>.<span class="title">PreviewCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = data.length;</span><br><span class="line">            <span class="comment">//当相机的预览分辨率为1600 * 1200，预览图像的编码格式为 NV21 即 12bit/pixel 时</span></span><br><span class="line">            <span class="comment">//每一帧图像的大小应该为 1600 * 1200 * 12 / 8 = 2880000 Bytes</span></span><br><span class="line">            Log.d(tag, <span class="string">"onPreviewFrame data.data len="</span> + len);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MediaCallbackListener mediaCallbackListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************  SurfaceTextureListener  **********************************/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSurfaceMode)</span><br><span class="line">            initCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************  SurfaceCallback  **********************************/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode)</span><br><span class="line">            initCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MediaCallbackListener</span> <span class="keyword">implements</span> <span class="title">MediaRecorder</span>.<span class="title">OnInfoListener</span>, <span class="title">MediaRecorder</span>.<span class="title">OnErrorListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(MediaRecorder mr, <span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInfo</span><span class="params">(MediaRecorder mr, <span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"info"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (mCamera == null) return;</span></span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.btn_take_pic) <span class="comment">//拍照</span></span><br><span class="line">            takePicture();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_start_video)</span><br><span class="line">            startVideoRecord();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_stop_video)</span><br><span class="line">            stopVideoRecord();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************  拍照部分   *******************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCamera.takePicture(<span class="keyword">null</span>, <span class="keyword">null</span>, mPictureCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String fileName = Environment.getExternalStorageDirectory() + <span class="string">"/t3.jpg"</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera.PictureCallback mPictureCallback = <span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            SavePicAsyncTask saveBitmapTask = <span class="keyword">new</span> SavePicAsyncTask();</span><br><span class="line">            saveBitmapTask.execute(data);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera.ShutterCallback mShutterCallback = <span class="keyword">new</span> Camera.ShutterCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是设置了rotation时调用保存图片的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePic</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            os.write(data);</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用bitmap保存时，因为compress是耗时方法，放在onPictureTaken中会体验极差，所以放个后台任务来压缩保存图片</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">SavePicAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = (<span class="keyword">byte</span>[]) objects[<span class="number">0</span>];</span><br><span class="line">            Bitmap bm0 = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于camera.</span></span><br><span class="line">            Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">            m.setRotate(<span class="number">90</span>, (<span class="keyword">float</span>) bm0.getWidth() / <span class="number">2</span>, (<span class="keyword">float</span>) bm0.getHeight() / <span class="number">2</span>); <span class="comment">//后面两个是旋转轴心坐标</span></span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(bm0, <span class="number">0</span>, <span class="number">0</span>, bm0.getWidth(), bm0.getHeight(), m, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">85</span>, os);</span><br><span class="line">                os.flush();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraUtil</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.graphics.ImageFormat;</span><br><span class="line"><span class="keyword">import</span> android.hardware.Camera;</span><br><span class="line"><span class="keyword">import</span> android.media.Image;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String tag = CameraUtil<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CameraUtil util;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CameraUtil <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (util == <span class="keyword">null</span>) &#123;</span><br><span class="line">            util = <span class="keyword">new</span> CameraUtil();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> util;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> CameraNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mIsPortrait = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CameraUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CameraNum = Camera.getNumberOfCameras();</span><br><span class="line">        Log.d(tag, <span class="string">"cam_num="</span> + CameraNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Camera <span class="title">openCamera</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CameraNum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Camera camera = Camera.open(id); <span class="comment">//打开第一个摄像头</span></span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCameraParamter</span><span class="params">(Context context, Camera camera, Bundle paramBundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (camera == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO); <span class="comment">//闪光灯模式</span></span><br><span class="line">        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = paramBundle.getInt(<span class="string">"width"</span>);</span><br><span class="line">        <span class="keyword">int</span> height = paramBundle.getInt(<span class="string">"height"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"width = "</span> + width + <span class="string">" height ="</span> + height);</span><br><span class="line">        List&lt;Camera.Size&gt; sizeList = parameters.getSupportedPreviewSizes();</span><br><span class="line">        Camera.Size lastSize = getOptimalPreviewSize(context, sizeList, width, height);</span><br><span class="line">        parameters.setPreviewSize(lastSize.width, lastSize.height);</span><br><span class="line">        Log.d(tag, <span class="string">"surwidth = "</span> + width + <span class="string">" surheight ="</span> + height</span><br><span class="line">                + <span class="string">" size width="</span> + lastSize.width + <span class="string">" size height="</span> + lastSize.height);</span><br><span class="line">        parameters.setPreviewFormat(ImageFormat.NV21); <span class="comment">//默认预览帧格式</span></span><br><span class="line">        <span class="comment">//拍照分辨率和预览分辨率</span></span><br><span class="line"><span class="comment">//        parameters.setPictureSize();</span></span><br><span class="line"><span class="comment">//        parameters.setPreviewSize(); //预览分辨率只能从上面的sizeList里面选取</span></span><br><span class="line"></span><br><span class="line">        followScreenOrientation(context, camera);</span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">        <span class="comment">//有的手机这么设置会出错，则使用camera.getParameters().setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);的形式设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">followScreenOrientation</span><span class="params">(Context context, Camera camera)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> orientation = context.getResources().getConfiguration().orientation;</span><br><span class="line">        <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">            camera.setDisplayOrientation(<span class="number">180</span>);</span><br><span class="line">            mIsPortrait = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">            camera.setDisplayOrientation(<span class="number">90</span>);</span><br><span class="line">            mIsPortrait = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然这样画面还是有一点点扁，还是不知道系统相机是如何做到画面不扁而且还像素高的</span></span><br><span class="line">    <span class="keyword">private</span> Camera.<span class="function">Size <span class="title">getOptimalPreviewSize</span><span class="params">(Context context, List&lt;Camera.Size&gt; sizes, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> ASPECT_TOLERANCE = <span class="number">0.2</span>;  <span class="comment">//camera宽高比与surface宽高比的最大误差阈值,越小越精确，但可能没有合适的分辨率，一般为0.1或0.2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> orientation = context.getResources().getConfiguration().orientation;</span><br><span class="line">        <span class="keyword">int</span> targetHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> targetRatio = <span class="number">0</span>d;</span><br><span class="line">        <span class="comment">//由于横竖屏不一样，系统相机的尺寸默认是横屏状态下的，</span></span><br><span class="line">        <span class="comment">// 所以竖屏状态下，比例就是高宽比（因此此时高大于宽），而与系统中高度比较时则应该用宽(哪个小用哪个)</span></span><br><span class="line">        <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">            targetRatio = (<span class="keyword">double</span>) w / h;</span><br><span class="line">            targetHeight = h;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">            targetRatio = (<span class="keyword">double</span>) h / w;</span><br><span class="line">            targetHeight = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得surfaceView的宽高比</span></span><br><span class="line">        <span class="keyword">if</span> (sizes == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Camera.Size optimalSize = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">double</span> minDiff = Double.MAX_VALUE; <span class="comment">//在比例合适的情况下，两种高度最低能达到的差值（肯定是越小越符合），一开始设为最大浮点数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"targetHeight="</span> + targetHeight);</span><br><span class="line">        <span class="comment">// Try to find an size match aspect ratio and size</span></span><br><span class="line">        <span class="keyword">for</span> (Camera.Size size : sizes) &#123;  <span class="comment">//遍历当前摄像头支持的分辨率，并计算宽高比</span></span><br><span class="line">            <span class="keyword">double</span> ratio = (<span class="keyword">double</span>) size.width / size.height;</span><br><span class="line">            Log.d(tag, <span class="string">"width="</span> + size.width + <span class="string">" height="</span> + size.height);</span><br><span class="line">            Log.d(tag, <span class="string">"target Ratio="</span> + targetRatio + <span class="string">" ratio="</span> + ratio);</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(ratio - targetRatio) &gt; ASPECT_TOLERANCE) <span class="keyword">continue</span>; <span class="comment">//如果两个宽高比之差大于阈值，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(size.height - targetHeight) &lt; minDiff) &#123; <span class="comment">//找到了更小的差值，则替换最合适的比例</span></span><br><span class="line">                optimalSize = size;</span><br><span class="line">                minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         Cannot find the one match the aspect ratio, ignore the requirement</span></span><br><span class="line">        <span class="keyword">if</span> (optimalSize == <span class="keyword">null</span>) &#123;          <span class="comment">//当使用阈值找不到时，则忽略比例阈值，直接用最小的高度差的那组分辨率</span></span><br><span class="line">            minDiff = Double.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (Camera.Size size : sizes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(size.height - targetHeight) &lt; minDiff) &#123;</span><br><span class="line">                    optimalSize = size;</span><br><span class="line">                    minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> optimalSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局文件，只让surfaceview和textureview其中之一显示</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--surfaceView 和 TextureView选一个隐藏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SurfaceView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_t3"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"visible"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextureView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/texture_view_1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_take_pic"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_take_pic"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_start_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_start_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_stop_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_stop_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/Android/onMeasure()%E5%92%8ConLayout()%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/Android/onMeasure()%E5%92%8ConLayout()%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">onMeasure()和onLayout()总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 15:44:11 / 修改时间：15:56:56" itemprop="dateCreated datePublished" datetime="2020-04-10T15:44:11+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载自 <a href="https://www.cnblogs.com/xqxacm/p/6673469.html" target="_blank" rel="noopener">https://www.cnblogs.com/xqxacm/p/6673469.html</a><br>和 <a href="https://blog.csdn.net/superxukai88/article/details/78675686" target="_blank" rel="noopener">https://blog.csdn.net/superxukai88/article/details/78675686</a></p>
<p>并写了一些自己的总结<br>前言：<br>　　自定义控件的三大方法：</p>
<ol>
<li>测量： onMeasure()：  测量自己的大小，为正式布局提供建议 </li>
<li>布局： onLayout():   使用layout()函数对所有子控件布局</li>
<li>绘制： onDraw():     根据布局的位置绘图 </li>
</ol>
<p>onDraw() 里面是绘制的操作，可以看下其他的文章，下面来了解 onMeasure()和onLayout()方法。</p>
<h1 id="一、onMeasure-、测量"><a href="#一、onMeasure-、测量" class="headerlink" title="一、onMeasure()、测量"></a>一、onMeasure()、测量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<p>参数即父类传过来的两个宽高的”建议值”，即把当前view的高设置为：heightMeasureSpec ;宽设置为：widthMeasureSpec<br>这个参数不是简单的整数类型，而是2位整数(模式类型)和30位整数(实际数值) 的组合</p>
<p>其中模式分为三种:</p>
<p>①、UNSPECIFIED(未指定)，父元素不对自元素施加任何束缚，子元素可以得到任意想要的大小；UNSPECIFIED=00000000000000000000000000000000</p>
<p>②、EXACTLY(完全)，父元素决定自元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；EXACTLY =01000000000000000000000000000000<br>③、AT_MOST(至多)，子元素至多达到指定大小的值。 他们对应的二进制值分别是： AT_MOST =10000000000000000000000000000000 </p>
<p>最前面两位代表模式，分别对应十进制的0，1，2；</p>
<p>获取模式int值 和 获取数值int值的方法：</p>
<blockquote>
<ol>
<li>int measureWidth = MeasureSpec.getSize(widthMeasureSpec);  </li>
<li>int measureHeight = MeasureSpec.getSize(heightMeasureSpec);  </li>
<li>int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);  </li>
<li>int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);<br>模式的值有：<br>MeasureSpec.AT_MOST       = 2<br>MeasureSpec.EXACTLY       = 1<br>MeasureSpec.UNSPECIFIED   = 0</li>
</ol>
</blockquote>
<p>上面我们知道了 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法参数的意义<br>下面了解参数对应的三个模式分别对应的意义：<br>每一个模式都对应的xml布局中的一个值<br>wrap_content — MeasureSpec.AT_MOST<br>match_parent — MeasureSpec.EXACTLY<br>具体值 — MeasureSpec.UNSPECIFIED</p>
<p>注意：<br>—当模式是MeasureSpec.AT_MOST时，即wrap_content时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上就是父亲建议的尺寸数值,（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议.</p>
<p>PS: 但需要注意的是，如果直接自定义一个View，宽高为wrap_content, 则最后绘制的时候view是占满整个父View的(假设父view只有这一个儿子)，这是因为上面说的，传过来的是父亲的尺寸，但如果自定义View继承了像TextView之类的，最后还调用了super.onMeasure，则显示的时候大小是根据其内容显示的，这是因为这些TextView在自己的onMeasure里又做了处理，使得其根据内容的大小而变化。</p>
<p>—当模式是MeasureSpec.EXACTLY时，即match_parent时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上也是父亲建议的尺寸数值（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议</p>
<p>PS:（AT_MOST与EXACTLY：如果在onMeasure中不做任何处理而调用setMeasureDimension(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.getSize(heightMeasureSpec))）来设置尺寸，，或者在基类的onMeasure中不做任何额外处理而调用super.onMeasure().那么这两个模式没有任何区别（都是用父亲建议的大小设置自己的大小，而且两个模式父亲建议的大小都一样）。因此若使用AT_MOST一般都要在onMeasure中根据mode不同而设置view尺寸为不同的大小（如同TextView做的那样）</p>
<p>—当模式是MeasureSpec.UNSPECIFIED时，即具体数值时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际是具体指定的数字，因此在onMeasure里不做其他操作，子view会符合父亲的建议，即变成它自己设定的尺寸，尽管这里的数字大小是不做限制的，但当绘制的时候，父亲会clip掉自己尺寸之外的子view的部分。要避免的话，需设置子view的顶级祖先ViewGroup的clipChildren属性为false，而且它的父亲必须不是RelativeLayout（即不clip有两个条件，1.顶级祖先view设置clipChildren=false。2.父view必须不是RelativeLayout，PS：父view设置不设置clipChildren无所谓，顶级祖先必须设置）</p>
<h1 id="二、onLayout-、-布局"><a href="#二、onLayout-、-布局" class="headerlink" title="二、onLayout() 、 布局"></a>二、onLayout() 、 布局</h1><p>onLayout方法是ViewGroup中子View的布局方法，用于放置子View的位置。放置子View很简单，只需在重写onLayout方法，然后获取子View的实例，调用子View的layout方法实现布局。在实际开发中，一般要配合onMeasure测量方法一起使用。</p>
<h2 id="onLayout方法："><a href="#onLayout方法：" class="headerlink" title="onLayout方法："></a>onLayout方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span>  <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法在ViewGroup中定义是抽象函数，继承该类必须实现onLayout方法，而ViewGroup的onMeasure并非必须重写的。View的放置都是根据一个矩形空间放置的，onLayout传下来的l,t,r,b分别是放置父控件的矩形可用空间（除去margin和padding的空间）的左上角的left、top以及右下角right、bottom值。</p>
<h2 id="layout方法："><a href="#layout方法：" class="headerlink" title="layout方法："></a>layout方法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法是View的放置方法，在View类实现。调用该方法需要传入放置View的矩形空间左上角left、top值和右下角right、bottom值。这四个值是相对于父控件而言的。例如传入的是（10, 10, 100, 100），则该View在距离父控件的左上角位置(10, 10)处显示，显示的大小是宽高是90(参数r,b是相对左上角的)，这有点像绝对布局。</p>
<p>平常开发所用到RelativeLayout、LinearLayout、FrameLayout…这些都是继承ViewGroup的布局。这些布局的实现都是通过都实现ViewGroup的onLayout方法，只是实现方法不一样而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/Concurrent%20mode%20failure%E5%92%8C%20promotion%20failed/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/Concurrent%20mode%20failure%E5%92%8C%20promotion%20failed/" class="post-title-link" itemprop="url">Concurrent mode failure和 promotion failed</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:54:47" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>：（两种错误刚好就是三种进入老年代的方法引起的）</p>
<h2 id="一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"><a href="#一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）" class="headerlink" title="一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"></a>一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）</h2><p>原因有两种：<br>    1.年轻代提升太快，老年代的处理速度跟不上新生代的提升速度；或者新生代空间太小，放不下新产生的对象而直接转入老年代，但老年代也空间不够<br>        解决办法：<br>        ①.调大新生代空间 -Xmn<br>        ②.加大新生代晋升的阈值 -XX:MaxTenuringThreshold<br>    2.老年代碎片过多<br>        解决办法：<br>        ①.调大老年代的比例  –XX:NewRatio<br>        ②.降低老年代进行垃圾回收的阈值，<br>        -XX:CMSInitiatingOccupancyFraction=60（默认是 68）<br>        -XX:+UseCMSInitiatingOccupancyOnly<br>当老年代碎片过多时，这个过程注意cms的性能会比较差，退化成只有一个线程来收集垃圾，耗时可能有几秒或十几秒。</p>
<h2 id="二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"><a href="#二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）" class="headerlink" title="二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"></a>二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）</h2><p>一个Survivor 区不能容纳eden和另外一个survivor里面的存活对象，多余的对象进入老年代，这样就会导致老年代里面的存放大量的短暂存活的对象，<br>而我们知道，如果老年代里面没有可用空间就会发生full gc，这样就造成扫描整个堆，造成提升失败（promotion failed）。</p>
<pre><code>解决办法：增加survivor
    ①.增加年轻代的大小 -Xmn
    ②.调整survivor和eden的比例  -XX:SurvivorRatio 默认是8 ， 各占比 s0：s1 ：eden =1：1：8 ， 减小这个值也就加大了survivor。</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/IoC%E5%92%8CAOP%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/IoC%E5%92%8CAOP%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">IoC和AOP的简单总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:03:14" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h2 id="IoC："><a href="#IoC：" class="headerlink" title="IoC："></a>IoC：</h2><hr>
<p>context是总管家。总领全局<br>    context创建一个bean工厂，一个解析工具（如xmlReader）。先让解析工具去完成对xml或者注解中bean的解析，对于每个bean节点，提取出其中的名称，类型、属性来构建出一个beandefinition(bd)，并存放到解析工具的map中，之后创建这个map中的bd全部移到bean工厂的map中，然后扫描出所有类型为bean初始化前置/后置处理器的bean，此时就要把它们创建好，并把它们都加到bean工厂的前置/后置处理列表中。<br>此时bean工厂中有了所有的bean的bd（但bean本身还没创建，除了前置/后置处理器bean）<br>（tiny中是全部bean都在这里创建，而在spring中，bean创建可以等到用户第一次getbean时，再触发下面的动作）<br>之后进行bean的创建，进行context的onrefresh，在bean工厂中遍历map，创建bean的实例，并且对每个bean实例做如下工作：<br>    创建后把bean实例和它的bd绑定起来（把它赋给bd的一个属性），并且从bd中取出之前设定的一些属性，给bean赋上。然后对从bean工厂中取出之前加入到前置处理器列表中的bean，使用这些处理器bean对当前的这个bean做前置处理；然后进行这个bean的初始化方法（指定的init-method），然后取出之前加入到后置处理器列表中的bean，使用这些处理器bean对当前的这个bean做后置处理（比如aop就是在这一步发挥作用，检测这个bean的类型是不是符合要拦截处理的类型，如果是，则创建用一个该类代理类型的bean代替当前的这个bean返回）； 做完前置/后置处理后都会返回bean(这个bean可能已经被修改了)，再次把这个最终经过前后置处理的bean重新与bd绑定（之前绑定的就作废了）。（真正的spring中还有给每个bean设置关于容器感知，名称感知，context感知之类的功能）<br>（如果对于特定类型的bean要执行特定的前置/后置处理，只需在处理器中判断bean的类型，满足再处理，否则就把传入的bean原样返回即可）<br>此时，bean的初始化就完成了，获取bean的话，就通过context得到bean工厂，再从bean工厂中通过要获取的bean的类型或名称得到bd，再从bd得到与之绑定的bean。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>有一个后置处理器叫AspectJAwareAdvisorAutoProxyCreator（简称apc），它的作用是在bean的后置处理时如果需要创建代理，则创建代理来代替原始bean返回<br>有一个类叫TargetSource，它可以封装一个其他类的实例对象，类型，以及它实现和继承的类型/接口集合，相当于是某个实例对象的信息组合。<br>一个类叫AdvisedSupport（具体实现是proxyFactory），它是一个aop的核心类型，它有targetsource的成员变量，有方法拦截器的成员变量，有方法匹配器的成员变量。<br>advisors实际上是包含所有需要代理的类的名单，需要拦截的方法的名单，以及所有的方法拦截器。<br>advisors由多个advisor组成，每个advisor包含一个pointcut成员，一个advice成员。<br>    pointcut定义了一组规则，包括符合条件的类型名规则，符合拦截的方法名规则。（术语是切点）<br>    advice就是一个方法拦截器.(其实就是执行额外的逻辑代码的工具) （术语是通知）<br>（这里advisor的术语就是aspect，即切面，实际上就是切点和通知的综合体）<br>每个advisor也是一个bean，它在spring中实际上就是注解了@AspectJ的类的实例，其pointcut和advice可能都是自己。（而且为了保证advisor必须在其他实例创建之前就创建好，每次有一个bean进入创建代理的后置处理器时，会从容器获得所有的advisor(利用getBeansForType)，如果有某个advisor还没创建，则优先创建它。因此会保证如果一个bean需要被代理，则其advisor一定在它用之前就创建好）</p>
<p>当有一个bean要进行apc的后置处理的时候，遍历所有的advisor，如果不符合所有的advisor类型规则，则直接返回bean；如果发现符合其中一个advisor的类型规则，进入下一步：（真正的spring中使用拦截链，也就是说可以有多个advisor匹配当前的bean，调用方法的时候会一个挨一个调用）<br>创建一个advisedSupport<br>  ·根据这个bean去创建一个它的targetSource，并且把这个targetSource设置给advisedSupport的成员<br>  ·把当前的advisor的方法规则（方法匹配器）设置给advisedSupport<br>  ·把当前advisor的方法拦截规则（方法拦截器）设置给advisedSupport</p>
<p>使用advisedSupport生成一个代理工厂，该代理工厂拥有advisedSupport的成员变量，并且这个代理工厂是一个调用处理器(InvocationHandler)。<br>    使用代理工厂去生成一个当前这个bean的代理对象。如果用jdk动态代理的话，使用<br>Proxy.newProxyInstance(当前类的类型加载器, bean的所有实现和继承的类型/接口集合, 调用处理器(也就是生成它的代理工厂)）来得到一个代理对象，这个代理对象拥有所有bean的同名方法，当调用代理对象的一个方法时，会调用它的调研处理器的invoke方法，并且会把bean的原本该名称的方法、bean对象，参数都传入invoke<br>，在调用处理器（即代理工厂）的invoke方法中，使用它的成员advisedSupport的方法匹配规则来判断当前调用的这个方法是不是需要拦截的，如果不是则直接调用bean的原来的方法；如果是需要拦截的，则使用advisedSupport的方法拦截器，去执行具体的拦截器的额外逻辑代码（这里还涉及到一个MethodInvocation，但它实际上就是对一个方法、对象、参数的包装，只是为了方便打包传递，从调用处理器传递到拦截器，没有额外的用途），当然这个额外的逻辑代码中也可以调用bean原来的方法，也可以去做一些额外的操作。<br>生成代理后返回，则此时代理对象就取代了原本的bean成为了bean容器中针对原来的bean类型的合法代言人了，别的地方不论是通过原本的类型，还是设置的名称，获得的都是这个代理，而原来的bean就只存在于代理对象的调用处理器中的advisedSupport中的targetSource中（层层包裹，外部是无法得到这个bean的）。</p>
<p>另：<br>生成代理对象的方式有jdk动态代理，还有其他一些，如Cglib2等，但原理都是一样的。</p>
<blockquote>
<p>注意，jdk动态代理生成的对象只能转成实际类实现的接口类型的对象，而无法转成实在的类的对象（而cglib能）<br>例如，A implements I<br>jdk动态代理创建好的代理proxy只能强转成I类型的，而不能强转成A类型的。</p>
</blockquote>
<blockquote>
<p>注意，InvocationHandler的invoke方法，传递过来的是proxy，而不是原始对象，所以如果要运行原本实例的方法(method.invoke)，需要在InvocationHandler中保存原本的实例</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">并发机制底层实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:02:33" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.volatile<br>    volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<p>volatile两条实现原则：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。<br> 在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。（补足64个字节，使得缓存中的头尾节点不会被读到一个缓存行中，也就不能相互锁定）<br>不应该追加字节的场景：</li>
</ol>
<ul>
<li>缓存行非64字节宽的处理器。</li>
<li>共享变量不会被频繁地写。</li>
</ul>
<p>1.synchronized<br>    用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ul>
<li>·对于普通同步方法，锁是当前实例对象。</li>
<li>·对于静态同步方法，锁是当前类的Class对象。</li>
<li>·对于同步方法块，锁是Synchonized括号里配置的对象。<br>  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br>（synchronized本质上是去获取对象对应的monitor的所有权）<br>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，<br>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。<br>》偏向锁<br>  大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</li>
</ul>
<blockquote>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>    简单说就算获得它的线程退出后先不释放锁，下一次如果还是这个线程进入的话就不用再获取锁了， 只是去比较一下是否是偏向锁且锁的markword中的线程ID是否是当前ID，<br>    如果是的话，都不用CAS，就直接进入同步块了。 如果有别的线程来竞争的话，就撤销偏向锁标志了。</p>
</blockquote>
<p>》轻量级锁</p>
<blockquote>
<p>如果当前不是偏向锁，且线程通过CAS修改锁的markword成功了，则就将其标志为轻量级锁<br>如果CAS没成功，则一直自旋CAS，如果失败到一定程度，则认为膨胀为重量级锁，修改其锁标志，这个自旋的线程再进入阻塞状态。<br>任何去竞争对象锁的线程都有权利按照规则修改其对象头的锁标志（不管是否获取到锁），但对象头的markword中的指向的锁记录的栈帧所属的线程才是该线程获得锁的标志<br>如果有线程去尝试获得锁，发现是重量级锁，就不会自旋CAS了，而是直接进入阻塞</p>
</blockquote>
<p>在Java中可以通过锁和循环CAS的方式来实现原子操作。<br>(只有AtomicXXX才能使用CAS)</p>
<p>CAS实现原子操作的三大问题</p>
<ul>
<li>ABA问题，java中使用AtomicStampedReference解决，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作。这个时候就可以用锁</li>
</ul>
<p>》使用锁机制实现原子操作<br>    锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E4%B8%ADparallel%20scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDCMS%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E4%B8%ADparallel%20scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDCMS%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F/" class="post-title-link" itemprop="url">垃圾收集器GC中parallel scavenge收集器为什么不能CMS配合使用？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：17:11:40" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先看一下收集器的分布：</p>
<p><img src="http://img.blog.csdn.net/20170102225015393" alt="垃圾收集器"></p>
<p>1.解答parallel scavenge收集器为什么不能CMS配合使用？<br>首先讲一下Hotspot，HotSpot VM里多个GC有部分共享的代码。有一个分代式GC框架，Serial/Serial Old/ParNew/CMS都在这个框架内；在该框架内的young collector和old collector可以任意搭配使用，所谓的“mix-and-match”。<br>而ParallelScavenge与G1则不在这个框架内，而是各自采用了自己特别的框架。这是因为新的GC实现时发现原本的分代式GC框架用起来不顺手。</p>
<p>ParallelScavenge（PS）的young collector就如其名字所示，是并行的拷贝式收集器。本来这个young collector就是“Parallel Scavenge”所指，但因为它不兼容原本的分代式GC框架，为了凸显出它是不同的，所以它的young collector带上了PS前缀，全名变成PS Scavenge。对应的，它的old collector的名字也带上了PS前缀，叫做PS MarkSweep。</p>
<p>这个PS MarkSweep默认的实现实际上是一层皮，它底下真正做mark-sweep-compact工作的代码是跟分代式GC框架里的serial old（这个collector名字叫做MarkSweepCompact）是共用同一份代码的。也就是说实际上PS MarkSweep与MarkSweepCompact在HotSpot VM里是同一个collector实现，包了两张不同的皮；这个collector是串行的。</p>
<p>最后：<br>重点就是Parallel Scavenge没有使用原本HotSpot其它GC通用的那个GC框架，所以不能跟使用了那个框架的CMS搭配使用。</p>
<p>新生代：使用复制算法进行GC。<br>老年代：使用标记-整理算法。</p>
<p>并发：（concurrent）用户线程与垃圾收集器同时执行（但不一定并行的，可能会交替执行）<br>并行：（parallel）多条垃圾手机线程并行，用户线程仍然等待。</p>
<p>1.新生代收集器<br>serial收集器：是新生代的一个单线程的GC，，进行GC时，停掉所有用户线程，直至回收结束，“stop-the-world”。但是其单线程的简单高效，没有线程交互的开销，常被JVM运行在client模式下的默认新生代收集器。</p>
<p>ParNew：并行收集器，是serial收集器的多线程的版本。是运行在server模式下的首先的新生代的收集器。</p>
<p>parallel scavenge ：新生代收集器，多线程，并行收集。<br>此收集器与之前的收集器目的不同：（特点）达到一个可控制的吞吐量。吞吐量=运行用户代码时间/CPU总执行时间。<br>用于精确吞吐量的两个参数：1.控制最大垃圾收集停顿时间参数 2.直接设置吞吐量大小的参数。Parallel scavenge收集器与ParNew收集器重要区别是： 垃圾自适应调节策略。</p>
<p>2.老年代收集器<br>serial old：老年代收集器版本，单线程。<br>用途：1.在JDK1.5版本之前与parallel scavenge 收集器搭配使用。<br>2.作为CMS收集器的后备预案。</p>
<p>Parallel Old ：使用多线程收集。吞吐量优先。</p>
<p>CMS：</p>
<ol>
<li>目标是：尽量缩短垃圾回收时间和用户线程的停顿时间</li>
<li>严格意义上第一款并发垃圾回收器</li>
<li>主要场景在 互联网 B/S 架构上</li>
<li>使用标记清除算法</li>
<li>步骤<br> 5.1 初始标记：STW、快；GC Root 能直接关联的对象<br> 5.2 并发标记：并发；GC Root Tracing 的过程<br> 5.3 重新标记：STW、快；修复并发标记阶段 用户线程运行时变动的对象<br> 5.4 并发清除：并发</li>
<li>因为整个过程中耗时最长的 “并发标记”和“并发清除”是和用户线程并发执行的，所以可认为CMS回收器是和用户线程并发执行的</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/linux/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3linux%E6%8C%82%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/linux/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3linux%E6%8C%82%E8%BD%BD/" class="post-title-link" itemprop="url">如何理解linux挂载</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：16:00:26" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>根据树结构去理解整个文件系统的挂载和挂载点还是有点困难，所以自己做了些总结，有不对的地方还请指正</p>
<p>df -h命令后</p>
<p>Filesystem 这里的文件系统表示的是目录的层次结构，而不是所谓的像ext4，fat那种真正的文件系统类型<br>一个具体的设备文件(或分区) ，或许是一块硬盘上的一个分区，或许是u盘上的一个分区</p>
<p>目录就相当于门<br>整个linux中的文件系统就像一个世界接着一个世界，不同的世界代表不同的被挂载的文件系统，挂载点就相当于任意门（特殊的门），各个被挂载的文件系统之间是独立的，但是要进入其中一个需要一个一个进入任意门去穿梭，整个世界的第一个门是 / ，它里面的世界是第一个文件系统，这个世界里又有很多个门，有的门背后的世界和这个世界是同一个，则他们是在同一个文件系统里，而当有其他的分区被挂载到一个目录的时候，例如<br>对一个目录 /home/lll，要到达这个门后的世界，要穿过 / 和 home/ （这个门在 / 后面的世界里） 和 lll/ （这个门在 home/ 后面的世界里），形象的描述为：</p>
<p>/ —》 世界A （包含 home/ —-》 世界B （包含 lll/ —》 世界C ）如果不做任何其他挂载，世界A、B、C是同一个世界）当要把/dev/sda1这个id所指向的分区挂载到 /home/lll 则相当于把 /home/lll/ 这个门变成任意门，它通往的世界变成了sda1的世界空间，自然的，只要进了这个世界，如果再不挂载其他的，则所有对 /home/lll/… 的操作都在sda1的世界里，而对这个门前面的世界的操作，如对/home/aaa的操作，仍然在一开始的那个世界里<br>把挂载点想象成一个任意门，进入第一个任意门是世界A，里面还有一个任意门通往世界B，虽然只有进了第一个任意门才能进第二个任意门，但世界A和世界B是毫无关系彼此独立的（挂载的文件系统之间彼此独立）<br>挂载绑定：把一个目录挂载到另一个目录，比如 mount –bind dir1 dir2 则是相当于对dir2这个门做了特殊处理，让dir2和dir1通往同一个世界的同一个位置，而dir2原本通往的那个位置里面的东西会被遮盖掉，当解除挂载后，dir2会恢复它原本通往的世界和位置，且里面的东西还在</p>
<p>当把目录A挂载到目录B，= mount –bind A B ; 其中B是新的挂载点 ，就是让门B通往的地方和门A通往的地方一毛一样<br>把设备A挂载到目录B = mount A B ; 其中B是新的挂载点，就是让门B通往的地方是A的世界空间。<br>挂载点必须是目录（门）</p>
<p>可以对同一个目录多次挂载，最后生效的结果是最后一次挂载，此时卸载，则倒数第二次挂载生效，再卸载，则倒数第三次挂载生效</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lujianyun06.github.io/2020/04/10/linux/Ubuntu16%E4%B8%8B%20pip%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8D%B8%E8%BD%BD%E3%80%81%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%8A%A5%E9%94%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/lu.jpg">
      <meta itemprop="name" content="RockMaster~Lu">
      <meta itemprop="description" content="记录学习生活，力求每日进步">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RockMaster's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/10/linux/Ubuntu16%E4%B8%8B%20pip%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8D%B8%E8%BD%BD%E3%80%81%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%8A%A5%E9%94%99/" class="post-title-link" itemprop="url">Ubuntu16下 pip安装，卸载、升级，报错</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-04-10 09:17:08 / 修改时间：16:48:11" itemprop="dateCreated datePublished" datetime="2020-04-10T09:17:08+08:00">2020-04-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>新装的ubuntu16，自带的python2.7，使用pip升级后，报错，修改记录如下：</p>
<h2 id="如何彻底卸载pip？"><a href="#如何彻底卸载pip？" class="headerlink" title="如何彻底卸载pip？"></a>如何彻底卸载pip？</h2><p>sudo python -m pip uninstall pip</p>
<h2 id="如何安装pip"><a href="#如何安装pip" class="headerlink" title="如何安装pip"></a>如何安装pip</h2><p>sudo apt install python-pip</p>
<h2 id="如何安装指定版本的pip"><a href="#如何安装指定版本的pip" class="headerlink" title="如何安装指定版本的pip"></a>如何安装指定版本的pip</h2><p>python -m pip install pip==18.1(换成你想要的版本编号)</p>
<h2 id="pip安装软件过程中报错："><a href="#pip安装软件过程中报错：" class="headerlink" title="pip安装软件过程中报错："></a>pip安装软件过程中报错：</h2><p>Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-BqMhb7/matplotlib/</p>
<ol>
<li>安装并升级setuptools<br>pip install –upgrade setuptools</li>
<li>升级pip<br>pip install –upgrade pip</li>
</ol>
<h2 id="pip升级后报错"><a href="#pip升级后报错" class="headerlink" title="pip升级后报错"></a>pip升级后报错</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/usr/bin/pip", line 9, in &lt;module&gt;</span><br><span class="line">    from pip import main</span><br><span class="line">ImportError: cannot import name 'main'</span><br><span class="line">修改/usr/bin/pip如下：</span><br><span class="line">//修改前</span><br><span class="line">from pip import main  </span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(main()) </span><br><span class="line">修改后</span><br><span class="line">from pip import __main__  //这行也要修改</span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(__main__._main())//增加__main__._  （注意最后main()前面有个_）</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockMaster~Lu"
      src="/images/lu.jpg">
  <p class="site-author-name" itemprop="name">RockMaster~Lu</p>
  <div class="site-description" itemprop="description">记录学习生活，力求每日进步</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yourname@gmail.com" title="E-Mail → mailto:yourname@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fas fa-cloud"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockMaster~Lu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

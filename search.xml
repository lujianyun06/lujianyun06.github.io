<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Android 音视频任务2</title>
    <url>/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A12/</url>
    <content><![CDATA[<p>任务：2. 在 Android 平台使用 AudioRecord 和 AudioTrack API 完成音频 PCM 数据的采集和播放，并实现读写音频 wav 文件</p>
<p>记得加权限：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECORD_AUDIO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>AudioRecord使用流程：<br>确定好采样率，通道类型，编码方式，录制来源<br>由AudioRecord.getMinbufferSize获得能接受的最小buffer大小<br>new一个AudioRecord对象 audioRecord ，第一个参数表示的是音频录制来源。注意的是record和track都有通道(channel)参数，但一个是in一个是out，不要搞反了<br>开始录制：audioRecord.startRecord() 同时要开启一个线程，该线程所做的工作是打开一个output流创建一个文件。不断用audioRecord.read把录制的数据写到一个比特数组，然后把比特数组写到output流中<br>暂停录制：audioRecord.stop，但不release，而且output流也停止写入，但不释放<br>恢复录制，audioRecord.startRecord() ，继续读取audioRecord的数据并写入output流，<br>停止录制：audioRecord.stop，audioRecord.release释放资源，output流flush一下然后关闭<br>这样录制的音频是pcm格式的，也就是没有文件头的原始文件，要转成wav文件，只需要保持数据部分不变，然后再文件开始加入wav的文件头<br>AudioTrack使用流程：<br>确定好采样率，通道类型，编码方式<br>由AudioTrack.getMinbufferSize获得能接受的最小buffer大小<br>new一个AudioTrack对象 audioTrack ，第一个参数表示的是音频播放的类型，可选的有演讲、音乐、影视等(可能是针对每种不同的场景类型做一些优化) 。最后一个参数mode是表示创建的模式<br>MODE_STATIC 其中音频数据从Java传输到本地层仅一次，然后音频开始播放。<br>MODE_STREAM 当音频播放时，音频数据从Java流到本地层。(两个先后顺序不同)<br>开始播放：audioTrack.play() 同时要开启一个线程，该线程所做的工作是打开一个input流读取音频文件(audioTrack既可以读原始的pcm文件，也可以读加入文件头的wav文件), 不断把文件到一个比特数组，然后用audioTrack.write把比特数组写入.<br>暂停播放：audioTrack.stop，但不release，而且input流也停止读入，但不释放（文件指针还停留在此）<br>恢复播放，audioTrack.play，让input流在停止的地方继续入读，<br>停止播放：audioTrack.stop，audioTrack.release释放资源，关闭input流（这样input流保留的文件指针也就丢失了，下一次就会从头读）<br>AudioRecord的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioFormat;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioRecord;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaRecorder;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lll.va.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioRecorder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String tag = <span class="string">"AudioRecorder"</span>;</span><br><span class="line">    <span class="comment">//音频输入-麦克风</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_INPUT = MediaRecorder.AudioSource.MIC;</span><br><span class="line">    <span class="comment">//采用频率</span></span><br><span class="line">    <span class="comment">//44100是目前的标准，但是某些设备仍然支持22050，16000，11025</span></span><br><span class="line">    <span class="comment">//采样频率一般共分为22.05KHz、44.1KHz、48KHz三个等级</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_SAMPLE_RATE = <span class="number">16000</span>;</span><br><span class="line">    <span class="comment">//声道 单声道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_CHANNEL = AudioFormat.CHANNEL_IN_MONO;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> data[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRecording = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AudioRecord audioRecord = <span class="keyword">null</span>;  <span class="comment">// 声明 AudioRecord 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> recordBufSize = <span class="number">0</span>; <span class="comment">// 声明recoordBufffer的大小字段</span></span><br><span class="line">    <span class="keyword">private</span> Button btnStart;</span><br><span class="line">    <span class="keyword">private</span> Button btnStop;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTask2byAudioRecord</span><span class="params">(Activity activity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AudioRecorder audioRecorder = <span class="keyword">new</span> AudioRecorder();</span><br><span class="line">        audioRecorder.createAudioRecord();</span><br><span class="line">        audioRecorder.btnStart = activity.findViewById(R.id.btn_start_record_audio);</span><br><span class="line">        audioRecorder.btnStop = activity.findViewById(R.id.btn_stop_record_audio);</span><br><span class="line">        audioRecorder.btnStart.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                audioRecorder.startRecord();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        audioRecorder.btnStop.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                audioRecorder.stopRecord();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createAudioRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        recordBufSize = AudioRecord.getMinBufferSize(AUDIO_SAMPLE_RATE,</span><br><span class="line">                AUDIO_CHANNEL, AUDIO_ENCODING);  <span class="comment">//audioRecord能接受的最小的buffer大小</span></span><br><span class="line">        audioRecord = <span class="keyword">new</span> AudioRecord(AUDIO_INPUT, AUDIO_SAMPLE_RATE, AUDIO_CHANNEL, AUDIO_ENCODING, recordBufSize);</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">byte</span>[recordBufSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioRecord.startRecording();</span><br><span class="line">        isRecording = <span class="keyword">true</span>;</span><br><span class="line">        thread_w.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String filename = Environment.getExternalStorageDirectory() + <span class="string">"/test"</span>;</span><br><span class="line">    Thread thread_w = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            FileOutputStream os = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os = <span class="keyword">new</span> FileOutputStream(filename);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != os) &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"isRecording = "</span> + isRecording);</span><br><span class="line">                <span class="keyword">while</span> (isRecording) &#123;</span><br><span class="line">                    <span class="keyword">int</span> read = audioRecord.read(data, <span class="number">0</span>, recordBufSize);</span><br><span class="line">                    Log.d(tag, <span class="string">"read size = "</span> + read);</span><br><span class="line">                    <span class="comment">// 如果读取音频数据没有出现错误，就将数据写入到文件</span></span><br><span class="line">                    <span class="keyword">if</span> (AudioRecord.ERROR_INVALID_OPERATION != read) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            os.write(data);</span><br><span class="line">                            Log.d(tag, <span class="string">"os writr = "</span> + data);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.flush();</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRecording = <span class="keyword">false</span>;</span><br><span class="line">        audioRecord.stop();</span><br><span class="line">        audioRecord.release();</span><br><span class="line"><span class="comment">//        thread_w = null;</span></span><br><span class="line">        PcmToWavUtil util = <span class="keyword">new</span> PcmToWavUtil(AUDIO_SAMPLE_RATE, AUDIO_CHANNEL, AUDIO_ENCODING);</span><br><span class="line">        util.pcmToWav(filename, filename + <span class="string">".wav"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给生成的pcm文件加入wav文件头的工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.media.AudioFormat;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PcmToWavUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的音频大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mBufferSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 采样率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSampleRate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声道数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChannel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sampleRate sample rate、采样率</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel channel、声道</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> encoding Audio data format、音频格式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PcmToWavUtil(<span class="keyword">int</span> sampleRate, <span class="keyword">int</span> channel, <span class="keyword">int</span> encoding) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mSampleRate = sampleRate;</span><br><span class="line">        <span class="keyword">this</span>.mChannel = channel;</span><br><span class="line">        <span class="keyword">this</span>.mBufferSize = AudioRecord.getMinBufferSize(mSampleRate, mChannel, encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * pcm文件转wav文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inFilename 源文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outFilename 目标文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pcmToWav</span><span class="params">(String inFilename, String outFilename)</span> </span>&#123;</span><br><span class="line">        FileInputStream in;</span><br><span class="line">        FileOutputStream out;</span><br><span class="line">        <span class="keyword">long</span> totalAudioLen;</span><br><span class="line">        <span class="keyword">long</span> totalDataLen;</span><br><span class="line">        <span class="keyword">long</span> longSampleRate = mSampleRate;</span><br><span class="line">        <span class="keyword">int</span> channels = mChannel == AudioFormat.CHANNEL_IN_MONO ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> byteRate = <span class="number">16</span> * mSampleRate * channels / <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[mBufferSize];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> FileInputStream(inFilename);</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(outFilename);</span><br><span class="line">            totalAudioLen = in.getChannel().size();</span><br><span class="line">            totalDataLen = totalAudioLen + <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line">            writeWaveFileHeader(out, totalAudioLen, totalDataLen,</span><br><span class="line">                    longSampleRate, channels, byteRate);</span><br><span class="line">            <span class="keyword">while</span> (in.read(data) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(data);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入wav文件头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeWaveFileHeader</span><span class="params">(FileOutputStream out, <span class="keyword">long</span> totalAudioLen,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> totalDataLen, <span class="keyword">long</span> longSampleRate, <span class="keyword">int</span> channels, <span class="keyword">long</span> byteRate)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">44</span>];</span><br><span class="line">        <span class="comment">// RIFF/WAVE header</span></span><br><span class="line">        header[<span class="number">0</span>] = <span class="string">'R'</span>;</span><br><span class="line">        header[<span class="number">1</span>] = <span class="string">'I'</span>;</span><br><span class="line">        header[<span class="number">2</span>] = <span class="string">'F'</span>;</span><br><span class="line">        header[<span class="number">3</span>] = <span class="string">'F'</span>;</span><br><span class="line">        header[<span class="number">4</span>] = (<span class="keyword">byte</span>) (totalDataLen &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">5</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">6</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">7</span>] = (<span class="keyword">byte</span>) ((totalDataLen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">//WAVE</span></span><br><span class="line">        header[<span class="number">8</span>] = <span class="string">'W'</span>;</span><br><span class="line">        header[<span class="number">9</span>] = <span class="string">'A'</span>;</span><br><span class="line">        header[<span class="number">10</span>] = <span class="string">'V'</span>;</span><br><span class="line">        header[<span class="number">11</span>] = <span class="string">'E'</span>;</span><br><span class="line">        <span class="comment">// 'fmt ' chunk</span></span><br><span class="line">        header[<span class="number">12</span>] = <span class="string">'f'</span>;</span><br><span class="line">        header[<span class="number">13</span>] = <span class="string">'m'</span>;</span><br><span class="line">        header[<span class="number">14</span>] = <span class="string">'t'</span>;</span><br><span class="line">        header[<span class="number">15</span>] = <span class="string">' '</span>;</span><br><span class="line">        <span class="comment">// 4 bytes: size of 'fmt ' chunk</span></span><br><span class="line">        header[<span class="number">16</span>] = <span class="number">16</span>;</span><br><span class="line">        header[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">18</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">19</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// format = 1</span></span><br><span class="line">        header[<span class="number">20</span>] = <span class="number">1</span>;</span><br><span class="line">        header[<span class="number">21</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">22</span>] = (<span class="keyword">byte</span>) channels;</span><br><span class="line">        header[<span class="number">23</span>] = <span class="number">0</span>;</span><br><span class="line">        header[<span class="number">24</span>] = (<span class="keyword">byte</span>) (longSampleRate &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">25</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">26</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">27</span>] = (<span class="keyword">byte</span>) ((longSampleRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">28</span>] = (<span class="keyword">byte</span>) (byteRate &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">29</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">30</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">31</span>] = (<span class="keyword">byte</span>) ((byteRate &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// block align</span></span><br><span class="line">        header[<span class="number">32</span>] = (<span class="keyword">byte</span>) (<span class="number">2</span> * <span class="number">16</span> / <span class="number">8</span>);</span><br><span class="line">        header[<span class="number">33</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// bits per sample</span></span><br><span class="line">        header[<span class="number">34</span>] = <span class="number">16</span>;</span><br><span class="line">        header[<span class="number">35</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//data</span></span><br><span class="line">        header[<span class="number">36</span>] = <span class="string">'d'</span>;</span><br><span class="line">        header[<span class="number">37</span>] = <span class="string">'a'</span>;</span><br><span class="line">        header[<span class="number">38</span>] = <span class="string">'t'</span>;</span><br><span class="line">        header[<span class="number">39</span>] = <span class="string">'a'</span>;</span><br><span class="line">        header[<span class="number">40</span>] = (<span class="keyword">byte</span>) (totalAudioLen &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">41</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">42</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        header[<span class="number">43</span>] = (<span class="keyword">byte</span>) ((totalAudioLen &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        out.write(header, <span class="number">0</span>, <span class="number">44</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AudioTrack的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioAttributes;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioFormat;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioManager;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioRecord;</span><br><span class="line"><span class="keyword">import</span> android.media.AudioTrack;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaRecorder;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lll.va.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioTracker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String tag = <span class="string">"AudioTracker"</span>;</span><br><span class="line">    <span class="comment">//采用频率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_SAMPLE_RATE = <span class="number">16000</span>;</span><br><span class="line">    <span class="comment">//声道 单声道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_CHANNEL = AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    <span class="keyword">private</span> AudioTrack audioTrack;</span><br><span class="line">    <span class="keyword">private</span> Activity activity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buffersize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPlay = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstPlay = <span class="keyword">true</span>; <span class="comment">//用firstPlay和isPlay组合，可以完成暂停和继续播放的功能</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTask2byAudioTrack</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AudioTracker audioTracker = <span class="keyword">new</span> AudioTracker();</span><br><span class="line">        audioTracker.activity = activity;</span><br><span class="line">        Button btnPlay = activity.findViewById(R.id.btn_play_audio);</span><br><span class="line">        Button btnStop = activity.findViewById(R.id.btn_stop_audio);</span><br><span class="line">        Button btnPause = activity.findViewById(R.id.btn_pause_audio);</span><br><span class="line">        btnPlay.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                audioTracker.startPlay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btnStop.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                audioTracker.stopPlay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        btnPause.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                audioTracker.pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AudioAttributes取代了流类型的概念（例如参见AudioManager.STREAM_MUSIC或AudioManager.STREAM_ALARM），</span></span><br><span class="line">    <span class="comment">// 用于定义音频播放的行为。 通过允许应用程序定义，属性允许应用程序指定比在流类型中传达的信息更多的信息：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initAudioTrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFirstPlay) &#123;</span><br><span class="line">            buffersize = AudioTrack.getMinBufferSize(AUDIO_SAMPLE_RATE,</span><br><span class="line">                    AUDIO_CHANNEL, AUDIO_ENCODING);  <span class="comment">//audioTracker能接受的最小的buffer大小</span></span><br><span class="line">            audioTrack = <span class="keyword">new</span> AudioTrack(AudioAttributes.CONTENT_TYPE_MUSIC, AUDIO_SAMPLE_RATE, AUDIO_CHANNEL</span><br><span class="line">                    , AudioFormat.ENCODING_PCM_16BIT, buffersize, AudioTrack.MODE_STREAM);</span><br><span class="line">            data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffersize];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initAudioTrack();</span><br><span class="line">        audioTrack.play();</span><br><span class="line">        isPlay = <span class="keyword">true</span>;</span><br><span class="line">        playThread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioTrack.stop();</span><br><span class="line">        isPlay = <span class="keyword">false</span>;</span><br><span class="line">        Log.d(tag, <span class="string">"pasue "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioTrack.stop();</span><br><span class="line">        isPlay = <span class="keyword">false</span>;</span><br><span class="line">        isFirstPlay = <span class="keyword">true</span>;</span><br><span class="line">        audioTrack.release();</span><br><span class="line">        Log.d(tag, <span class="string">"stop "</span>);</span><br><span class="line">        is = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileInputStream is = <span class="keyword">null</span>;</span><br><span class="line">    String fileName = Environment.getExternalStorageDirectory() + <span class="string">"/test.wav"</span>;</span><br><span class="line">    Thread playThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFirstPlay) &#123; <span class="comment">//如果是首次播放（停止后再播放也算首次）则初始化流</span></span><br><span class="line">                    is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                    isFirstPlay = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.d(tag, <span class="string">"is = "</span> + is);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            writeData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (is == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (isPlay) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> read = is.read(data);</span><br><span class="line">                Log.d(tag, <span class="string">"read = "</span> + read);</span><br><span class="line">                <span class="keyword">if</span> (read != <span class="number">0</span> &amp;&amp; read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    audioTrack.write(data, <span class="number">0</span>, read);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stopPlay();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局就是很简单的layout和几个分别控制开始、暂停、结束的button，就不贴了</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 音视频任务3</title>
    <url>/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A13/</url>
    <content><![CDATA[<p>任务3. 在 Android 平台使用 Camera API 进行视频的采集，分别使用 SurfaceView、TextureView 来预览 Camera 数据，取到 NV21 的数据回调</p>
<p>由于这次的任务牵涉面十分广，所以用了很久才搞懂了一些知识，以后的任务也应该会做的越来越慢，不过十分合理，慢工出细活，上来一会儿就完成的东西，要不就是含金量不高，要不就是没有深究，对于学习阶段，虽然说有时候要管中窥豹不要太深究，但有些事情不搞清楚就不能算掌握知识了对吧？</p>
<p>下面是使用CameraAPI进行拍照和录视频，当然还有预览的全过程。虽然CameraAPI在5.0后就被弃用了（原因之一是它不能同时预览和拍摄），取而代之的是camera2，但由于众所周知的原因，仍然要好好学习。</p>
<p>添加权限后，如果是android6以上的，必须在设置的应用里面手动打开申请的权限</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.camera.autofocus"</span> <span class="attr">android:required</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>相机的角度，如果不加调整的打开相机，默认的角度是0°，（这一点很奇怪。。）一般竖屏状态下是90度，横屏则为0或180度(应该是取决于传感器的方向)</p>
<h2 id="拍摄照片"><a href="#拍摄照片" class="headerlink" title="拍摄照片"></a>拍摄照片</h2><p>使用Camera拍摄照片的步骤：<br>要使用此类拍摄照片，请使用以下步骤：</p>
<ol>
<li>从open（int）获取Camera的实例。(首先使用以下方法获得设备摄像头数目)<br>int cameraNum = Camera.getNumberOfCameras();<br>//上面open的有效取值是 0 ~ cameraNum-1 代表了摄像头的设备id</li>
<li>使用getParameters（）获取现有（默认）设置。如有必要，修改返回的Camera.Parameters对象并调setParameters（Camera.Parameters）</li>
<li>调用setDisplayOrientation（int）以确保正确的预览方向。<br>  重要提示：将完全初始化的SurfaceHolder传递给    setPreviewDisplay（SurfaceHolder）。没有surface，相机将无法启动预览。<br> 重要说明：调用startPreview（）开始更新预览曲面。必须先开始预览才能拍照。</li>
<li>如果需要，可以调用takePicture（Camera.ShutterCallback，Camera.PictureCallback，Camera.PictureCallback，Camera.PictureCallback）来捕获照片。等待回调提供实际的图像数据。</li>
<li>拍照后，预览显示将停止。要拍摄更多照片，请先再次调用startPreview（）。</li>
<li>调用stopPreview（）以停止更新预览surface。<br>   重要提示：调用release（）以释放相机以供其他应用程序使用。应用程序应立即在Activity.onPause（）中释放相机（并在Activity.onResume（）中重新打开它）。</li>
</ol>
<p>一般自定义的来说，surface显示的图像都会被拉伸，或者压扁，反正就是图像比例不对，这是由于surfaceView和Camera.Size不匹配导致的，所以要根据surfaceView的宽高，在Camera所支持的Size里面找一个最合适的</p>
<p>在启用startPreview后，就可以通过Camera.takePicture()方法拍摄一张照片，返回的照片数据通过Callback接口获取。takePicture()接口可以获取三个类型的照片：</p>
<ul>
<li>第一个，ShutterCallback接口，在快门瞬间被回调，通常用于播放“咔嚓”这样的音效；</li>
<li>第二个，PictureCallback接口，返回未经压缩的RAW类型照片(字节数组)；</li>
<li>第三个，PictureCallback接口，返回经过压缩的JPEG类型照片(字节数组)；</li>
</ul>
<p>这三个都可以不实现，第一个一般没啥影响，但第二个第三个不实现则相当于拍的东西就没了。（第二第三个可以选一个实现）调用此方法后，在返回JPEG回调之前，不得调用startPreview（）或拍摄另一张照片。</p>
<p>camera.setDisplayOrientation(90); //设定的是预览的方向，预览和数据是独立的，如果只设置了DisplayOrientation，则在surfaceView中显示正常，但保存的数据仍然是0°的</p>
<p>修改拍摄数据角度的两种方法(以下均是竖屏情况，横屏情况不用额外处理，因为默认是横屏情况)：</p>
<ol>
<li>直接在设置camera参数的时候设置 parameters.setRotation(90); //这样拍摄出的data就是修正过后的数据，直接写到文件里即可<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        os.write(data);</span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCamera.startPreview();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>不设置相机的Rotation，这样得到的数据是横屏情况下的，要使用Matrix和Bitmap进行修正<br>parameters.setPreviewFormat(ImageFormat.NV21); //默认预览帧格式为NV21,注意很多格式设备可能不支持，程序就会崩,如nexus6p不支持YUY2</li>
</ol>
<h2 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h2><h4 id="使用surfaceView"><a href="#使用surfaceView" class="headerlink" title="使用surfaceView"></a>使用surfaceView</h4><ol>
<li>像上面一样获得camera的实例并初始化它，并开启preview</li>
<li>调用unlock()允许mediaRecorder的工作线程使用设定好参数的camera</li>
<li>把camera实例传给MediaRecorder.setCamera(Camera) </li>
<li>设置用于预览的surface：MediaRecorder.setPreviewDisplay（如果camera没绑定surface，则此步骤会替换camera的surface为本参数）<br>//以下为设置录制的参数<br>设置视频源setVideoSource： 一般为摄像头<br>设置音频源setAudioSource:一般是CAMCORDER(单纯录视频是没声音的)  如果是用mediaRecorder单录音频的话，一般用MIC<br>设置输出文件格式：setOutputFormat<br>设置视频的角度：setOrientationHint //预览角度在camera的参数里设置<br>//下面的必须要放在输出格式确定后<br>设置视频编码：setVideoEncoder<br>设置音频编码:setAudioEncoder<br>//下面的必须要放在编码确定后<br>设置视频分辨率：setVideoSize; 这里的分辨率必须要选择设备摄像头支持的分辨率,否则报错(Camera.getParameters().getSupportedPreviewSizes()的值之一)<br>设置录制视频的捕获帧速率：setVideoFrameRate(); //必须要选择摄像头支持的帧率，否则报错（mCamera.getParameters().getSupportedPreviewFrameRates()的值之一）<br>设置所录制视频的编码位率:setVideoEncodingBitRate(3 * 1024 * 1024);<br>设置记录会话的最大持续时间(毫秒)setMaxDuration(30 * 1000);<br>设置输出文件的路径：setOutputFile</li>
<li>当完成录制后，调用camera.reconnect把camera的使用权从mediaRecorder的工作线程转回到设置了它的本线程</li>
<li>调用mediaRecorder调用stop和release 释放资源<br>一些总结性的概述：<br>surfaceView 只是一个用来占位置的控件，是用来显示surface内容的，它会显示它绑定的SurfaceHolder所持有的surface， 真正用于显示的是surface(它是具体的要显示的数据)，surface的持有者是SurfaceHolder，每个surfaceView生来就有一个默认与其绑定的SurfaceHolder，通过getHolder来获取，SurfaceHolder会决定如何去显示surface，每个surface有且只有一个SurfaceHolder，<br>surfaceView:画布<br>surface：画的内容<br>surfaceHolder，画内容的持有者<br>surfaceView、surfaceHolder、surface三位一体，是一个不可分的整体</li>
</ol>
<blockquote>
<p>一个camera设置好参数，它本身是被本线程持有的，持有的话是被lock的，mediaRecorder的工作是在单独的线程中完成的<br>使用setCamera给mediarecorder设置一个被设置好相机。而如果不调用setCamera设置相机的话，分配给的是一个默认情况下的相机，也就是说什么参数都没有被设置，这样一般不可能满足拍摄需求，因此一般要给mediaRecorder设置camera<br><br>在mediaRecorder.start之前，它的camera必须要调用unlock(如果设置了的话)，因为mediaRecorder的工作是在单独的线程中完成的，而camera默认是被创建它的线程所持有的，这样mediaRecorder的工作线程无法使用它)，如果start顺利结束，则会自动调用lock归还camera，如果start调用失败，则要手动lock来回收camera的所有权</p>
<p>mediaRecorder.setPreviewDisplay(Surface s)<br>给mediaRecorder设置surface，surface是用来显示mediaRecorder的相机的预览。如果s已经被一个设置给了camera（只是设置给了，还没有被持有资源），而且这个camera已经通过mediaRecorder.setCamera被设置给了mediaRecorder，那么这个方法不需要调用。如果s已经被设置给了一个另一个camera，只是设置给了，还没有被持有资源），但这个camera没有被设置给mediaRecorder，那么这个s将会被设置给给mediaRecorder自己的camera（如果没设置，则是默认的camera）。此时mediaRecorder自己的camera和另一个camera被设置了同一个surface.<br>如果s为空，则完全不会发生任何事</p>
<p><br>camera.setHolder<br>给camera设置一个holder，即surface；但此时holder的surface资源并不为camera所持有，只有当开启预览(即startPreview)时，surface资源才会被camera所持有（下面所说的surface和相应的surfaceHolder都是绑定的，彼此一体，surface资源也就相当于holder的资源）</p>
<p>如果对一个camera持有一个surface的资源，再次让另一个camera再次去持有这个surface资源，则会报错(mediaRecorder.start中会调用类似于它自己的camera.startPreview,startPreview会试图去占有surface资源)也就是说，同一个surfaceHolder可以被多个camera设置，但同时只能有一个camera持有它的surface的资源，否则就会报错。可以对同一个camera连续多次试图持有资源（反正资源就是你的，反复持有还是这些）.<br><br>当用startPreview成功开启预览后,surface的资源就被camera持有，此时单纯调用stopPreview关闭预览并不能释放它所持有的surface资源，必须要用camera.release(完全释放camera)，或者直接setDisplayHolder（null）（只释放camera占有的surface资源，不改变camera的其他参数设置）才能释放它占用的surface资源。但不能直接把camera置为null来释放资源，因为这样只能减少它的引用计数，不是真正的释放资源。</p>
</blockquote>
<p>mediaRecorder 不会吧自己的surface主动连接到自己设置的camera, 除非是不设置camera而使用默认的camera，因为mediaRecorder会默认自己设置的camera有surface</p>
<p>camera.setDisplayOrientation设置相机预览的角度，mediaRecorder.setOrientationHini设置存储的视频的角度，两者互相独立</p>
<h4 id="使用TextureView"><a href="#使用TextureView" class="headerlink" title="使用TextureView"></a>使用TextureView</h4><p>TextureViewView:<br>TextureView可用于显示内容流。 这样的内容流可以例如是视频或OpenGL场景。 内容流可以来自应用程序的进程以及远程进程。</p>
<p>TextureView只能在硬件加速窗口中使用。 在软件中渲染时，TextureView将不会绘制任何内容。(例如在xml中给textureView设置背景色，就直接会报错)</p>
<p>与SurfaceView不同，TextureView不会创建单独的窗口，而是表现为常规View。 这个关键区别允许它进行移动，转换，动画等。例如，您可以通过调用myView.setAlpha（0.5f）使TextureView半透明。</p>
<p>使用TextureView很简单：您需要做的就是获得它的SurfaceTexture。 然后，把SurfaceTexture用来呈现内容。 以下示例演示如何将相机预览渲染到TextureView中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiveCameraActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">TextureView</span>.<span class="title">SurfaceTextureListener</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> Camera mCamera;</span><br><span class="line">      <span class="keyword">private</span> TextureView mTextureView;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">          mTextureView = <span class="keyword">new</span> TextureView(<span class="keyword">this</span>);</span><br><span class="line">          mTextureView.setSurfaceTextureListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">          setContentView(mTextureView);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          mCamera = Camera.open();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              mCamera.setPreviewTexture(surface);</span><br><span class="line">              mCamera.startPreview();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">              <span class="comment">// Something bad happened</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Ignored, Camera does all the work for us</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">          mCamera.stopPreview();</span><br><span class="line">          mCamera.release();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Invoked every time there's a new Camera preview frame</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过调用getSurfaceTexture（）或使用TextureView.SurfaceTextureListener来获取TextureView的SurfaceTexture。 重要的是要知道只有在将TextureView附加到窗口（并且已调用onAttachedToWindow（）之后）才能使用SurfaceTexture。因此，强烈建议您使用listener在SurfaceTexture可用时进行通知。</p>
<p>值得注意的是，只有一个生产者可以使用TextureView。 例如，如果使用TextureView显示相机预览，则无法使用lockCanvas（）同时绘制到TextureView。<br>如同surface一样，TextureView的surfaceTexture资源同一时间也只能被一个对象所持有</p>
<p>———————————————————————————————————————————————————————————————<br>SurfaceTexture:<br>从图像流中捕获帧作为OpenGL ES纹理。</p>
<p>图像流可以来自相机预览或视频解码。从SurfaceTexture创建的Surface可以用作android.hardware.camera2，MediaCodec，MediaPlayer和Allocation API的输出目标。调用updateTexImage（）时，将更新创建SurfaceTexture时指定的纹理对象的内容，以包含图像流中的最新图像。这可能导致跳过一些流的帧。</p>
<p>在指定旧版Camera API的输出目标时，也可以使用SurfaceTexture代替SurfaceHolder。这样做会导致图像流中的所有帧都被发送到SurfaceTexture对象而不是设备的显示。</p>
<p>从纹理中采样时，应首先使用通过getTransformMatrix（float []）查询的矩阵变换纹理坐标。每次调用updateTexImage（）时变换矩阵都会改变，因此每次更新纹理图像时都应该重新查询。该矩阵将形式为（s，t，0,1）的传统2D OpenGL ES纹理坐标列向量转换为包含区间[0,1]上的s和t到流式纹理中的适当采样位置。此变换可补偿图像流源的任何属性，使其看起来与传统的OpenGL ES纹理不同。例如，可以通过使用查询的矩阵变换列向量（0,0,0,1）来完成从图像左下角的采样，而从图像的右上角进行采样可以通过变换来完成（ 1,1,0,1）。</p>
<p>纹理对象使用GL_TEXTURE_EXTERNAL_OES纹理目标，该目标由GL_OES_EGL_image_external OpenGL ES扩展定义。这限制了纹理的使用方式。每次绑定纹理时，它必须绑定到GL_TEXTURE_EXTERNAL_OES目标而不是GL_TEXTURE_2D目标。此外，从纹理中采样的任何OpenGL ES 2.0着色器必须使用例如“#extension GL_OES_EGL_image_external：require”指令声明其对此扩展的使用。此类着色器还必须使用samplerExternalOES GLSL采样器类型访问纹理。</p>
<p>可以在任何线程上创建SurfaceTexture对象。 updateTexImage（）只能在包含纹理对象的OpenGL ES上下文的线程上调用。在任意线程上调用可用帧的回调，因此除非特别小心，否则不应直接从回调中调用updateTexImage（）。<br>———————————————————————————————————————————————————————————————</p>
<p>录制流程：<br>其他步骤均和surfaceView一样，只有第四步有区别,由于此时不能获得surfaceHolder，只要把TextureView的SurfaceTexture绑定到相机即可（给camera设置用于预览的surfaceTexture：camera.setPreviewTexture（代替camera.setPreviewDisplay)，同时而且也不需要给mediaRecorder调用setPreviewDisplay）</p>
<p>MediaRecorder：用来录制音频和视频，录制控制基于简单的状态机，如下图：<br><img src="https://img-blog.csdnimg.cn/20181205184528266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>使用MediaRecorder录制<strong>音频</strong>的流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A common <span class="keyword">case</span> of using MediaRecorder to record audio works as follows:</span><br><span class="line">MediaRecorder recorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line"> recorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line"> recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class="line"> recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);</span><br><span class="line"> recorder.setOutputFile(PATH_NAME);</span><br><span class="line"> recorder.prepare();</span><br><span class="line"> recorder.start();   <span class="comment">// Recording is now started</span></span><br><span class="line"> ...</span><br><span class="line"> recorder.stop();</span><br><span class="line"> recorder.reset();   <span class="comment">// You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line"> recorder.release(); <span class="comment">// Now the object cannot be reused</span></span><br></pre></td></tr></table></figure>
<p>//这个不需要手动另开线程写数据，体积小使用方便，但很大的一个缺点就是录下的音质不太好。相比之下AudioRecord虽然麻烦一点，但录制的更像是无损音质</p>
<p>application可能希望注册信息和错误事件，以便在录制期间获知某些内部更新和可能的运行时错误。 通过设置适当的监听器（通过调用（到setOnInfoListener（OnInfoListener）setOnInfoListener和/或setOnErrorListener（OnErrorListener）setOnErrorListener）来注册此类事件。为了接收与这些侦听器关联的相应回调，应用程序需要在运行Looper的线程上创建MediaRecorder对象 （默认情况下，主UI线程已经运行了Looper）。</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">使用MediaRecorder报错at android.media.MediaRecorder.start(Native <span class="function"><span class="keyword">Method</span>)：很可能是如下原因:</span> </span><br><span class="line"><span class="number">1</span>.使用下面两个函数但参数不被当前硬件所支持</span><br><span class="line">mediaRecorder.setVideoFrameRate()和mediaRecorder.setVideoSize(videoWidth, videoHeight)</span><br><span class="line"><span class="comment">//注释掉后，会使用硬件支持的默认的参数，就不会出错了,</span></span><br><span class="line">要获得硬件支持的参数用如下的函数：</span><br><span class="line">mCamera.getParameters().getSupportedPreviewSizes()的值之一</span><br><span class="line">mCamera.getParameters().getSupportedPreviewFrameRates()的值之一</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.已经有其他摄像头开启过预览，持有了SurfaceView或SurfaceTexture的surface资源，但停止预览后没有释放资源</span><br><span class="line"></span><br><span class="line">另：mediaRecorder.setVideoSize不能设置的太大，否则点击录像后画面会停住</span><br></pre></td></tr></table></figure>
<h5 id="相机预览数据的获取"><a href="#相机预览数据的获取" class="headerlink" title="相机预览数据的获取"></a>相机预览数据的获取</h5><p>转自：<a href="https://blog.csdn.net/lb377463323/article/details/53338045" target="_blank" rel="noopener">https://blog.csdn.net/lb377463323/article/details/53338045</a><br>首先定义一个类实现Camera.PreviewCallback接口，然后在它的onPreviewFrame(byte[] data, Camera camera)方法中即可接收到每一帧的预览数据，也就是参数data。<br>然后使用setPreviewCallback()、setOneShotPreviewCallback或setPreviewCallbackWithBuffer()注册回调接口，下面介绍一下这些方法： </p>
<pre><code>1，void setPreviewCallback (Camera.PreviewCallback cb) </code></pre><p>一旦使用此方法注册预览回调接口，onPreviewFrame()方法会一直被调用，直到camera preview销毁</p>
<p>注意，onPreviewFrame()方法跟Camera.open()是运行于同一个线程，所以为了防止onPreviewFrame()会阻塞UI线程，将Camera.open()放置在子线程中运行。</p>
<pre><code>2，void setOneShotPreviewCallback (Camera.PreviewCallback cb) </code></pre><p>使用此方法注册预览回调接口时，会将下一帧数据回调给onPreviewFrame()方法，调用完成后这个回调接口将被销毁。也就是只会回调一次预览帧数据。</p>
<pre><code>3，void setPreviewCallbackWithBuffer (Camera.PreviewCallback cb) </code></pre><p>它跟setPreviewCallback的工作方式一样，但是要求指定一个字节数组作为缓冲区，用于预览帧数据，这样能够更好的管理预览帧数据时使用的内存。它一般搭配addCallbackBuffer方法使用，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] mPreBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//首先分配一块内存作为缓冲区，size的计算方式见第四点中</span></span><br><span class="line">mCamera.addCallbackBuffer(mPreBuffer);</span><br><span class="line">mCamera.setPreviewCallbackWithBuffer(Camera.PreviewCallback cb);</span><br><span class="line">mCamera.startPreview();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPreBuffer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPreBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    mCamera.addCallbackBuffer(mPreBuffer);<span class="comment">//将此缓冲区添加到预览回调缓冲区队列中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setPreviewCallbackWithBuffer需要在startPreview()之前调用，因为setPreviewCallbackWithBuffer使用时需要指定一个字节数组作为缓冲区，用于预览帧数据，所以我们需要在setPreviewCallbackWithBuffer之前调用addCallbackBuffer，这样onPreviewFrame的data才有值。</p>
<p>总结一下，设置addCallbackBuffer的地方有两个，一个是在startPreview之前，一个是在onPreviewFrame中，这两个都需要调用，如果在onPreviewFrame中不调用，那么预览帧数据就不会回调给onPreviewFrame了</p>
<pre><code>4，void addCallbackBuffer (byte[] callbackBuffer) </code></pre><p>添加一个预分配的缓冲区到预览回调缓冲区队列中。应用程序可一添加一个或多个缓冲器到这个队列中。当预览帧数据到达时并且缓冲区队列仍然有至少一个可用的缓冲区时，这个 缓冲区将会被消耗掉然后从队列中移除，然后这个缓冲区会调用预览回调接口。如果预览帧数据到达时没有剩余的缓冲区，这帧数据将会被丢弃。当缓冲区中的数据处理完成后，应用程序应该将这个缓冲区添加回缓冲区队列中。<br>对于非YV12的格式，缓冲区的Size是预览图像的宽、高和每个像素的字节数的乘积。宽高可以使用getPreviewSize()方法获取。每个像素的字节数可以使用ImageFormat.getBitsPerPixel(mCameraParameters.getPreviewFormat()) / 8获取。<br>对于YU12的格式，缓冲区的Size可以使用setPreviewFormat(int)里面的公式计算，具体详见官方文档。<br>这个方法只有在使用setPreviewCallbackWithBuffer(PreviewCallback)时才有必要使用。当使用setPreviewCallback(PreviewCallback) 或者setOneShotPreviewCallback(PreviewCallback)时，缓冲区会自动分配。当提供的缓冲区如果太小了，不能支持预览帧数据时，预览回调接口将会return null，然后从缓冲区队列中移除此缓冲区。</p>
<p>完整代码：只需在activity里面调用runTask3即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.SurfaceTexture;</span><br><span class="line"><span class="keyword">import</span> android.hardware.Camera;</span><br><span class="line"><span class="keyword">import</span> android.media.MediaRecorder;</span><br><span class="line"><span class="keyword">import</span> android.os.AsyncTask;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceHolder;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceView;</span><br><span class="line"><span class="keyword">import</span> android.view.TextureView;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.lll.va.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task3</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">TextureView</span>.<span class="title">SurfaceTextureListener</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SurfaceHolder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String tag = Task3<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera mCamera;</span><br><span class="line">    <span class="keyword">private</span> SurfaceHolder mHolder;</span><br><span class="line">    <span class="keyword">private</span> CameraUtil mCameraUtil;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> SurfaceView surfaceView;</span><br><span class="line">    <span class="keyword">private</span> TextureView textureView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Task3 task3;</span><br><span class="line">    <span class="keyword">private</span> Activity mActivity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isSurfaceMode;  <span class="comment">//切换surfaceview和textureview的演示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String videoFileName = Environment.getExternalStorageDirectory() + <span class="string">"/test_vedio.mp4"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runTask3</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        task3 = <span class="keyword">new</span> Task3(activity);</span><br><span class="line">        task3.initView();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task3</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        mActivity = activity;</span><br><span class="line">        mContext = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mActivity.setContentView(R.layout.activity_task3);</span><br><span class="line"></span><br><span class="line">        surfaceView = mActivity.findViewById(R.id.sv_t3);</span><br><span class="line">        textureView = mActivity.findViewById(R.id.texture_view_1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了知道surface的生命周期，一般只有surface建好后才开始下一步动作</span></span><br><span class="line">        <span class="comment">//surfaceView必须给holder添加callback，TextureView必须给自己添加listener</span></span><br><span class="line">        <span class="keyword">if</span> (surfaceView.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            isSurfaceMode = <span class="keyword">true</span>;</span><br><span class="line">            surfaceView.getHolder().addCallback(<span class="keyword">this</span>);</span><br><span class="line">            mHolder = surfaceView.getHolder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isSurfaceMode = <span class="keyword">false</span>;</span><br><span class="line">            textureView.setSurfaceTextureListener(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Button btnTakePic = mActivity.findViewById(R.id.btn_take_pic);</span><br><span class="line">        Button btnStartVideo = mActivity.findViewById(R.id.btn_start_video);</span><br><span class="line">        Button btnStopVideo = mActivity.findViewById(R.id.btn_stop_video);</span><br><span class="line">        btnTakePic.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStartVideo.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        btnStopVideo.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getWidthAndHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        width = isSurfaceMode ? surfaceView.getWidth() : textureView.getWidth();</span><br><span class="line">        height = isSurfaceMode ? surfaceView.getHeight() : textureView.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.release();</span><br><span class="line">            mCamera = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(tag, <span class="string">"is surfaceview = "</span> + isSurfaceMode);</span><br><span class="line">        mCameraUtil = CameraUtil.getInstance();</span><br><span class="line">        mCamera = mCameraUtil.openCamera(<span class="number">0</span>);</span><br><span class="line">        Bundle paramBundle = <span class="keyword">new</span> Bundle();  <span class="comment">//感觉干脆用bundle传参好了</span></span><br><span class="line">        getWidthAndHeight();</span><br><span class="line">        paramBundle.putInt(<span class="string">"width"</span>, width);</span><br><span class="line">        paramBundle.putInt(<span class="string">"height"</span>, height);</span><br><span class="line">        mCameraUtil.setCameraParamter(mContext, mCamera, paramBundle);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据不同的view，选择不同的预览载体</span></span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                mCamera.setPreviewDisplay(surfaceView.getHolder());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mCamera.setPreviewTexture(textureView.getSurfaceTexture());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预览监听</span></span><br><span class="line">        mCamera.setPreviewCallback(mCameraCallback);</span><br><span class="line"><span class="comment">//        mCamera.setPreviewCallbackWithBuffer(mCameraCallback);</span></span><br><span class="line">        <span class="comment">//开始预览</span></span><br><span class="line">        mCamera.startPreview();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************  录视频部分   *******************************/</span></span><br><span class="line">    MediaRecorder mediaRecorder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startVideoRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mediaRecorder = <span class="keyword">new</span> MediaRecorder();<span class="comment">// 创建mediarecorder对象</span></span><br><span class="line">        <span class="comment">// 设置录制视频源为设置好参数的Camera(相机)</span></span><br><span class="line">        mediaRecorder.setOnInfoListener(mediaCallbackListener);</span><br><span class="line">        mediaRecorder.setOnErrorListener(mediaCallbackListener);</span><br><span class="line">        mCamera.unlock();</span><br><span class="line"></span><br><span class="line">        mediaRecorder.setCamera(mCamera);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode)<span class="comment">//如果给camera设置了setPreviewDisplay，则这句可以不加</span></span><br><span class="line">            mediaRecorder.setPreviewDisplay(mHolder.getSurface());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"camera + "</span> + mCamera);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line">        mediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">        <span class="comment">// 设置录制完成后视频的封装格式THREE_GPP为3gp.MPEG_4为mp4</span></span><br><span class="line">        mediaRecorder</span><br><span class="line">                .setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">        <span class="comment">// 设置录制的视频编码h264</span></span><br><span class="line">        <span class="comment">//音频编码为AAC</span></span><br><span class="line">        mediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">        mediaRecorder.setOrientationHint(<span class="number">90</span>);</span><br><span class="line">        <span class="comment">// 设置视频录制的分辨率。必须放在设置编码和格式的后面，否则报错</span></span><br><span class="line">        mediaRecorder.setVideoSize(<span class="number">1600</span>, <span class="number">1200</span>);</span><br><span class="line">        mediaRecorder.setVideoEncodingBitRate(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>);<span class="comment">// 设置编码位率,图像模糊的设置了这个图像就清晰了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置录制的视频帧率。必须放在设置编码和格式的后面，否则报错</span></span><br><span class="line">        mediaRecorder.setVideoFrameRate(<span class="number">24</span>);</span><br><span class="line"><span class="comment">//        mediaRecorder.setPreviewDisplay(mHolder.getSurface());</span></span><br><span class="line">        <span class="comment">// 设置视频文件输出的路径</span></span><br><span class="line">        mediaRecorder.setOutputFile(Task3.videoFileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 准备录制</span></span><br><span class="line">            mediaRecorder.prepare();</span><br><span class="line">            <span class="comment">// 开始录制</span></span><br><span class="line">            mediaRecorder.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopVideoRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaRecorder == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        mediaRecorder.stop();</span><br><span class="line">        mediaRecorder.release();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCamera.lock();</span><br><span class="line">            mCamera.reconnect();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这或许是camera的bug，预览的时候不能同时进行拍摄，如果拍摄结束后还需要预览</span></span><br><span class="line">            <span class="comment">//要再setPreviewCallback和startPreview，貌似在camera2中解决了</span></span><br><span class="line">            mCamera.setPreviewCallback(mCameraCallback);</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line"><span class="comment">//            mCamera.lock();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CameraCallback mCameraCallback = <span class="keyword">new</span> CameraCallback();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CameraCallback</span> <span class="keyword">implements</span> <span class="title">Camera</span>.<span class="title">PreviewCallback</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreviewFrame</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len = data.length;</span><br><span class="line">            <span class="comment">//当相机的预览分辨率为1600 * 1200，预览图像的编码格式为 NV21 即 12bit/pixel 时</span></span><br><span class="line">            <span class="comment">//每一帧图像的大小应该为 1600 * 1200 * 12 / 8 = 2880000 Bytes</span></span><br><span class="line">            Log.d(tag, <span class="string">"onPreviewFrame data.data len="</span> + len);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MediaCallbackListener mediaCallbackListener;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************  SurfaceTextureListener  **********************************/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isSurfaceMode)</span><br><span class="line">            initCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureUpdated</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************  SurfaceCallback  **********************************/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSurfaceMode)</span><br><span class="line">            initCamera();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**********************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MediaCallbackListener</span> <span class="keyword">implements</span> <span class="title">MediaRecorder</span>.<span class="title">OnInfoListener</span>, <span class="title">MediaRecorder</span>.<span class="title">OnErrorListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(MediaRecorder mr, <span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInfo</span><span class="params">(MediaRecorder mr, <span class="keyword">int</span> what, <span class="keyword">int</span> extra)</span> </span>&#123;</span><br><span class="line">            Log.d(tag, <span class="string">"info"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        if (mCamera == null) return;</span></span><br><span class="line">        <span class="keyword">if</span> (v.getId() == R.id.btn_take_pic) <span class="comment">//拍照</span></span><br><span class="line">            takePicture();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_start_video)</span><br><span class="line">            startVideoRecord();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (v.getId() == R.id.btn_stop_video)</span><br><span class="line">            stopVideoRecord();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**************************  拍照部分   *******************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCamera.takePicture(<span class="keyword">null</span>, <span class="keyword">null</span>, mPictureCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String fileName = Environment.getExternalStorageDirectory() + <span class="string">"/t3.jpg"</span>;</span><br><span class="line">    <span class="keyword">private</span> Camera.PictureCallback mPictureCallback = <span class="keyword">new</span> Camera.PictureCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureTaken</span><span class="params">(<span class="keyword">byte</span>[] data, Camera camera)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            SavePicAsyncTask saveBitmapTask = <span class="keyword">new</span> SavePicAsyncTask();</span><br><span class="line">            saveBitmapTask.execute(data);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mCamera.startPreview();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera.ShutterCallback mShutterCallback = <span class="keyword">new</span> Camera.ShutterCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是设置了rotation时调用保存图片的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePic</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            os.write(data);</span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCamera.startPreview();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用bitmap保存时，因为compress是耗时方法，放在onPictureTaken中会体验极差，所以放个后台任务来压缩保存图片</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="class"><span class="keyword">class</span> <span class="title">SavePicAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Object <span class="title">doInBackground</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = (<span class="keyword">byte</span>[]) objects[<span class="number">0</span>];</span><br><span class="line">            Bitmap bm0 = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//由于camera.</span></span><br><span class="line">            Matrix m = <span class="keyword">new</span> Matrix();</span><br><span class="line">            m.setRotate(<span class="number">90</span>, (<span class="keyword">float</span>) bm0.getWidth() / <span class="number">2</span>, (<span class="keyword">float</span>) bm0.getHeight() / <span class="number">2</span>); <span class="comment">//后面两个是旋转轴心坐标</span></span><br><span class="line">            Bitmap bitmap = Bitmap.createBitmap(bm0, <span class="number">0</span>, <span class="number">0</span>, bm0.getWidth(), bm0.getHeight(), m, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                FileOutputStream os = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                bitmap.compress(Bitmap.CompressFormat.JPEG, <span class="number">85</span>, os);</span><br><span class="line">                os.flush();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CameraUtil</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.res.Configuration;</span><br><span class="line"><span class="keyword">import</span> android.graphics.ImageFormat;</span><br><span class="line"><span class="keyword">import</span> android.hardware.Camera;</span><br><span class="line"><span class="keyword">import</span> android.media.Image;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String tag = CameraUtil<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CameraUtil util;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CameraUtil <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (util == <span class="keyword">null</span>) &#123;</span><br><span class="line">            util = <span class="keyword">new</span> CameraUtil();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> util;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> CameraNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> mIsPortrait = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CameraUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CameraNum = Camera.getNumberOfCameras();</span><br><span class="line">        Log.d(tag, <span class="string">"cam_num="</span> + CameraNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Camera <span class="title">openCamera</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CameraNum == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Camera camera = Camera.open(id); <span class="comment">//打开第一个摄像头</span></span><br><span class="line">        <span class="keyword">return</span> camera;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCameraParamter</span><span class="params">(Context context, Camera camera, Bundle paramBundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (camera == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Camera.Parameters parameters = camera.getParameters();</span><br><span class="line">        parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO); <span class="comment">//闪光灯模式</span></span><br><span class="line">        parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = paramBundle.getInt(<span class="string">"width"</span>);</span><br><span class="line">        <span class="keyword">int</span> height = paramBundle.getInt(<span class="string">"height"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"width = "</span> + width + <span class="string">" height ="</span> + height);</span><br><span class="line">        List&lt;Camera.Size&gt; sizeList = parameters.getSupportedPreviewSizes();</span><br><span class="line">        Camera.Size lastSize = getOptimalPreviewSize(context, sizeList, width, height);</span><br><span class="line">        parameters.setPreviewSize(lastSize.width, lastSize.height);</span><br><span class="line">        Log.d(tag, <span class="string">"surwidth = "</span> + width + <span class="string">" surheight ="</span> + height</span><br><span class="line">                + <span class="string">" size width="</span> + lastSize.width + <span class="string">" size height="</span> + lastSize.height);</span><br><span class="line">        parameters.setPreviewFormat(ImageFormat.NV21); <span class="comment">//默认预览帧格式</span></span><br><span class="line">        <span class="comment">//拍照分辨率和预览分辨率</span></span><br><span class="line"><span class="comment">//        parameters.setPictureSize();</span></span><br><span class="line"><span class="comment">//        parameters.setPreviewSize(); //预览分辨率只能从上面的sizeList里面选取</span></span><br><span class="line"></span><br><span class="line">        followScreenOrientation(context, camera);</span><br><span class="line">        camera.setParameters(parameters);</span><br><span class="line">        <span class="comment">//有的手机这么设置会出错，则使用camera.getParameters().setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);的形式设置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">followScreenOrientation</span><span class="params">(Context context, Camera camera)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> orientation = context.getResources().getConfiguration().orientation;</span><br><span class="line">        <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">            camera.setDisplayOrientation(<span class="number">180</span>);</span><br><span class="line">            mIsPortrait = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">            camera.setDisplayOrientation(<span class="number">90</span>);</span><br><span class="line">            mIsPortrait = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然这样画面还是有一点点扁，还是不知道系统相机是如何做到画面不扁而且还像素高的</span></span><br><span class="line">    <span class="keyword">private</span> Camera.<span class="function">Size <span class="title">getOptimalPreviewSize</span><span class="params">(Context context, List&lt;Camera.Size&gt; sizes, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> ASPECT_TOLERANCE = <span class="number">0.2</span>;  <span class="comment">//camera宽高比与surface宽高比的最大误差阈值,越小越精确，但可能没有合适的分辨率，一般为0.1或0.2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> orientation = context.getResources().getConfiguration().orientation;</span><br><span class="line">        <span class="keyword">int</span> targetHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> targetRatio = <span class="number">0</span>d;</span><br><span class="line">        <span class="comment">//由于横竖屏不一样，系统相机的尺寸默认是横屏状态下的，</span></span><br><span class="line">        <span class="comment">// 所以竖屏状态下，比例就是高宽比（因此此时高大于宽），而与系统中高度比较时则应该用宽(哪个小用哪个)</span></span><br><span class="line">        <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">            targetRatio = (<span class="keyword">double</span>) w / h;</span><br><span class="line">            targetHeight = h;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == Configuration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">            targetRatio = (<span class="keyword">double</span>) h / w;</span><br><span class="line">            targetHeight = w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获得surfaceView的宽高比</span></span><br><span class="line">        <span class="keyword">if</span> (sizes == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Camera.Size optimalSize = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">double</span> minDiff = Double.MAX_VALUE; <span class="comment">//在比例合适的情况下，两种高度最低能达到的差值（肯定是越小越符合），一开始设为最大浮点数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"targetHeight="</span> + targetHeight);</span><br><span class="line">        <span class="comment">// Try to find an size match aspect ratio and size</span></span><br><span class="line">        <span class="keyword">for</span> (Camera.Size size : sizes) &#123;  <span class="comment">//遍历当前摄像头支持的分辨率，并计算宽高比</span></span><br><span class="line">            <span class="keyword">double</span> ratio = (<span class="keyword">double</span>) size.width / size.height;</span><br><span class="line">            Log.d(tag, <span class="string">"width="</span> + size.width + <span class="string">" height="</span> + size.height);</span><br><span class="line">            Log.d(tag, <span class="string">"target Ratio="</span> + targetRatio + <span class="string">" ratio="</span> + ratio);</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(ratio - targetRatio) &gt; ASPECT_TOLERANCE) <span class="keyword">continue</span>; <span class="comment">//如果两个宽高比之差大于阈值，不符合</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(size.height - targetHeight) &lt; minDiff) &#123; <span class="comment">//找到了更小的差值，则替换最合适的比例</span></span><br><span class="line">                optimalSize = size;</span><br><span class="line">                minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//         Cannot find the one match the aspect ratio, ignore the requirement</span></span><br><span class="line">        <span class="keyword">if</span> (optimalSize == <span class="keyword">null</span>) &#123;          <span class="comment">//当使用阈值找不到时，则忽略比例阈值，直接用最小的高度差的那组分辨率</span></span><br><span class="line">            minDiff = Double.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (Camera.Size size : sizes) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(size.height - targetHeight) &lt; minDiff) &#123;</span><br><span class="line">                    optimalSize = size;</span><br><span class="line">                    minDiff = Math.abs(size.height - targetHeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> optimalSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局文件，只让surfaceview和textureview其中之一显示</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--surfaceView 和 TextureView选一个隐藏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">SurfaceView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_t3"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"visible"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextureView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/texture_view_1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"500dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_take_pic"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_take_pic"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_start_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_start_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/btn_stop_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:text</span>=<span class="string">"btn_stop_video"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 音视频任务7</title>
    <url>/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A17/</url>
    <content><![CDATA[<p>先做任务7，是因为做完任务4感觉想要稍微深入了解一下MediaCodec，感觉这样更能把刚学到的知识连贯一下。</p>
<p>任务7. 学习 MediaCodec API，完成音频 AAC 硬编、硬解</p>
<p>MediaCodec的作用是转换编码或解码文件，支持已编码的特定格式转成原始raw数据，<br>原始raw数据转成特定编码的格式<br>解码时，mediaCodec设定的格式是输入文件的格式，输出原始raw数据<br>编码时，mediaCodec设定的格式是输出文件的格式，输入为原始raw数据</p>
<p>解码时文件的格式和解码器设置的格式一定要一样，否则报错</p>
<h2 id="音频编解码："><a href="#音频编解码：" class="headerlink" title="音频编解码："></a>音频编解码：</h2><h3 id="解码："><a href="#解码：" class="headerlink" title="解码："></a>解码：</h3><ul>
<li>解码是吧audio/XXX给变成audio/raw，即pcm文件，最原始的未经压缩编码处理的文件。所以解码后的文件一般会比被压缩文件大得多<br>流程：</li>
<li>首先要使用MediaExtractor把音轨从文件中提取出来，把format也提取出来，根据要解码的mime创建codec：<br>mDCodec = MediaCodec.createDecoderByType(srcMIMTType);</li>
<li>把format设置到codec：mDCodec.configure(mFormat, null, null, 0); //视频文件如果要播放解码出的数据，则第二个参数选择要用于播放的surface</li>
<li>数据回调监听：mDCodec.setCallback(mDecodeCallback); （异步处理，感觉异步的好一点）</li>
<li>开始解码：mDCodec.start();<br>callback中：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="comment">//onInputBufferAvailable：当有可用的缓冲区时，会转到这里，在该函数中往可用的缓冲区写入要解码的数据，然后把缓冲区加入待处理队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//获得可用的缓冲</span></span><br><span class="line">            ByteBuffer inputBuffer = codec.getInputBuffer(index);</span><br><span class="line"></span><br><span class="line">            MediaCodec.BufferInfo info = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = mExtractor.readSampleData(inputBuffer, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> flag = mExtractor.getSampleFlags();</span><br><span class="line">            <span class="keyword">long</span> presentation = mExtractor.getSampleTime();</span><br><span class="line">            <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"size= "</span> + size + <span class="string">" flag="</span> + flag + <span class="string">" presentation="</span> + presentation);</span><br><span class="line"><span class="comment">//要对文件是否读到末尾单独处理，若读到末尾了，size,presentation都要置为0，flag要标注为 MediaCodec.BUFFER_FLAG_END_OF_STREAM</span></span><br><span class="line">            <span class="keyword">if</span> (size != -<span class="number">1</span>) &#123;</span><br><span class="line">                inputSize += size;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">                mExtractor.advance();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//当文件达到末尾时，用flag</span></span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                presentation = <span class="number">0</span>;</span><br><span class="line">                flag = MediaCodec.BUFFER_FLAG_END_OF_STREAM;</span><br><span class="line">                codec.queueInputBuffer(index, offset, size, presentation, flag);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//onOutputBufferAvailable：当有待处理数据完成解码时，会放入输出缓冲区，并转到这里，在该函数中获得解码后的raw数据，并且每次读出数据后要release当前缓冲，让它能够继续被使用，否则就那么一点缓冲区，不释放的话几下就没了</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MediaFormat format = codec.getOutputFormat(index);</span><br><span class="line">        Log.d(tag, <span class="string">"out format="</span> + format.getString(MediaFormat.KEY_MIME));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得可用的输出缓冲区（也就是解码好的数据）</span></span><br><span class="line">        ByteBuffer outputBuffer = codec.getOutputBuffer(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果直接定义 data =  new byte[100 * 1024]; 然后调用outputBuffer.get(data),</span></span><br><span class="line">        <span class="comment">// 则会使用data的长度去操作buffer，但buffer没这么大，导致BufferUnderflowException</span></span><br><span class="line">        <span class="comment">//所以下面两种方式选一种</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[outputBuffer.limit()];</span><br><span class="line">        outputBuffer.get(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] data = new byte[100 * 1024];</span></span><br><span class="line"><span class="comment">//        outputBuffer.get(data,0, outputBuffer.limit());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">        outputSize += data.length;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.write(data); <span class="comment">//写入流中</span></span><br><span class="line">            fos.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(tag, <span class="string">"flag="</span> + info.flags);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize= "</span> + outputSize);</span><br><span class="line">        <span class="comment">//用完后释放这个buffer，使其可以接着被使用</span></span><br><span class="line">        codec.releaseOutputBuffer(index, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//当到达末尾时，释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">            Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            stopAndrealseCodec();</span><br><span class="line">            exPCM2WAV();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDCodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mDCodec.release();</span><br><span class="line">        mDCodec = <span class="keyword">null</span>;</span><br><span class="line">        mExtractor.release();</span><br><span class="line">        mExtractor = <span class="keyword">null</span>;</span><br><span class="line">        Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">        Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">        Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pcm文件加入wav头变成wav文件，wav文件会被识别成audio/raw，而原始的pcm文件会被识别错误</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exPCM2WAV</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为什么从视频里(只试了mp4和3gp)剥离出来的要 原本的sampleRate/2才是正常速度？</span></span><br><span class="line">    <span class="keyword">int</span> sampleRate = mFormat.getInteger(MediaFormat.KEY_SAMPLE_RATE);</span><br><span class="line">    PcmToWavUtil util = <span class="keyword">new</span> PcmToWavUtil(sampleRate, mFormat.getInteger(MediaFormat.KEY_CHANNEL_COUNT),</span><br><span class="line">            AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line">    Log.d(tag, <span class="string">"sampleRate="</span> + sampleRate);</span><br><span class="line">    util.pcmToWav(outputFileName, outputFileName + <span class="string">".wav"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h3><p>编码是吧audio/raw给变成audio/XXX，是对原始数据压缩编码，但这个有一个问题要注意的是硬件是否支持这种编码方式，比如nexus6p，由于mp3格式编码是不开源的，所以不能编码成mp3文件。下面以把wav的原生格式编码成aac<br>流程：<br><em>编码要比解码多一个步骤，就是设置要编码的格式的各项数据，比如</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outFormat = MediaFormat.createAudioFormat(desMIMEType, SAMPLE_RATE, CHANNEL_COUNT); <span class="comment">//根据编码格式，采样率，声道数创建format</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>); <span class="comment">//比特率</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_AAC_PROFILE,  MediaCodecInfo.CodecProfileLevel.AACObjectLC);  <span class="comment">//aac特有的profile</span></span><br><span class="line">outFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, <span class="number">100</span> * <span class="number">1024</span>);<span class="comment">//输入缓存的最大值，设置这个防止一帧的数据量太大而超过默认的buffer大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加aac的csd-0，如果是视频，则csd-0和csd-1都要有（这个是干什么的还不清楚）</span></span><br><span class="line">ByteBuffer csd = ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((aacObjLC &lt;&lt; <span class="number">3</span>) | (sampleIndex &gt;&gt; <span class="number">1</span>)));</span><br><span class="line">csd.position(<span class="number">1</span>);</span><br><span class="line">csd.put((<span class="keyword">byte</span>) ((<span class="keyword">byte</span>) ((sampleIndex &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x80</span>) | (channelCount &lt;&lt; <span class="number">3</span>)));</span><br><span class="line">csd.flip();</span><br><span class="line">outFormat.setByteBuffer(<span class="string">"csd-0"</span>, csd); <span class="comment">// add csd-0</span></span><br><span class="line">System.out.println(Arrays.toString(csd.array()) + <span class="string">"===++”);</span></span><br><span class="line"><span class="string">查看设备支持的编码和解码器：</span></span><br><span class="line"><span class="string">MediaCodecList list = new MediaCodecList(MediaCodecList.ALL_CODECS);</span></span><br><span class="line"><span class="string">MediaCodecInfo[] infos = list.getCodecInfos();</span></span><br><span class="line"><span class="string">for (int i = 0; i &lt; infos.length; i++) &#123;</span></span><br><span class="line"><span class="string">    String name = infos[i].getName();</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>i=<span class="string">" + i + "</span> name=<span class="string">" + name);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">根据format创建相应的编码器</span></span><br><span class="line"><span class="string">//根据相应的格式找到是否有合适的编码器，如果有则返回其名称，然后创建相应的编码器</span></span><br><span class="line"><span class="string">String encodeName = list.findEncoderForFormat(outFormat);</span></span><br><span class="line"><span class="string">    Log.d(tag, "</span>encodeName=<span class="string">" + encodeName);</span></span><br><span class="line"><span class="string">    mECodec = MediaCodec.createByCodecName(encodeName);</span></span><br><span class="line"><span class="string">&#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="string">    e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">mECodec.setCallback(mEncodeCallback); //设置回调</span></span><br><span class="line"><span class="string">mECodec.configure(outFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);  //编码配置，编码时要设置最后一个参数</span></span><br><span class="line"><span class="string">mECodec.start();  //开始编码</span></span><br></pre></td></tr></table></figure>
<p>callback中：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">on</span>InputBufferAvailable和解码器的并无不同，都是由MediaExtractor读出数据放到缓存队列里等待处理</span><br></pre></td></tr></table></figure>

<p>onOutputBufferAvailable和默认流程和解码器类似，都是从缓冲队列中取出已经处理好的数据（每次取一帧），但编码器不同的一点是，这个数据只是真实数据流的编码，仅仅有这些没办法封装成可读的格式，还必须要加上可识别的部分，比如wav文件是在所有数据头部加上wav头，aac文件是在每一帧数据前面加上adts头，<br>adts见 <a href="https://www.cnblogs.com/lihaiping/p/5284547.html" target="_blank" rel="noopener">https://www.cnblogs.com/lihaiping/p/5284547.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOutputBufferAvailable</span><span class="params">(@NonNull MediaCodec codec, <span class="keyword">int</span> index, @NonNull MediaCodec.BufferInfo info)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fos == <span class="keyword">null</span>) <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"fos == null!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> outIndex = index;</span><br><span class="line">            MediaFormat format = codec.getOutputFormat(outIndex);</span><br><span class="line"></span><br><span class="line">            ByteBuffer outputBuffer = codec.getOutputBuffer(outIndex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = outputBuffer.limit();</span><br><span class="line">            outputSize += size;</span><br><span class="line">            <span class="keyword">byte</span>[] packedData = <span class="keyword">new</span> <span class="keyword">byte</span>[size + <span class="number">7</span>];</span><br><span class="line">            addADTStoPacket(packedData, packedData.length);</span><br><span class="line">            outputBuffer.get(packedData, <span class="number">7</span>, size);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.write(packedData);</span><br><span class="line">                fos.flush();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用完后释放这个buffer，使其可以接着被使用，如果一直不释放，如果文件太大则会导致缓冲区不够用</span></span><br><span class="line">            outputBuffer.clear();</span><br><span class="line">            codec.releaseOutputBuffer(outIndex, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (info.flags == MediaCodec.BUFFER_FLAG_END_OF_STREAM) &#123;</span><br><span class="line">                Log.d(tag, <span class="string">"BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">                stopAndrealseCodec();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每一帧前面都要加上ADTS头，可以看做是每一个AAC帧的帧头</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>;  <span class="comment">//AAC LC</span></span><br><span class="line">        <span class="comment">//39=MediaCodecInfo.CodecProfileLevel.AACObjectELD;</span></span><br><span class="line">        <span class="keyword">int</span> freqIdx = <span class="number">4</span>;  <span class="comment">//44.1KHz</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">2</span>;  <span class="comment">//CPE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        byte[] packet1 = new byte[packetLen];</span></span><br><span class="line">        <span class="comment">// fill in ADTS data</span></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (freqIdx &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //把这些清晰的放出来，但最好还是用上面的方式</span></span><br><span class="line"><span class="comment">//        //syncword</span></span><br><span class="line"><span class="comment">//        packet[0] = (byte) 0xFF;</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0xF &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //id</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1 &lt;&lt; 3;</span></span><br><span class="line"><span class="comment">//        //layer</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x00 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //protection_abscent</span></span><br><span class="line"><span class="comment">//        packet[1] |= 0x1;</span></span><br><span class="line"><span class="comment">//        //profile</span></span><br><span class="line"><span class="comment">//        packet[2] |= (profile -1) &lt;&lt; 6;</span></span><br><span class="line"><span class="comment">//        //sampling_frequency_index</span></span><br><span class="line"><span class="comment">//        packet[2] |= freqIdx &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //private bit</span></span><br><span class="line"><span class="comment">//        packet[2] |= 0x0 &lt;&lt; 1;</span></span><br><span class="line"><span class="comment">//        //channel_config</span></span><br><span class="line"><span class="comment">//        packet[2] |= chanCfg &gt;&gt; 2;  //高1位</span></span><br><span class="line"><span class="comment">//        packet[3] |= chanCfg &lt;&lt; 6;   //低2位</span></span><br><span class="line"><span class="comment">//        //copy and home;</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 4;</span></span><br><span class="line"><span class="comment">//        //cib and cis</span></span><br><span class="line"><span class="comment">//        packet[3] |= 0x00 &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//        //frame_length,单位是字节。不用管int是几个字节，把它当13位就行了,一帧的长度一般不可能超过13位能表达的最大值(8KB),</span></span><br><span class="line"><span class="comment">//        packet[3] |= packetLen &gt;&gt; 11;</span></span><br><span class="line"><span class="comment">//        packet[4] = (byte) (packetLen &gt;&gt; 3);</span></span><br><span class="line"><span class="comment">//        int x = packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//        packet[5] |= packetLen &lt;&lt; 5;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        packet[5] |= 0x7FF &gt;&gt; 6;</span></span><br><span class="line"><span class="comment">//        packet[6] |= 0x7FF &lt;&lt; 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stopAndrealseCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mECodec != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mECodec.release();</span><br><span class="line">            mECodec = <span class="keyword">null</span>;</span><br><span class="line">            mExtractor.release();</span><br><span class="line">            mExtractor = <span class="keyword">null</span>;</span><br><span class="line">            Log.d(tag, <span class="string">"outputBuffer BUFFER_FLAG_END_OF_STREAM"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Log.d(tag, <span class="string">"stopAndrealseCodec"</span>);</span><br><span class="line">            Log.d(tag, <span class="string">"inputSize="</span> + inputSize);</span><br><span class="line">            Log.d(tag, <span class="string">"outputSize="</span> + outputSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码见 <a href="https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7" target="_blank" rel="noopener">https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/Task7</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android 音视频任务4</title>
    <url>/2020/04/10/Android/Android%20%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A14/</url>
    <content><![CDATA[<p>任务4. 学习 Android 平台的 MediaExtractor 和 MediaMuxer API，知道如何解析和封装 mp4 文件</p>
<ul>
<li>MediaMuxer和MediaCodec算是比较年轻的，它们是JB 4.1和JB 4.3才引入的。前者用于将音频和视频进行混合生成多媒体文件。缺点是目前只能支持一个audio track和一个video track，目前支持mp4,3gp,webm输出</li>
<li>MediaCodec用于将音视频进行压缩编码，它有个比较牛X的地方是可以对Surface内容进行编码，如KK 4.4中屏幕录像功能就是用它实现的。</li>
<li>MediaFormat用于描述多媒体数据的格式。</li>
<li>MediaRecorder用于录像+压缩编码，生成编码好的文件如mp4, 3gpp，视频主要是用于录制Camera preview。</li>
<li>MediaPlayer用于播放压缩编码后的音视频文件。</li>
<li>AudioRecord用于录制PCM数据。</li>
<li>AudioTrack用于播放PCM数据。PCM即原始音频采样数据，可以用如vlc播放器播放。</li>
</ul>
<p>MediaExtractor可以从数据源中提取解复用的，编码后的媒体数据。MediaExtractor用于音视频分路,比如从一个视频中分别提取音频(音轨)和视频(视频轨)<br>它既可以从视频里提取视频轨或音频轨，也可以单从音频里提取音频轨</p>
<p>//如下使用`</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediaExtractor extractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line"> extractor.setDataSource(…);</span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line"> <span class="keyword">int</span> numTracks = extractor.getTrackCount(); <span class="comment">//当前视频中有几个轨道</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numTracks; ++i) &#123;</span><br><span class="line">   MediaFormat format = extractor.getTrackFormat(i);</span><br><span class="line">   String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">   <span class="keyword">boolean</span> isVideoTrack = mime.startsWith(<span class="string">"video/“); //当前是不是视频轨，视频轨的MIME以”video/“开头，音频轨的MIME以“audio/”开头</span></span><br><span class="line"><span class="string">   if (isVideoTrack) &#123;</span></span><br><span class="line"><span class="string">     extractor.selectTrack(i);   //选择视轨,当确定感兴趣的轨道时，一定要选取！</span></span><br><span class="line"><span class="string">     int index = mediaMuxer.addTrack(format) //如果要进行这个视轨的合成合成器除了需要数据，也需要mediaMuxer需要设置当前视轨的format，在写入的时候也需要视轨的index</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> ByteBuffer inputBuffer = ByteBuffer.allocate(…)  //这个容量必须大一点，否则下面readSampleData会崩，实测是1000*1024可以</span></span><br><span class="line"><span class="string">//下面readSampleData会自动更新buffer的limit和postion，就和read，write一样</span></span><br><span class="line"><span class="string"> while (extractor.readSampleData(inputBuffer, ...) &gt;= 0) &#123;</span></span><br><span class="line"><span class="string">   int trackIndex = extractor.getSampleTrackIndex();</span></span><br><span class="line"><span class="string">   long presentationTimeUs = extractor.getSampleTime();</span></span><br><span class="line"><span class="string">   ...</span></span><br><span class="line"><span class="string">   extractor.advance(); //前进到下一个样本(下一个视频帧或音频帧)；readSampleData看起来不会自动更新读过的数据所以需要这个</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> extractor.release();</span></span><br><span class="line"><span class="string"> extractor = null;</span></span><br></pre></td></tr></table></figure>

<p>MediaMuxer可以复用基本流。 目前MediaMuxer支持MP4，Webm和3GP文件作为输出。 它还支持自Android Nougat以来在MP4中复用B帧。是extractor的反作用类型，用于把视频轨和音频轨进行合成,和MediaExtractor正好是反过程。<br>不支持mp3，wav音频源（AAC支持）<br>只能支持一个audio track和一个video track，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如下使用</span></span><br><span class="line">MediaMuxer muxer = <span class="keyword">new</span> MediaMuxer(<span class="string">"temp.mp4"</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line">mediaMuxer.setOrientationHint(<span class="number">90</span>); <span class="comment">//设置混合后视频的旋转角度</span></span><br><span class="line"> <span class="comment">// More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat()</span></span><br><span class="line"> <span class="comment">// or MediaExtractor.getTrackFormat().</span></span><br><span class="line"> MediaFormat audioFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"> MediaFormat videoFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"> <span class="keyword">int</span> audioTrackIndex = muxer.addTrack(audioFormat); <span class="comment">//返回的是混合器里的轨道号，也就是新文件里的轨道号</span></span><br><span class="line"> <span class="keyword">int</span> videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line"> ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize);</span><br><span class="line"> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"> BufferInfo bufferInfo = <span class="keyword">new</span> BufferInfo();</span><br><span class="line"></span><br><span class="line"> muxer.start(); <span class="comment">//开始混合</span></span><br><span class="line"> <span class="keyword">while</span>(!finished) &#123;</span><br><span class="line">   <span class="comment">// getInputBuffer() will fill the inputBuffer with one frame of encoded</span></span><br><span class="line">   <span class="comment">/* sample from either MediaCodec or MediaExtractor, set isAudioSample to true when the sample is audio data, set up all the fields of bufferInfo,and return true if there are no more samples.*/</span></span><br><span class="line">   finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo);</span><br><span class="line">   <span class="keyword">if</span> (!finished) &#123;</span><br><span class="line">     <span class="keyword">int</span> currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bufferInfo.presentationTimeUs = extractor.getSampleTime(); //直接从extractor获取</span></span><br><span class="line"><span class="comment">bufferInfo.offset = 0;  //如果没有特殊需求一般是0</span></span><br><span class="line"><span class="comment">bufferInfo.flags = extractor.getSampleFlags();</span></span><br><span class="line"><span class="comment">bufferInfo.size = size;  //本次写入的数据量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo); <span class="comment">//每次写入数据都要同时写入index和info，info要明确如上面几点，注意这里的index是新合成的视频的相应轨道，应该是由addTrack返回的值</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> muxer.stop();</span><br><span class="line"> muxer.release();</span><br></pre></td></tr></table></figure>

<p>元数据跟踪<br>每帧元数据用于携带与视频或音频相关的额外信息以便于离线处理，例如，来自传感器的陀螺仪信号可以在进行离线处理时帮助稳定视频。仅在MP4容器中支持元数据跟踪。添加新元数据轨道时，轨道的mime格式必须以前缀“application /”开头，例如“application/gyro”。元数据的格式/布局将由应用程序定义。写入元数据与编写视频/音频数据几乎相同，只是数据不会来自mediacodec。应用程序只需要将包含元数据的字节缓冲区以及相关的时间戳传递给writeSampleData（int，ByteBuffer，MediaCodec.BufferInfo）api。时间戳必须与视频和音频的时间基准相同。生成的MP4文件使用ISOBMFF的第12.3.3.2节中定义的TextMetaDataSampleEntry来表示元数据的mime格式。当使用MediaExtractor提取具有元数据轨道的文件时，元数据的mime格式将被提取到MediaFormat中。<br>//如下例，把陀螺仪信息也传给生成的MP4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediaMuxer muxer = <span class="keyword">new</span> MediaMuxer(<span class="string">"temp.mp4"</span>, OutputFormat.MUXER_OUTPUT_MPEG_4);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SetUp Video/Audio Tracks.</span></span><br><span class="line"></span><br><span class="line">   MediaFormat audioFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   MediaFormat videoFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> audioTrackIndex = muxer.addTrack(audioFormat);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> videoTrackIndex = muxer.addTrack(videoFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Setup Metadata Track</span></span><br><span class="line"></span><br><span class="line">   MediaFormat metadataFormat = <span class="keyword">new</span> MediaFormat(...);</span><br><span class="line"></span><br><span class="line">   metadataFormat.setString(KEY_MIME, <span class="string">"application/gyro"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> metadataTrackIndex = muxer.addTrack(metadataFormat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   muxer.start();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(..) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Allocate bytebuffer and write gyro data(x,y,z) into it.</span></span><br><span class="line"></span><br><span class="line">       ByteBuffer metaData = ByteBuffer.allocate(bufferSize);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(x);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(y);</span><br><span class="line"></span><br><span class="line">       metaData.putFloat(z);</span><br><span class="line"></span><br><span class="line">       BufferInfo metaInfo = <span class="keyword">new</span> BufferInfo();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Associate this metadata with the video frame by setting</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// the same timestamp as the video frame.</span></span><br><span class="line"></span><br><span class="line">       metaInfo.presentationTimeUs = currentVideoTrackTimeUs;</span><br><span class="line"></span><br><span class="line">       metaInfo.offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       metaInfo.flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       metaInfo.size = bufferSize;</span><br><span class="line"></span><br><span class="line">       muxer.writeSampleData(metadataTrackIndex, metaData, metaInfo);</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   muxer.stop();</span><br><span class="line"></span><br><span class="line">   muxer.release();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>MediaCodec类可用于访问低级媒体编解码器，即编码器/解码器组件。 它是Android低级多媒体支持基础架构的一部分（通常与MediaExtractor，MediaSync，MediaMuxer，MediaCrypto，MediaDrm，Image，Surface和AudioTrack一起使用。）</p>
<p>从广义上讲，编解码器处理输入数据以生成输出数据。它异步处理数据并使用一组输入和输出缓冲区。在简单的级别，您请求（或接收）一个空的输入缓冲区，用数据填充它并将其发送到编解码器进行处理。编解码器使用数据并将其转换到它的空输出缓冲区之一。最后，您请求（或接收）到一个填充了数据的输出缓冲区，使用其内容并将其释放回编解码器。</p>
<p>数据类型<br>编解码器对三种数据进行操作：压缩数据，原始音频数据和原始视频数据。可以使用ByteBuffers处理所有三种数据，但是您应该使用Surface for raw视频数据来提高编解码器性能。 Surface使用本机视频缓冲区而不映射或将它们复制到ByteBuffers;因此，效率更高。使用Surface时通常无法访问原始视频数据，但您可以使用ImageReader类访问不安全的解码（原始）视频帧。这可能仍然比使用ByteBuffers更有效，因为一些本机缓冲区可能会映射到直接ByteBuffers。使用ByteBuffer模式时，可以使用Image类和getInput / OutputImage（int）访问原始视频帧。</p>
<p>原始音频缓冲区<br>原始音频缓冲区包含整个PCM音频数据帧，这是通道顺序中每个通道的一个样本。 每个样本都是本机字节顺序的16位有符号整数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">short</span>[] getSamplesForChannel(MediaCodec codec, <span class="keyword">int</span> bufferId, <span class="keyword">int</span> channelIx) &#123;</span><br><span class="line"></span><br><span class="line">  ByteBuffer outputBuffer = codec.getOutputBuffer(bufferId);</span><br><span class="line"></span><br><span class="line">  MediaFormat format = codec.getOutputFormat(bufferId);</span><br><span class="line"></span><br><span class="line">  ShortBuffer samples = outputBuffer.order(ByteOrder.nativeOrder()).asShortBuffer();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> numChannels = formet.getInteger(MediaFormat.KEY_CHANNEL_COUNT);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (channelIx &lt; <span class="number">0</span> || channelIx &gt;= numChannels) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">short</span>[] res = <span class="keyword">new</span> <span class="keyword">short</span>[samples.remaining() / numChannels];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; ++i) &#123;</span><br><span class="line"></span><br><span class="line">    res[i] = samples.get(i * numChannels + channelIx);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line"><span class="comment">//音频抽取后的format信息</span></span><br><span class="line"><span class="number">0</span> = &#123;HashMap$HashMapEntry@4594&#125; <span class="string">"mime"</span> -&gt; <span class="string">"audio/mp4a-latm"</span></span><br><span class="line"><span class="number">1</span> = &#123;HashMap$HashMapEntry@4595&#125; <span class="string">"aac-profile"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">2</span> = &#123;HashMap$HashMapEntry@4596&#125; <span class="string">"channel-count"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span> = &#123;HashMap$HashMapEntry@4597&#125; <span class="string">"track-id"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">4</span> = &#123;HashMap$HashMapEntry@4598&#125; <span class="string">"durationUs"</span> -&gt; <span class="string">"192911760"</span></span><br><span class="line"><span class="number">5</span> = &#123;HashMap$HashMapEntry@4599&#125; <span class="string">"csd-0"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=2 cap=2]"</span></span><br><span class="line"><span class="number">6</span> = &#123;HashMap$HashMapEntry@4600&#125; <span class="string">"sample-rate"</span> -&gt; <span class="string">"44100"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//视频抽取后的format信息</span></span><br><span class="line"><span class="number">0</span> = &#123;HashMap$HashMapEntry@4620&#125; <span class="string">"csd-1"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=8 cap=8]"</span></span><br><span class="line"><span class="number">1</span> = &#123;HashMap$HashMapEntry@4621&#125; <span class="string">"rotation-degrees"</span> -&gt; <span class="string">"90"</span></span><br><span class="line"><span class="number">2</span> = &#123;HashMap$HashMapEntry@4622&#125; <span class="string">"track-id"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span> = &#123;HashMap$HashMapEntry@4623&#125; <span class="string">"height"</span> -&gt; <span class="string">"1200"</span></span><br><span class="line"><span class="number">4</span> = &#123;HashMap$HashMapEntry@4624&#125; <span class="string">"profile"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">5</span> = &#123;HashMap$HashMapEntry@4625&#125; <span class="string">"color-standard"</span> -&gt; <span class="string">"1"</span></span><br><span class="line"><span class="number">6</span> = &#123;HashMap$HashMapEntry@4626&#125; <span class="string">"durationUs"</span> -&gt; <span class="string">"2157877"</span></span><br><span class="line"><span class="number">7</span> = &#123;HashMap$HashMapEntry@4627&#125; <span class="string">"color-transfer"</span> -&gt; <span class="string">"3"</span></span><br><span class="line"><span class="number">8</span> = &#123;HashMap$HashMapEntry@4628&#125; <span class="string">"mime"</span> -&gt; <span class="string">"video/avc"</span></span><br><span class="line"><span class="number">9</span> = &#123;HashMap$HashMapEntry@4629&#125; <span class="string">"frame-rate"</span> -&gt; <span class="string">"30"</span></span><br><span class="line"><span class="number">10</span> = &#123;HashMap$HashMapEntry@4630&#125; <span class="string">"width"</span> -&gt; <span class="string">"1600"</span></span><br><span class="line"><span class="number">11</span> = &#123;HashMap$HashMapEntry@4631&#125; <span class="string">"color-range"</span> -&gt; <span class="string">"2"</span></span><br><span class="line"><span class="number">12</span> = &#123;HashMap$HashMapEntry@4632&#125; <span class="string">"max-input-size"</span> -&gt; <span class="string">"123106"</span></span><br><span class="line"><span class="number">13</span> = &#123;HashMap$HashMapEntry@4633&#125; <span class="string">"csd-0"</span> -&gt; <span class="string">"java.nio.HeapByteBuffer[pos=0 lim=21 cap=21]"</span></span><br><span class="line"><span class="number">14</span> = &#123;HashMap$HashMapEntry@4634&#125; <span class="string">"level"</span> -&gt; <span class="string">"2048"</span></span><br></pre></td></tr></table></figure>
<p>这里要注意的是，要分清楚原视频中的视/音轨号和新合成的视频中的视/音轨号，一般来说前者是为了让extractor选中相应的轨道，而后者是在合成视频写数据的时候需要。这里犯了一个错就是提取视频轨的时候，视频轨在视频中的轨道号是0，提取音频帧时，音轨在音频中的轨道号也是0，实际给muxer添加轨道的时候，视轨被添加到了新视频的轨道0，音轨被添加到了新视频的轨道1。但写音频数据的时候仍往0号轨道写，就崩掉了报错：stop muxer failed</p>
<p>具体工程代码见 <a href="https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/task4" target="_blank" rel="noopener">https://github.com/lujianyun06/VATask/tree/master/app/src/main/java/com/example/lll/va/task4</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android如何替换原生应用</title>
    <url>/2020/04/10/Android/Android%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>有个需求是把原生的日历app换成修改源码后编译生成的新app<br>尝试进入adb，须有root权限（完整的root权限）<br>用以下代码删除原生的calendar</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb shell</span><br><span class="line">su</span><br><span class="line">pm uninstall -k --user 0 com.android.calendar</span><br></pre></td></tr></table></figure>

<p>然后要把/system挂载成可读写的（rw，一开始是只读的ro）<br>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount</span></span><br></pre></td></tr></table></figure>
<p>可以发现/system是只读的 ro<br>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">mount -o rw,remount /system</span><br><span class="line">mount</span><br></pre></td></tr></table></figure>
<p>可以看到/system 是可读写的：rw<br>此时退出adb shell，把已经编译好的新的日历apk push进手机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adb push ~/newapk/Calendar.apk /system/app/Calendar</span><br><span class="line">adb shell   </span><br><span class="line">reboot   //重启手机</span><br></pre></td></tr></table></figure>
<p>此时就可以使用改后的calendar了<br>————————————————<br>版权声明：本文为CSDN博主「TheRockMaster」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_43752854/article/details/84647709" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43752854/article/details/84647709</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>onMeasure()和onLayout()总结</title>
    <url>/2020/04/10/Android/onMeasure()%E5%92%8ConLayout()%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>转载自 <a href="https://www.cnblogs.com/xqxacm/p/6673469.html" target="_blank" rel="noopener">https://www.cnblogs.com/xqxacm/p/6673469.html</a><br>和 <a href="https://blog.csdn.net/superxukai88/article/details/78675686" target="_blank" rel="noopener">https://blog.csdn.net/superxukai88/article/details/78675686</a></p>
<p>并写了一些自己的总结<br>前言：<br>　　自定义控件的三大方法：</p>
<ol>
<li>测量： onMeasure()：  测量自己的大小，为正式布局提供建议 </li>
<li>布局： onLayout():   使用layout()函数对所有子控件布局</li>
<li>绘制： onDraw():     根据布局的位置绘图 </li>
</ol>
<p>onDraw() 里面是绘制的操作，可以看下其他的文章，下面来了解 onMeasure()和onLayout()方法。</p>
<h1 id="一、onMeasure-、测量"><a href="#一、onMeasure-、测量" class="headerlink" title="一、onMeasure()、测量"></a>一、onMeasure()、测量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span></span></span><br></pre></td></tr></table></figure>
<p>参数即父类传过来的两个宽高的”建议值”，即把当前view的高设置为：heightMeasureSpec ;宽设置为：widthMeasureSpec<br>这个参数不是简单的整数类型，而是2位整数(模式类型)和30位整数(实际数值) 的组合</p>
<p>其中模式分为三种:</p>
<p>①、UNSPECIFIED(未指定)，父元素不对自元素施加任何束缚，子元素可以得到任意想要的大小；UNSPECIFIED=00000000000000000000000000000000</p>
<p>②、EXACTLY(完全)，父元素决定自元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；EXACTLY =01000000000000000000000000000000<br>③、AT_MOST(至多)，子元素至多达到指定大小的值。 他们对应的二进制值分别是： AT_MOST =10000000000000000000000000000000 </p>
<p>最前面两位代表模式，分别对应十进制的0，1，2；</p>
<p>获取模式int值 和 获取数值int值的方法：</p>
<blockquote>
<ol>
<li>int measureWidth = MeasureSpec.getSize(widthMeasureSpec);  </li>
<li>int measureHeight = MeasureSpec.getSize(heightMeasureSpec);  </li>
<li>int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);  </li>
<li>int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);<br>模式的值有：<br>MeasureSpec.AT_MOST       = 2<br>MeasureSpec.EXACTLY       = 1<br>MeasureSpec.UNSPECIFIED   = 0</li>
</ol>
</blockquote>
<p>上面我们知道了 onMeasure(int widthMeasureSpec, int heightMeasureSpec) 方法参数的意义<br>下面了解参数对应的三个模式分别对应的意义：<br>每一个模式都对应的xml布局中的一个值<br>wrap_content — MeasureSpec.AT_MOST<br>match_parent — MeasureSpec.EXACTLY<br>具体值 — MeasureSpec.UNSPECIFIED</p>
<p>注意：<br>—当模式是MeasureSpec.AT_MOST时，即wrap_content时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上就是父亲建议的尺寸数值,（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议.</p>
<p>PS: 但需要注意的是，如果直接自定义一个View，宽高为wrap_content, 则最后绘制的时候view是占满整个父View的(假设父view只有这一个儿子)，这是因为上面说的，传过来的是父亲的尺寸，但如果自定义View继承了像TextView之类的，最后还调用了super.onMeasure，则显示的时候大小是根据其内容显示的，这是因为这些TextView在自己的onMeasure里又做了处理，使得其根据内容的大小而变化。</p>
<p>—当模式是MeasureSpec.EXACTLY时，即match_parent时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际上也是父亲建议的尺寸数值（如果父亲只有一个子view，数值就是父亲自己的尺寸，多个子view的LinearLayout传递的值是安置完之前的子view剩下的空间尺寸），因此在onMeasure里不做其他操作，view仍然会符合父亲的建议</p>
<p>PS:（AT_MOST与EXACTLY：如果在onMeasure中不做任何处理而调用setMeasureDimension(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.getSize(heightMeasureSpec))）来设置尺寸，，或者在基类的onMeasure中不做任何额外处理而调用super.onMeasure().那么这两个模式没有任何区别（都是用父亲建议的大小设置自己的大小，而且两个模式父亲建议的大小都一样）。因此若使用AT_MOST一般都要在onMeasure中根据mode不同而设置view尺寸为不同的大小（如同TextView做的那样）</p>
<p>—当模式是MeasureSpec.UNSPECIFIED时，即具体数值时，此时传入的int widthMeasureSpec, int heightMeasureSpec的数值部分(后30位)实际是具体指定的数字，因此在onMeasure里不做其他操作，子view会符合父亲的建议，即变成它自己设定的尺寸，尽管这里的数字大小是不做限制的，但当绘制的时候，父亲会clip掉自己尺寸之外的子view的部分。要避免的话，需设置子view的顶级祖先ViewGroup的clipChildren属性为false，而且它的父亲必须不是RelativeLayout（即不clip有两个条件，1.顶级祖先view设置clipChildren=false。2.父view必须不是RelativeLayout，PS：父view设置不设置clipChildren无所谓，顶级祖先必须设置）</p>
<h1 id="二、onLayout-、-布局"><a href="#二、onLayout-、-布局" class="headerlink" title="二、onLayout() 、 布局"></a>二、onLayout() 、 布局</h1><p>onLayout方法是ViewGroup中子View的布局方法，用于放置子View的位置。放置子View很简单，只需在重写onLayout方法，然后获取子View的实例，调用子View的layout方法实现布局。在实际开发中，一般要配合onMeasure测量方法一起使用。</p>
<h2 id="onLayout方法："><a href="#onLayout方法：" class="headerlink" title="onLayout方法："></a>onLayout方法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span>  <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该方法在ViewGroup中定义是抽象函数，继承该类必须实现onLayout方法，而ViewGroup的onMeasure并非必须重写的。View的放置都是根据一个矩形空间放置的，onLayout传下来的l,t,r,b分别是放置父控件的矩形可用空间（除去margin和padding的空间）的左上角的left、top以及右下角right、bottom值。</p>
<h2 id="layout方法："><a href="#layout方法：" class="headerlink" title="layout方法："></a>layout方法：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法是View的放置方法，在View类实现。调用该方法需要传入放置View的矩形空间左上角left、top值和右下角right、bottom值。这四个值是相对于父控件而言的。例如传入的是（10, 10, 100, 100），则该View在距离父控件的左上角位置(10, 10)处显示，显示的大小是宽高是90(参数r,b是相对左上角的)，这有点像绝对布局。</p>
<p>平常开发所用到RelativeLayout、LinearLayout、FrameLayout…这些都是继承ViewGroup的布局。这些布局的实现都是通过都实现ViewGroup的onLayout方法，只是实现方法不一样而已。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>理解YUV</title>
    <url>/2020/04/10/Android/%E7%90%86%E8%A7%A3YUV/</url>
    <content><![CDATA[<p>先贴一个好贴：<a href="https://www.cnblogs.com/ALittleDust/p/5935983.html" target="_blank" rel="noopener">https://www.cnblogs.com/ALittleDust/p/5935983.html</a></p>
<p>YUV</p>
<p>YUV是一种颜色空间，基于YUV的颜色编码是流媒体的常用编码方式。Y表示流明，U、V表示色度、浓度，这种表达方式起初是为了彩色电视与黑白电视之间的信号兼容。 对于图像每一点，Y确定其亮度，UV确认其彩度。<br>Y’CbCr也称为YUV，是YUV的压缩版本，不同之处在于Y’CbCr用于数字图像领域，YUV用于模拟信号领域，MPEG、DVD、摄像机中常说的YUV其实是Y’CbCr，二者转换为RGBA的转换矩阵是不同的。Y’为亮度，Cb、Cr分量代表当前颜色对蓝色和红色的偏移程度。<br><img src="https://img-blog.csdnimg.cn/20181205185454660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Y’=0.5时，Cb、Cr构成的颜色平面<br>如果输出Y’CbCr三个分量的值，那么会是这样的。<br><img src="https://img-blog.csdnimg.cn/2018120518554167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由上到下依次为Y’、Cb、Cr<br>为了方便，以下文中YUV特指Y’CbCr。<br>YUV颜色编码的作用</p>
<p>YUV编码是image/video pipeline的重要组成。比如常用的I420相对于RGB24（RGB三个分量各8个字节）的编码格式，只需要一半的存储容量。在流数据传输时降低了带宽压力。<br><img src="https://img-blog.csdnimg.cn/20181205185556564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>YUV颜色编码在video pipeline中的运用<br>YUV颜色编码格式</p>
<p>YUV色彩编码格式由其色度抽样方式和存储方式决定。<br>YUV 采样</p>
<p>对光信号采样是把光由模拟信号变为数字信号，这不是我们要做的事，我们要做的是把射线透照产生的模拟图像变为数字图像，两者不是一码事。所以不应该对光信号谈采样定理。<br>对图像的采样，是把模拟图像变成数字图像，描述模拟图像的是连续的信息，但要把它变成离散的信息，<br>YUV采样<br>YUV的一个优点是色度通道可以具有比Y通道更低的采样率而不会显着降低感知质量。 称为A：B：C表示法的符号用于描述U和V相对于Y的采样频率：</p>
<ul>
<li>4：4：4表示没有色度通道的下采样。</li>
<li>4：2：2表示2：1水平下采样，没有垂直下采样。 对于每两个U或V样本，每条扫描线包含四个Y样本。</li>
<li>4：2：0表示2：1水平下采样，2：1垂直下采样。</li>
<li>4：1：1表示4：1水平下采样，没有垂直下采样。 每个扫描线包含每个U或V样本的四个Y样本。 4：1：1采样不如其他格式常见，本文不再详细讨论。<br>图1显示了4：4：4图片中使用的采样网格。 Luma样本由十字表示，色度样本由圆表示。<br>Figure 1 展示了 4:4:4 格式的图片所用的采样网格. Luma samples are represented by a cross, and chroma samples are represented by a circle.（亮度信息是X，色度信息是O）<br><img src="https://img-blog.csdnimg.cn/20181205185613326.png" alt="在这里插入图片描述"><br>Figure 1. YUV 4:4:4 sample positions<br>4：2：2采样的主要形式在ITU-R建议书BT.601中定义。 Figure 2 shows the sampling grid defined by this standard.<br><img src="https://img-blog.csdnimg.cn/20181205185626707.png" alt="在这里插入图片描述"><br>Figure 2. YUV 4:2:2 sample positions<br>有两种常见的4：2：0采样变体。 其中一个用于MPEG-2视频，另一个用于MPEG-1和ITU-T建议H.261和H.263。 图3显示了MPEG-1方案中使用的采样网格，图4显示了MPEG-2方案中使用的采样网格。（视频使用的采样网格，就是视频中每一帧(一张图片)的采样网格）<br><img src="https://img-blog.csdnimg.cn/20181205185635494.png" alt="在这里插入图片描述"><br>Figure 3. YUV 4:2:0 sample positions (MPEG-1 scheme)<br><img src="https://img-blog.csdnimg.cn/20181205185646205.png" alt="在这里插入图片描述"><br>Figure 4. YUV 4:2:0 sample positions (MPEG-2 scheme)<br>与MPEG-1方案相比，在MPEG-2方案和为4：2：2和4：4：4格式定义的采样网格之间进行转换更为简单。 因此，MPEG-2方案在Windows中是首选，应被视为4：2：0格式的默认解释。<br>先记住下面这段话，以后提取每个像素的YUV分量会用到。<br>（每一个像素对应一个Y）</li>
</ul>
<ol>
<li>YUV 4:4:4采样，每一个Y对应一组UV分量。（每个像素对应一组UV）</li>
<li>YUV 4:2:2采样，每两个Y共用一组UV分量。 （两个像素共用一组UV）</li>
<li>YUV 4:2:0采样，每四个Y共用一组UV分量(专指12bit/pixel的格式)。（四个像素共用一组UV）<br>4:2:0采样还有每四个Y共用2组UV分量（为16bit[pixel的格式）<br>YUV存储方式</li>
</ol>
<p>宏像素(macropixel)：一组包含了若干个亮度，色度（可能还有透明度）的数据组。有可能一个像素对应一个宏像素，也有可能几个像素共用一个宏像素</p>
<p>YUV存储像素信息有两种格式：<br>packed：Y,U,V的信息存储在同一个存储平面中（或者其中的两个存储在同一数组中），像素被组织成一组宏像素，，布局取决于格式<br>planar：Y,U,V 被存储为3个不同平面里<br>简而言之：packed就是宏像素混合存储，planar就是每种宏像素分开存储</p>
<p>存储平面（surface）：一个抽象的平面表示了像素存储的方式，其中的单位是一个宏像素<br>原点：屏幕左上角<br>步幅stride：存储平面的宽度，始终为正<br>对齐：surface字对齐<br>4:4:4 格式, 32 Bits per Pixel</p>
<p>单个4：4：4格式，使用FOURCC代码AYUV。  这是一种打包格式，其中每个像素被编码为四个连续字节，按以下顺序排列。（每个像素对应一个宏像素，如像素p0对应宏像素 V0U0Y0A0）</p>
<p><img src="https://img-blog.csdnimg.cn/20181205185702662.png" alt="在这里插入图片描述"><br>Figure 5. AYUV memory layout<br>标为A的字节代表透明度<br>4:2:2 Formats, 16 Bits per Pixel<br>两种 4:2:2 格式, 编码方式如下:</p>
<ul>
<li>YUY2</li>
<li>UYVY<br>都是packed格式, 其中每个宏像素用于两个像素，编码为四个连续的字节。 这导致色度的水平下采样两倍。<br>YUY2</li>
</ul>
<p>在YUY2格式中，数据可以被视为无符号字符值的数组，其中第一个字节包含第一个Y样本，第二个字节包含第一个U（Cb）样本，第三个字节包含第二个Y样本，以及 第四个字节包含第一个V（Cr）样本，如图6（每两个像素对应一个宏像素，如像素p0，p1对应宏像素 Y0U0Y1V0, 第一个像素的显示信息为Y0U0V0，第二个像素的显示信息为Y1U0V0。相当于32个bit存储了2像素的信息，就叫做每个像素16bit，但实际上每个像素的完整信息仍需要12bit，只是其中8bit与另一个共用）</p>
<p><img src="https://img-blog.csdnimg.cn/20181205185723582.png" alt="在这里插入图片描述">Figure 6. YUY2 memory layout<br>如果图像被放置为两个小端WORD值的数组，则第一个WORD在最低有效位（LSB）中包含Y0，在最高有效位（MSB）中包含U. 第二个WORD在LSB中包含Y1，在MSB中包含V.<br>YUY2是MicrosoftDirectX®视频加速（DirectX VA）的首选4：2：2像素格式。 预计这将是支持4：2：2视频的DirectX VA加速器的中期要求。<br>UYVY<br>这种格式与YUY2相同，只是字节顺序颠倒了 - 也就是说，色度和亮度字节被翻转（图7）。 如果图像被寻址为两个小端WORD值的数组，则第一个WORD在LSB中包含U，在MSB中包含Y0，第二个WORD在LSB中包含V，在MSB中包含Y1。（每两个像素对应一个宏像素，如像素p0，p1对应宏像素 Y0U0Y1V0, 第一个像素的显示信息为Y0U0V0，第二个像素的显示信息为Y1U0V0）<br><img src="https://img-blog.csdnimg.cn/20181205185734628.png" alt="在这里插入图片描述"><br>Figure 7. UYVY memory layout<br>4:2:0 Formats, 16 Bits per Pixel</p>
<p>两种4：2：0 格式，16位/像素，编码方式如下：</p>
<ul>
<li>IMC1</li>
<li>IMC3<br>这两种都是planar格式. 色度通道在水平和垂直维度上次采样系数为2<br>IMC1<br>所有的Y首先在内存中存储， 就像一个无符号 char 值类型的数组. 紧接着是 V (Cr) 样本, 然后是U (Cb) 样本.  V 和 U 平面的宽度和Y平面的宽度一样, 所以会导致一些没有用到的内存, 如图8. （4个像素对应一个宏像素,  p0,p1,p2,p3对应 Y0Y1Y2Y3V0V1U0U1，p0的显示信息为Y0V0U0，p1的显示信息为Y1V0U0，p2的显示信息为Y2V1U1，p3的显示信息为Y3V1U1，U,V可能不是这么安排的。每个像素对应一个Y，对应一种U,V的组合，4个像素分别用各自的亮度信息，共用4个色度信息，平均每个像素使用16bit）<br><img src="https://img-blog.csdnimg.cn/20181205185744370.png" alt="在这里插入图片描述"><br>Figure 8. IMC1 memory layout<br>IMC3</li>
</ul>
<p>此格式与IMC1相同，但U和V平面交换次序：<br><img src="https://img-blog.csdnimg.cn/20181205185751494.png" alt="在这里插入图片描述"><br>Figure 9. IMC3 memory layout<br>4:2:0 Formats, 12 Bits per Pixel</p>
<p>4种 4:2:0 12bit/pixel 格式 ，存储方式如下（4个像素用4个Y，1个U,一个V）</p>
<ul>
<li>IMC2</li>
<li>IMC4</li>
<li>YV12</li>
<li>NV12<br>在这些所有格式中，色度通道在水平和垂直维度上次采样系数为2</li>
</ul>
<p>IMC2<br>该格式与IMC1相同，除了V（Cr）和U（Cb）线在半步边界处交错。 换句话说，色度区域中的每个全步幅线以一行V样本开始，接着从下一个半步幅边界开始是一行U样本，（图10）。 这种布局比IMC1更有效地使用地址空间。 它将色度地址空间减半，因此总地址空间减少了25％。 在4：2：0格式中，IMC2是仅次于NV12的第二好的格式。<br><img src="https://img-blog.csdnimg.cn/20181205185802914.png" alt="在这里插入图片描述"><br>Figure 10. IMC2 memory layout<br>IMC4</p>
<p>此格式与IMC2相同，但U（Cb）和V（Cr）行交换：<br><img src="https://img-blog.csdnimg.cn/20181205185821899.png" alt="在这里插入图片描述"><br>Figure 11. IMC4 memory layout<br>YV12</p>
<p>所有Y样本首先在内存中显示为无符号char值的数组。 该阵列紧接着是所有V（Cr）样本。 V平面的步幅是Y平面的一半，V平面包含Y平面一半的行数。 紧接着V平面的所有U（Cb）样本，具有与V平面相同的步幅和行数（图12）。<br><img src="https://img-blog.csdnimg.cn/20181205185833455.png" alt="在这里插入图片描述"><br>Figure 12. YV12 memory layout<br>NV12</p>
<p>所有Y样本首先在内存中存储，Y平面是无符号char值的数组，共有偶数行。 Y平面后面紧跟着一个无符号字符值数组，其中包含打包的U（Cb）和V（Cr）样本，如图13所示。当组合的UV数组作为小端WORD值的数组进行寻址时， LSB包含U值，MSB包含V值。 NV12是DirectX VA的首选4：2：0像素格式。 预计这将是支持4：2：0视频的DirectX VA加速器的中期要求。<br><img src="https://img-blog.csdnimg.cn/20181205185840535.png" alt="在这里插入图片描述"><br>Figure 13. NV12 memory layout<br>I420多用于传输</p>
<p>摄像头采集得到的数据是NV12<br><img src="https://img-blog.csdnimg.cn/20181205185850444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>音视频任务1</title>
    <url>/2020/04/10/Android/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BB%BB%E5%8A%A11/</url>
    <content><![CDATA[<p>跟着大神的步骤一步一步做，加油！<br>任务列表：<a href="http://blog.51cto.com/ticktick/1956269" target="_blank" rel="noopener">http://blog.51cto.com/ticktick/1956269</a></p>
<p>在 Android 平台绘制一张图片，使用至少 3 种不同的 API，ImageView，SurfaceView，自定义 View<br>imageView和surfaceView，为了方便都是直接在activity里面写的函数，直接在onCreateView里面调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.res.Resources;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Bitmap;</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Canvas;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Matrix;</span><br><span class="line"><span class="keyword">import</span> android.graphics.Rect;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.BitmapDrawable;</span><br><span class="line"><span class="keyword">import</span> android.graphics.drawable.Drawable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceHolder;</span><br><span class="line"><span class="keyword">import</span> android.view.SurfaceView;</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        displaySurfaceView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displayImg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ImageView iv = findViewById(R.id.iv_lu);</span><br><span class="line">        <span class="comment">//1</span></span><br><span class="line"><span class="comment">//        iv.setImageResource(R.mipmap.wechatimg1);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2</span></span><br><span class="line"><span class="comment">//        Drawable drawable = getResources().getDrawable(R.mipmap.wechatimg1, null);</span></span><br><span class="line"><span class="comment">//        iv.setImageDrawable(drawable);</span></span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.wechatimg1);</span><br><span class="line">        iv.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">displaySurfaceView</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SurfaceView sv = findViewById(com.example.lujianyun.va.R.id.sv_lu);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SurfaceHolder holder = sv.getHolder();</span><br><span class="line">        <span class="keyword">final</span> Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Canvas canvas = holder.lockCanvas();</span><br><span class="line">                Bitmap bitmap = BitmapFactory.decodeResource(getResources(), com.example.lujianyun.va.R.mipmap.wechatimg1);</span><br><span class="line">                canvas.drawBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">                holder.unlockCanvasAndPost(canvas);</span><br><span class="line">                holder.lockCanvas(<span class="keyword">new</span> Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">                holder.unlockCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        holder.addCallback(<span class="keyword">new</span> SurfaceHolder.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceCreated</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line">                t.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceChanged</span><span class="params">(SurfaceHolder holder, <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">surfaceDestroyed</span><span class="params">(SurfaceHolder holder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义view</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String TAG = <span class="string">"DrawView"</span>;</span><br><span class="line">    Bitmap bitmap;</span><br><span class="line">    Bitmap orginBitmap;</span><br><span class="line">    <span class="keyword">boolean</span> bitmapFinished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawView</span><span class="params">(Context context, @Nullable AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        orginBitmap = BitmapFactory.decodeResource(getResources(), R.mipmap.wechatimg1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!bitmapFinished) &#123; <span class="comment">//由于onmeasure要多次调用，所以创建对象的工作只做一次，防止耗时</span></span><br><span class="line">            <span class="keyword">int</span> w = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">            <span class="keyword">int</span> h = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">            bitmap = Bitmap.createScaledBitmap(orginBitmap, w, h, <span class="keyword">false</span>); </span><br><span class="line">            bitmapFinished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onMeasure(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line">        <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>)</span><br><span class="line">            canvas.drawBitmap(bitmap, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".MainActivity"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:clipChildren</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/iv_lu"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">"parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">"parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">SurfaceView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/sv_lu"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:visibility</span>=<span class="string">"gone"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.lll.va.DrawView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>hexo如何引用本地图片</title>
    <url>/2020/04/10/hexo/hexo%E5%A6%82%E4%BD%95%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="如何引用本地图片？"><a href="#如何引用本地图片？" class="headerlink" title="如何引用本地图片？"></a>如何引用本地图片？</h2><p>首先在source下创建images page文件夹，必须用以下命令创建，否则没有index.md, 图片会显示错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page images</span><br></pre></td></tr></table></figure>
<p>然后把图片img1.png放到 hexo_dir/source/images/ 中，然后可以直接在文章中用</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片的alt</span>](<span class="link">/images/img1.png 'title'</span>)</span><br></pre></td></tr></table></figure>
<p>来使用</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>hexo+Next主题详细配置说明</title>
    <url>/2020/04/11/hexo/hexo-Next%E4%B8%BB%E9%A2%98%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>前情<br>之前的文章已经说明了hexo这一框架的搭建过程，本文对该框架如何配置，以及Next主题的配置来一个说明，按着文章的说明慢慢走一遍，属于自己的博客就可以呈现出来啦。也欢迎到我的博客中观看哦~<br>配置说明<br>我个人选择的是Next这一主题，这一主题是由中国人开发，具有中文文档，并且我很喜欢它的设计风格。下面的配置也是围绕这个主题进行的，如果喜欢别的主题，可以到hexo的主题页选择，并根据文档说明尽心配置。</p>
<p>Next主题安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo   <span class="comment"># 进入博客根目录</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>hexo配置<br>编辑博客根目录下的_config.yml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span>                  <span class="comment"># 博客名称</span></span><br><span class="line"><span class="attr">subtitle:</span>               <span class="comment"># 博客子标题</span></span><br><span class="line"><span class="attr">description:</span>            <span class="comment"># 作者描述</span></span><br><span class="line"><span class="attr">keywords:</span>               <span class="comment"># 站点关键词，用于搜索优化</span></span><br><span class="line"><span class="attr">author:</span>                 <span class="comment"># 博主名</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>         <span class="comment"># 站点语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span> <span class="comment"># 时区</span></span><br><span class="line"><span class="comment"># 注意</span></span><br><span class="line"><span class="comment"># 语言这里需要进入 /***/themes/next/languages/ 目录</span></span><br><span class="line"><span class="comment"># 不同版本的语言名称可能有些许差别</span></span><br><span class="line"><span class="comment"># *** 为博客根目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span>                <span class="comment"># 你的域名，如果有 </span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span></span><br><span class="line"><span class="attr">tag_dir:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">archive_dir:</span> <span class="string">archives</span></span><br><span class="line"><span class="attr">category_dir:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">code_dir:</span> <span class="string">downloads/code</span></span><br><span class="line"><span class="attr">i18n_dir:</span> <span class="string">:lang</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing                       # 博文相关</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>        <span class="comment"># 博文的格式，默认markdown编辑 </span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>            <span class="comment"># 默认发布的为post，即默认发布的是文章</span></span><br><span class="line">                                <span class="comment"># 共有三种类型，具体见hexo文档</span></span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = '')</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span>              <span class="comment"># 首页每页展示的文章数</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span>           <span class="comment"># 按日期逆序</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> <span class="string">uncategorized</span></span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> <span class="string">YYYY-MM-DD</span></span><br><span class="line"><span class="attr">time_format:</span> <span class="string">HH:mm:ss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> <span class="string">page</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span>                 <span class="comment"># 使用的主题，这里选用的是Next主题        </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment                # 下面是第三方扩展，根据个人需求设置，也可不修改以下内容</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">search:</span>                     <span class="comment"># 实现搜索文章的功能</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="attr">feed:</span>                       <span class="comment"># 实现博客订阅功能</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sitemap:</span>                    <span class="comment"># 生成站点地图用于SEO优化</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">baidusitmap:</span>                <span class="comment"># 同上</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
<p>Next配置<br>编辑 /<strong><em>/themes/next/_config.yml（其中</em></strong>为博客根目录）文件：<br>注意：<br>该主题内置了大量的第三方插件，使用极其方便，并且在该配置文件中都指明了该三方插件的文档网址，所以在这里只对基础功能进行说明。如果有需求，可浏览相关文档配置出属于自己的博客~</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class="line"><span class="comment"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class="line"><span class="comment"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class="line"><span class="comment"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下设置网站的logo，建议用400*400制作好原图</span></span><br><span class="line"><span class="comment"># 然后访问https://realfavicongenerator.net生成各种类型的logo</span></span><br><span class="line"><span class="comment"># 放置于 ***/themes/next/source/images/目录下，***为博客根目录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/safari-pinned-tab.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup.</span></span><br><span class="line">  <span class="comment"># If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#808080"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, will be used `author` from Hexo main config.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># -------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># Any custom text can be defined here.</span></span><br><span class="line">  <span class="comment">#custom_text: Hosted by &lt;a target="_blank" rel="external nofollow" href="https://pages.coding.me"&gt;&lt;b&gt;Coding Pages&lt;/b&gt;&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SEO 相关设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">true</span>           <span class="comment"># 开启seo优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, will add site-subtitle to index page, added in main hexo config.</span></span><br><span class="line"><span class="comment"># subtitle: Subtitle</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">true</span>       <span class="comment"># 网页搜索及标签页显示副标题</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下为主菜单按键设置，不需要的在行首用#注释掉</span></span><br><span class="line"><span class="comment"># 启用的标签页需要创建相应的目录</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># cd ***                    # 进入微博根目录</span></span><br><span class="line"><span class="comment"># hexo new page about       # 创建about页面</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="comment">#archives: /archives/ || archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主题风格设置</span></span><br><span class="line"><span class="comment"># 选用哪个就去掉哪个的#</span></span><br><span class="line"><span class="comment"># 样例可在next文档中查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主页面菜单栏设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Posts / Categories / Tags in sidebar.</span></span><br><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links.</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.</span></span><br><span class="line"><span class="comment">#social:</span></span><br><span class="line">  <span class="comment">#GitHub: https://github.com/yourname || github</span></span><br><span class="line">  <span class="comment">#E-Mail: mailto:yourname@gmail.com || envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#VK Group: https://vk.com/yourname || vk</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Dependencies: exturl: true in Tags Settings section below.</span></span><br><span class="line">  <span class="comment"># To encrypt links above use https://www.base64encode.org</span></span><br><span class="line">  <span class="comment"># Example encoded link: `GitHub: aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ= || github`</span></span><br><span class="line">  <span class="attr">exturl:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Follow me on GitHub banner in right-top corner.</span></span><br><span class="line"><span class="comment"># Usage: `permalink || title`</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target permalink.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the title and aria-label name.</span></span><br><span class="line"><span class="comment">#github_banner: https://github.com/yourname || Follow me on GitHub</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Blog rolls</span></span><br><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">Links</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">block</span></span><br><span class="line"><span class="comment">#links_layout: inline</span></span><br><span class="line"><span class="comment">#links:</span></span><br><span class="line">  <span class="comment">#Title: http://example.com/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># 头像设置</span></span><br><span class="line"><span class="comment"># 将图片放置于 ***/themes/next/source/images/目录下，***为博客根目录</span></span><br><span class="line"><span class="comment"># 图片不要过大，不利于加载</span></span><br><span class="line"></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/touxiang.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="comment">#rounded: false</span></span><br><span class="line">  <span class="comment"># The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Table Of Contents in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 菜单栏放置于左边还是右边</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width.</span></span><br><span class="line">  <span class="comment"># If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="comment">#width: 300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value (only for Muse | Mist):</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="comment">#display: hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span>            <span class="comment"># 文章索引与顶部的距离</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Back to top in sidebar (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">b2t:</span> <span class="literal">false</span>            <span class="comment"># 回到顶部是否置于菜单栏下方</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Post Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">false</span>           <span class="comment"># 是否自动进行“查看全文”标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically saving scroll position on each post/page in cookies.</span></span><br><span class="line"><span class="attr">save_scroll:</span> <span class="literal">false</span>              <span class="comment"># 是否记录浏览位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically excerpt description in homepage as preamble text.</span></span><br><span class="line"><span class="attr">excerpt_description:</span> <span class="literal">true</span>       <span class="comment"># 是否自动摘录作为前言</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt. Not recommend.</span></span><br><span class="line"><span class="comment"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post meta display settings</span></span><br><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># If true, show updated date label only if `updated date` different from 'created date' (post edited in another day than was created).</span></span><br><span class="line">    <span class="comment"># And if post will edited in same day as created, edited time will show in popup title under created time label.</span></span><br><span class="line">    <span class="comment"># If false show anyway, but if post edited in same day, show only edited time.</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br><span class="line"></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Manual define the border radius in codeblock</span></span><br><span class="line">  <span class="comment"># Leave it empty for the default 1</span></span><br><span class="line">  <span class="attr">border_radius:</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Show text copy result</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微信订阅相关设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Wechat Subscriber</span></span><br><span class="line"><span class="comment">#wechat_subscriber:</span></span><br><span class="line">  <span class="comment">#enabled: true</span></span><br><span class="line">  <span class="comment">#qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg</span></span><br><span class="line">  <span class="comment">#description: ex. subscribe to my blog by scanning my public wechat account</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reward                            # 打赏相关设置</span></span><br><span class="line"><span class="comment">#reward_comment: Donate comment here</span></span><br><span class="line"><span class="comment">#wechatpay: /images/wechatpay.jpg</span></span><br><span class="line"><span class="comment">#alipay: /images/alipay.jpg</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Related popular posts</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/tea3/hexo-related-popular-posts</span></span><br><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br><span class="line">    <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">    <span class="comment">#isDate: false</span></span><br><span class="line">    <span class="comment">#isImage: false</span></span><br><span class="line">    <span class="comment">#isExcerpt: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Declare license on posts</span></span><br><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">&lt;a</span> <span class="string">href="https://creativecommons.org/licenses/by-nc-sa/4.0/"</span> <span class="string">rel="external</span> <span class="string">nofollow"</span> <span class="string">target="_blank"&gt;CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span><span class="string">&lt;/a&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Post edit</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/hexojs/hexo-deployer-git</span></span><br><span class="line"><span class="attr">post_edit:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">https://github.com/theme-next/theme-next.org/_posts/tree/master/</span> <span class="comment"># Link for view source.</span></span><br><span class="line"><span class="comment"># url: https://github.com/theme-next/theme-next.org/_posts/edit/master/ # Link for fork &amp; edit.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reduce padding / margin indents on devices with narrow width.</span></span><br><span class="line"><span class="attr">mobile_layout_economy:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep).</span></span><br><span class="line"><span class="attr">android_chrome_color:</span> <span class="string">"#222"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images's url</span></span><br><span class="line"><span class="attr">custom_logo:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">eighties</span>             <span class="comment"># 代码高亮风格</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable "cheers" for archive page.</span></span><br><span class="line"><span class="attr">cheers_enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># - Find fonts on Google Fonts (https://www.google.com/fonts)</span></span><br><span class="line"><span class="comment"># - All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#     light, light italic, normal, normal italic, bold, bold italic</span></span><br><span class="line"><span class="comment"># - Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># - Introduce in 5.0.1</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># CAUTION! Safari Version 10.1.2 <span class="doctag">bug:</span> https://github.com/iissnan/hexo-theme-next/issues/1844</span></span><br><span class="line"><span class="comment"># To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体相关设置</span></span><br><span class="line"><span class="comment"># 因为上述的谷歌字体中没有中文支持</span></span><br><span class="line"><span class="comment"># 所以下列一般只改字体大小</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host. E.g. //fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: xx`. Use `px` as unit.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements in &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">18</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Headlines (H1, H2, H3, H4, H5, H6).</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for Logo.</span></span><br><span class="line">  <span class="comment"># Fallback to `global` font settings.</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>收工部分<br>在配置过程中，可运行hexo服务器实时观看配置效果，hexo配置的修改需要重启hexo服务器才能生效，主题配置的修改保存后刷新页面即可生效。配置完成后，需要生成静态文件：</p>
<pre><code>cd  xxx/  
hexo generate</code></pre><p>生成的静态文件在 /xxx/public 目录下，如果是托管在github上的话，在网上查找相关教程即可，教程极其丰富。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>创建hexo博客教程</title>
    <url>/2020/04/10/hexo/%E5%88%9B%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1. 新建仓库"></a>1. 新建仓库</h1><p>上 github 新建一个仓库，仓库名必须为 <user-name>.github.io 格式，其中 <user-name> 是你 github 的昵称。不要问我为什么，问我我也不想回答你。</p>
<h1 id="2-全局安装hexo"><a href="#2-全局安装hexo" class="headerlink" title="2. 全局安装hexo"></a>2. 全局安装hexo</h1><p>打开命令行，输入下面的命令，全局安装 hexo。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3. 初始化项目"></a>3. 初始化项目</h1><p>Just one 命令，hexo init，就会自动构建一个 hexo 项目，紧接着执行 hexo s，浏览器访问 localhost:4000 就可以看到效果啦！过程一定要快，凉了就不好吃了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">// 本地运行</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<h1 id="4-部署到github"><a href="#4-部署到github" class="headerlink" title="4. 部署到github"></a>4. 部署到github</h1><p>快速在项目根目录下找到  _congif.yml，找到 deploy 字段并填写完整，下面请开始你上学时最擅长的事情：抄写！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: &lt;你的仓库地址&gt; <span class="comment"># https://github.com/TJ-XiaJiaHao/TJ-XiaJiaHao.github.io</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>抄写完毕！但是！我们需要额外的一个工具来帮助我们推到仓库上，那就是！那就是！那就是 hexo-deployer-git。搞它！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>万事俱备，只欠东南风！执行下面两个命令，就可以把项目自动部署到 github 上。<br>这俩命令顺序一定不能错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>查看效果</li>
</ol>
<p>浏览器访问：<a href="https://lujianyun06.github.io/">https://lujianyun06.github.io/</a> 即可看到效果。<br>至此，已经完成了个人博客的搭建，也可以在浏览器中访问，下面将介绍一些常用的野外生存技能。</p>
<p>如何创建新文章</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">// [layout] 为布局，可选项为 `post`、`page`、`draft`，这将决定文章所在文件路径。</span><br><span class="line">// &lt;title&gt; 为文章标题</span><br><span class="line">// 如 hexo <span class="keyword">new</span> post 除了帅气，我还有啥！</span><br><span class="line">hexo <span class="keyword">new</span> [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>更换主题皮肤<br>风格不喜欢？换之。</p>
<p>更换主题流程：下载主题 -&gt; 配置主题，以 xoxo 为例</p>
<h1 id="下载到themes文件夹下"><a href="#下载到themes文件夹下" class="headerlink" title="下载到themes文件夹下"></a>下载到themes文件夹下</h1><p>git clone <a href="https://github.com/KevinOfNeu/hexo-theme-xoxo" target="_blank" rel="noopener">https://github.com/KevinOfNeu/hexo-theme-xoxo</a> xoxo</p>
<h1 id="修改-config-yml-配置"><a href="#修改-config-yml-配置" class="headerlink" title="修改 _config.yml 配置"></a>修改 _config.yml 配置</h1><p>theme: xoxo<br>部署优化<br>每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">"dev": "hexo s",</span><br><span class="line">"build": "hexo clean &amp;&amp; hexo deploy"</span><br></pre></td></tr></table></figure>

<p>部署命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>并发机制底层实现原理</title>
    <url>/2020/04/10/java/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>1.volatile<br>    volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</p>
<p>volatile两条实现原则：</p>
<ol>
<li>Lock前缀指令会引起处理器缓存回写到内存。</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。<br> 在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。（补足64个字节，使得缓存中的头尾节点不会被读到一个缓存行中，也就不能相互锁定）<br>不应该追加字节的场景：</li>
</ol>
<ul>
<li>缓存行非64字节宽的处理器。</li>
<li>共享变量不会被频繁地写。</li>
</ul>
<p>1.synchronized<br>    用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
<ul>
<li>·对于普通同步方法，锁是当前实例对象。</li>
<li>·对于静态同步方法，锁是当前类的Class对象。</li>
<li>·对于同步方法块，锁是Synchonized括号里配置的对象。<br>  当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br>（synchronized本质上是去获取对象对应的monitor的所有权）<br>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，<br>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。<br>》偏向锁<br>  大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。</li>
</ul>
<blockquote>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。<br>    简单说就算获得它的线程退出后先不释放锁，下一次如果还是这个线程进入的话就不用再获取锁了， 只是去比较一下是否是偏向锁且锁的markword中的线程ID是否是当前ID，<br>    如果是的话，都不用CAS，就直接进入同步块了。 如果有别的线程来竞争的话，就撤销偏向锁标志了。</p>
</blockquote>
<p>》轻量级锁</p>
<blockquote>
<p>如果当前不是偏向锁，且线程通过CAS修改锁的markword成功了，则就将其标志为轻量级锁<br>如果CAS没成功，则一直自旋CAS，如果失败到一定程度，则认为膨胀为重量级锁，修改其锁标志，这个自旋的线程再进入阻塞状态。<br>任何去竞争对象锁的线程都有权利按照规则修改其对象头的锁标志（不管是否获取到锁），但对象头的markword中的指向的锁记录的栈帧所属的线程才是该线程获得锁的标志<br>如果有线程去尝试获得锁，发现是重量级锁，就不会自旋CAS了，而是直接进入阻塞</p>
</blockquote>
<p>在Java中可以通过锁和循环CAS的方式来实现原子操作。<br>(只有AtomicXXX才能使用CAS)</p>
<p>CAS实现原子操作的三大问题</p>
<ul>
<li>ABA问题，java中使用AtomicStampedReference解决，这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>只能保证一个共享变量的原子操作。这个时候就可以用锁</li>
</ul>
<p>》使用锁机制实现原子操作<br>    锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>IoC和AOP的简单总结</title>
    <url>/2020/04/10/java/IoC%E5%92%8CAOP%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<hr>
<h2 id="IoC："><a href="#IoC：" class="headerlink" title="IoC："></a>IoC：</h2><hr>
<p>context是总管家。总领全局<br>    context创建一个bean工厂，一个解析工具（如xmlReader）。先让解析工具去完成对xml或者注解中bean的解析，对于每个bean节点，提取出其中的名称，类型、属性来构建出一个beandefinition(bd)，并存放到解析工具的map中，之后创建这个map中的bd全部移到bean工厂的map中，然后扫描出所有类型为bean初始化前置/后置处理器的bean，此时就要把它们创建好，并把它们都加到bean工厂的前置/后置处理列表中。<br>此时bean工厂中有了所有的bean的bd（但bean本身还没创建，除了前置/后置处理器bean）<br>（tiny中是全部bean都在这里创建，而在spring中，bean创建可以等到用户第一次getbean时，再触发下面的动作）<br>之后进行bean的创建，进行context的onrefresh，在bean工厂中遍历map，创建bean的实例，并且对每个bean实例做如下工作：<br>    创建后把bean实例和它的bd绑定起来（把它赋给bd的一个属性），并且从bd中取出之前设定的一些属性，给bean赋上。然后对从bean工厂中取出之前加入到前置处理器列表中的bean，使用这些处理器bean对当前的这个bean做前置处理；然后进行这个bean的初始化方法（指定的init-method），然后取出之前加入到后置处理器列表中的bean，使用这些处理器bean对当前的这个bean做后置处理（比如aop就是在这一步发挥作用，检测这个bean的类型是不是符合要拦截处理的类型，如果是，则创建用一个该类代理类型的bean代替当前的这个bean返回）； 做完前置/后置处理后都会返回bean(这个bean可能已经被修改了)，再次把这个最终经过前后置处理的bean重新与bd绑定（之前绑定的就作废了）。（真正的spring中还有给每个bean设置关于容器感知，名称感知，context感知之类的功能）<br>（如果对于特定类型的bean要执行特定的前置/后置处理，只需在处理器中判断bean的类型，满足再处理，否则就把传入的bean原样返回即可）<br>此时，bean的初始化就完成了，获取bean的话，就通过context得到bean工厂，再从bean工厂中通过要获取的bean的类型或名称得到bd，再从bd得到与之绑定的bean。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>有一个后置处理器叫AspectJAwareAdvisorAutoProxyCreator（简称apc），它的作用是在bean的后置处理时如果需要创建代理，则创建代理来代替原始bean返回<br>有一个类叫TargetSource，它可以封装一个其他类的实例对象，类型，以及它实现和继承的类型/接口集合，相当于是某个实例对象的信息组合。<br>一个类叫AdvisedSupport（具体实现是proxyFactory），它是一个aop的核心类型，它有targetsource的成员变量，有方法拦截器的成员变量，有方法匹配器的成员变量。<br>advisors实际上是包含所有需要代理的类的名单，需要拦截的方法的名单，以及所有的方法拦截器。<br>advisors由多个advisor组成，每个advisor包含一个pointcut成员，一个advice成员。<br>    pointcut定义了一组规则，包括符合条件的类型名规则，符合拦截的方法名规则。（术语是切点）<br>    advice就是一个方法拦截器.(其实就是执行额外的逻辑代码的工具) （术语是通知）<br>（这里advisor的术语就是aspect，即切面，实际上就是切点和通知的综合体）<br>每个advisor也是一个bean，它在spring中实际上就是注解了@AspectJ的类的实例，其pointcut和advice可能都是自己。（而且为了保证advisor必须在其他实例创建之前就创建好，每次有一个bean进入创建代理的后置处理器时，会从容器获得所有的advisor(利用getBeansForType)，如果有某个advisor还没创建，则优先创建它。因此会保证如果一个bean需要被代理，则其advisor一定在它用之前就创建好）</p>
<p>当有一个bean要进行apc的后置处理的时候，遍历所有的advisor，如果不符合所有的advisor类型规则，则直接返回bean；如果发现符合其中一个advisor的类型规则，进入下一步：（真正的spring中使用拦截链，也就是说可以有多个advisor匹配当前的bean，调用方法的时候会一个挨一个调用）<br>创建一个advisedSupport<br>  ·根据这个bean去创建一个它的targetSource，并且把这个targetSource设置给advisedSupport的成员<br>  ·把当前的advisor的方法规则（方法匹配器）设置给advisedSupport<br>  ·把当前advisor的方法拦截规则（方法拦截器）设置给advisedSupport</p>
<p>使用advisedSupport生成一个代理工厂，该代理工厂拥有advisedSupport的成员变量，并且这个代理工厂是一个调用处理器(InvocationHandler)。<br>    使用代理工厂去生成一个当前这个bean的代理对象。如果用jdk动态代理的话，使用<br>Proxy.newProxyInstance(当前类的类型加载器, bean的所有实现和继承的类型/接口集合, 调用处理器(也就是生成它的代理工厂)）来得到一个代理对象，这个代理对象拥有所有bean的同名方法，当调用代理对象的一个方法时，会调用它的调研处理器的invoke方法，并且会把bean的原本该名称的方法、bean对象，参数都传入invoke<br>，在调用处理器（即代理工厂）的invoke方法中，使用它的成员advisedSupport的方法匹配规则来判断当前调用的这个方法是不是需要拦截的，如果不是则直接调用bean的原来的方法；如果是需要拦截的，则使用advisedSupport的方法拦截器，去执行具体的拦截器的额外逻辑代码（这里还涉及到一个MethodInvocation，但它实际上就是对一个方法、对象、参数的包装，只是为了方便打包传递，从调用处理器传递到拦截器，没有额外的用途），当然这个额外的逻辑代码中也可以调用bean原来的方法，也可以去做一些额外的操作。<br>生成代理后返回，则此时代理对象就取代了原本的bean成为了bean容器中针对原来的bean类型的合法代言人了，别的地方不论是通过原本的类型，还是设置的名称，获得的都是这个代理，而原来的bean就只存在于代理对象的调用处理器中的advisedSupport中的targetSource中（层层包裹，外部是无法得到这个bean的）。</p>
<p>另：<br>生成代理对象的方式有jdk动态代理，还有其他一些，如Cglib2等，但原理都是一样的。</p>
<blockquote>
<p>注意，jdk动态代理生成的对象只能转成实际类实现的接口类型的对象，而无法转成实在的类的对象（而cglib能）<br>例如，A implements I<br>jdk动态代理创建好的代理proxy只能强转成I类型的，而不能强转成A类型的。</p>
</blockquote>
<blockquote>
<p>注意，InvocationHandler的invoke方法，传递过来的是proxy，而不是原始对象，所以如果要运行原本实例的方法(method.invoke)，需要在InvocationHandler中保存原本的实例</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Concurrent mode failure和 promotion failed</title>
    <url>/2020/04/10/java/Concurrent%20mode%20failure%E5%92%8C%20promotion%20failed/</url>
    <content><![CDATA[<p>：（两种错误刚好就是三种进入老年代的方法引起的）</p>
<h2 id="一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"><a href="#一-并发模式失败（concurrent-mode-failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）" class="headerlink" title="一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）"></a>一.并发模式失败（concurrent mode failure）：产生的原因是老年代的可用空间不够了（因为正常晋升入老年代的对象太多太快，或者由于新生代不够而从创建就直接进入老年代的对象太多）</h2><p>原因有两种：<br>    1.年轻代提升太快，老年代的处理速度跟不上新生代的提升速度；或者新生代空间太小，放不下新产生的对象而直接转入老年代，但老年代也空间不够<br>        解决办法：<br>        ①.调大新生代空间 -Xmn<br>        ②.加大新生代晋升的阈值 -XX:MaxTenuringThreshold<br>    2.老年代碎片过多<br>        解决办法：<br>        ①.调大老年代的比例  –XX:NewRatio<br>        ②.降低老年代进行垃圾回收的阈值，<br>        -XX:CMSInitiatingOccupancyFraction=60（默认是 68）<br>        -XX:+UseCMSInitiatingOccupancyOnly<br>当老年代碎片过多时，这个过程注意cms的性能会比较差，退化成只有一个线程来收集垃圾，耗时可能有几秒或十几秒。</p>
<h2 id="二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"><a href="#二-提升失败（promotion-failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）" class="headerlink" title="二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）"></a>二. 提升失败（promotion failed）：新生代太小，放不下要复制的存活对象，转而要往老年代放，但这样老年代就有大量短命对象，而很快内存不够就报错（因为MinorGC时的survivor放不下eden和另一个survivor中没回收的对象，转而进入老年代）</h2><p>一个Survivor 区不能容纳eden和另外一个survivor里面的存活对象，多余的对象进入老年代，这样就会导致老年代里面的存放大量的短暂存活的对象，<br>而我们知道，如果老年代里面没有可用空间就会发生full gc，这样就造成扫描整个堆，造成提升失败（promotion failed）。</p>
<pre><code>解决办法：增加survivor
    ①.增加年轻代的大小 -Xmn
    ②.调整survivor和eden的比例  -XX:SurvivorRatio 默认是8 ， 各占比 s0：s1 ：eden =1：1：8 ， 减小这个值也就加大了survivor。</code></pre>]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu16下 pip安装，卸载、升级，报错</title>
    <url>/2020/04/10/linux/Ubuntu16%E4%B8%8B%20pip%E5%AE%89%E8%A3%85%EF%BC%8C%E5%8D%B8%E8%BD%BD%E3%80%81%E5%8D%87%E7%BA%A7%EF%BC%8C%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>新装的ubuntu16，自带的python2.7，使用pip升级后，报错，修改记录如下：</p>
<h2 id="如何彻底卸载pip？"><a href="#如何彻底卸载pip？" class="headerlink" title="如何彻底卸载pip？"></a>如何彻底卸载pip？</h2><p>sudo python -m pip uninstall pip</p>
<h2 id="如何安装pip"><a href="#如何安装pip" class="headerlink" title="如何安装pip"></a>如何安装pip</h2><p>sudo apt install python-pip</p>
<h2 id="如何安装指定版本的pip"><a href="#如何安装指定版本的pip" class="headerlink" title="如何安装指定版本的pip"></a>如何安装指定版本的pip</h2><p>python -m pip install pip==18.1(换成你想要的版本编号)</p>
<h2 id="pip安装软件过程中报错："><a href="#pip安装软件过程中报错：" class="headerlink" title="pip安装软件过程中报错："></a>pip安装软件过程中报错：</h2><p>Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build-BqMhb7/matplotlib/</p>
<ol>
<li>安装并升级setuptools<br>pip install –upgrade setuptools</li>
<li>升级pip<br>pip install –upgrade pip</li>
</ol>
<h2 id="pip升级后报错"><a href="#pip升级后报错" class="headerlink" title="pip升级后报错"></a>pip升级后报错</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File "/usr/bin/pip", line 9, in &lt;module&gt;</span><br><span class="line">    from pip import main</span><br><span class="line">ImportError: cannot import name 'main'</span><br><span class="line">修改/usr/bin/pip如下：</span><br><span class="line">//修改前</span><br><span class="line">from pip import main  </span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(main()) </span><br><span class="line">修改后</span><br><span class="line">from pip import __main__  //这行也要修改</span><br><span class="line">if __name__ == '__main__':  </span><br><span class="line">    sys.exit(__main__._main())//增加__main__._  （注意最后main()前面有个_）</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>如何理解linux挂载</title>
    <url>/2020/04/10/linux/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3linux%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<p>根据树结构去理解整个文件系统的挂载和挂载点还是有点困难，所以自己做了些总结，有不对的地方还请指正</p>
<p>df -h命令后</p>
<p>Filesystem 这里的文件系统表示的是目录的层次结构，而不是所谓的像ext4，fat那种真正的文件系统类型<br>一个具体的设备文件(或分区) ，或许是一块硬盘上的一个分区，或许是u盘上的一个分区</p>
<p>目录就相当于门<br>整个linux中的文件系统就像一个世界接着一个世界，不同的世界代表不同的被挂载的文件系统，挂载点就相当于任意门（特殊的门），各个被挂载的文件系统之间是独立的，但是要进入其中一个需要一个一个进入任意门去穿梭，整个世界的第一个门是 / ，它里面的世界是第一个文件系统，这个世界里又有很多个门，有的门背后的世界和这个世界是同一个，则他们是在同一个文件系统里，而当有其他的分区被挂载到一个目录的时候，例如<br>对一个目录 /home/lll，要到达这个门后的世界，要穿过 / 和 home/ （这个门在 / 后面的世界里） 和 lll/ （这个门在 home/ 后面的世界里），形象的描述为：</p>
<p>/ —》 世界A （包含 home/ —-》 世界B （包含 lll/ —》 世界C ）如果不做任何其他挂载，世界A、B、C是同一个世界）当要把/dev/sda1这个id所指向的分区挂载到 /home/lll 则相当于把 /home/lll/ 这个门变成任意门，它通往的世界变成了sda1的世界空间，自然的，只要进了这个世界，如果再不挂载其他的，则所有对 /home/lll/… 的操作都在sda1的世界里，而对这个门前面的世界的操作，如对/home/aaa的操作，仍然在一开始的那个世界里<br>把挂载点想象成一个任意门，进入第一个任意门是世界A，里面还有一个任意门通往世界B，虽然只有进了第一个任意门才能进第二个任意门，但世界A和世界B是毫无关系彼此独立的（挂载的文件系统之间彼此独立）<br>挂载绑定：把一个目录挂载到另一个目录，比如 mount –bind dir1 dir2 则是相当于对dir2这个门做了特殊处理，让dir2和dir1通往同一个世界的同一个位置，而dir2原本通往的那个位置里面的东西会被遮盖掉，当解除挂载后，dir2会恢复它原本通往的世界和位置，且里面的东西还在</p>
<p>当把目录A挂载到目录B，= mount –bind A B ; 其中B是新的挂载点 ，就是让门B通往的地方和门A通往的地方一毛一样<br>把设备A挂载到目录B = mount A B ; 其中B是新的挂载点，就是让门B通往的地方是A的世界空间。<br>挂载点必须是目录（门）</p>
<p>可以对同一个目录多次挂载，最后生效的结果是最后一次挂载，此时卸载，则倒数第二次挂载生效，再卸载，则倒数第三次挂载生效</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾收集器GC中parallel scavenge收集器为什么不能CMS配合使用？</title>
    <url>/2020/04/10/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8GC%E4%B8%ADparallel%20scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BDCMS%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%9F/</url>
    <content><![CDATA[<p>首先看一下收集器的分布：</p>
<p><img src="http://img.blog.csdn.net/20170102225015393" alt="垃圾收集器"></p>
<p>1.解答parallel scavenge收集器为什么不能CMS配合使用？<br>首先讲一下Hotspot，HotSpot VM里多个GC有部分共享的代码。有一个分代式GC框架，Serial/Serial Old/ParNew/CMS都在这个框架内；在该框架内的young collector和old collector可以任意搭配使用，所谓的“mix-and-match”。<br>而ParallelScavenge与G1则不在这个框架内，而是各自采用了自己特别的框架。这是因为新的GC实现时发现原本的分代式GC框架用起来不顺手。</p>
<p>ParallelScavenge（PS）的young collector就如其名字所示，是并行的拷贝式收集器。本来这个young collector就是“Parallel Scavenge”所指，但因为它不兼容原本的分代式GC框架，为了凸显出它是不同的，所以它的young collector带上了PS前缀，全名变成PS Scavenge。对应的，它的old collector的名字也带上了PS前缀，叫做PS MarkSweep。</p>
<p>这个PS MarkSweep默认的实现实际上是一层皮，它底下真正做mark-sweep-compact工作的代码是跟分代式GC框架里的serial old（这个collector名字叫做MarkSweepCompact）是共用同一份代码的。也就是说实际上PS MarkSweep与MarkSweepCompact在HotSpot VM里是同一个collector实现，包了两张不同的皮；这个collector是串行的。</p>
<p>最后：<br>重点就是Parallel Scavenge没有使用原本HotSpot其它GC通用的那个GC框架，所以不能跟使用了那个框架的CMS搭配使用。</p>
<p>新生代：使用复制算法进行GC。<br>老年代：使用标记-整理算法。</p>
<p>并发：（concurrent）用户线程与垃圾收集器同时执行（但不一定并行的，可能会交替执行）<br>并行：（parallel）多条垃圾手机线程并行，用户线程仍然等待。</p>
<p>1.新生代收集器<br>serial收集器：是新生代的一个单线程的GC，，进行GC时，停掉所有用户线程，直至回收结束，“stop-the-world”。但是其单线程的简单高效，没有线程交互的开销，常被JVM运行在client模式下的默认新生代收集器。</p>
<p>ParNew：并行收集器，是serial收集器的多线程的版本。是运行在server模式下的首先的新生代的收集器。</p>
<p>parallel scavenge ：新生代收集器，多线程，并行收集。<br>此收集器与之前的收集器目的不同：（特点）达到一个可控制的吞吐量。吞吐量=运行用户代码时间/CPU总执行时间。<br>用于精确吞吐量的两个参数：1.控制最大垃圾收集停顿时间参数 2.直接设置吞吐量大小的参数。Parallel scavenge收集器与ParNew收集器重要区别是： 垃圾自适应调节策略。</p>
<p>2.老年代收集器<br>serial old：老年代收集器版本，单线程。<br>用途：1.在JDK1.5版本之前与parallel scavenge 收集器搭配使用。<br>2.作为CMS收集器的后备预案。</p>
<p>Parallel Old ：使用多线程收集。吞吐量优先。</p>
<p>CMS：</p>
<ol>
<li>目标是：尽量缩短垃圾回收时间和用户线程的停顿时间</li>
<li>严格意义上第一款并发垃圾回收器</li>
<li>主要场景在 互联网 B/S 架构上</li>
<li>使用标记清除算法</li>
<li>步骤<br> 5.1 初始标记：STW、快；GC Root 能直接关联的对象<br> 5.2 并发标记：并发；GC Root Tracing 的过程<br> 5.3 重新标记：STW、快；修复并发标记阶段 用户线程运行时变动的对象<br> 5.4 并发清除：并发</li>
<li>因为整个过程中耗时最长的 “并发标记”和“并发清除”是和用户线程并发执行的，所以可认为CMS回收器是和用户线程并发执行的</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>brew从国内源安装</title>
    <url>/2020/04/10/mac/brew%E4%BB%8E%E5%9B%BD%E5%86%85%E6%BA%90%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>最近按照默认方法安装brew特别慢，但是想切换从国内源安装，得到的都是老版本的切换方法：</p>
<p><a href="https://segmentfault.com/a/1190000018360813" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018360813</a></p>
<p>因为安装brew的脚本现在不是ruby脚本，改成了shell脚本，而且脚本地址也改变了，所以也需要改变一下安装策略：</p>
<p>首先把<a href="https://raw.githubusercontent.com/Homebrew/install/master/install.sh上的所有内容拷贝到~目录下的brew_install" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install.sh上的所有内容拷贝到~目录下的brew_install</a> 文件中（没有就新建）</p>
<p>修改代码（修改为中科大源）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  HOMEBREW_PREFIX_DEFAULT=<span class="string">"/home/linuxbrew/.linuxbrew"</span></span><br><span class="line">  HOMEBREW_CACHE=<span class="string">"<span class="variable">$&#123;HOME&#125;</span>/.cache/Homebrew"</span></span><br><span class="line"> </span><br><span class="line">  STAT=<span class="string">"stat --printf"</span></span><br><span class="line">  CHOWN=<span class="string">"/bin/chown"</span></span><br><span class="line">  CHGRP=<span class="string">"/bin/chgrp"</span></span><br><span class="line">  GROUP=<span class="string">"<span class="variable">$(id -gn)</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># BREW_REPO="https://github.com/Homebrew/brew” 修改前</span></span><br><span class="line">BREW_REPO=<span class="string">"git://mirrors.ustc.edu.cn/brew.git”  #修改后</span></span><br><span class="line"><span class="string">CORE_TAP_REPO="</span>git://mirrors.ustc.edu.cn/homebrew-core.git”  <span class="comment">#新增</span></span><br></pre></td></tr></table></figure>

<p>修改过后把brew_install文件变为可执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+x brew_install</span><br></pre></td></tr></table></figure>
<p>然后用执行脚本的方式执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash brew_install</span><br></pre></td></tr></table></figure>
<p>速度简直和外网不是一个level！</p>
<p>但是执行到brew-core还是会巨慢无比，此时可以ctrl-c 可以停掉,</p>
<p>创建目录/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core</p>
<p>并执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure>
<p>然后重新执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash brew_install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
  </entry>
  <entry>
    <title>ERROR 1193 (HY000)：Unknown system variable ‘tx_isolaton’</title>
    <url>/2020/04/10/mysql/mysql%20error1193/</url>
    <content><![CDATA[<p>mysql执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@tx_isolaton;</span><br></pre></td></tr></table></figure>
<p>保错：</p>
<blockquote>
<p>ERROR 1193 (HY000): Unknown system variable ‘tx_isolaton’</p>
</blockquote>
<p>解决方法：mysql8及以上tx_isolaton更名为transaction_isolation，执行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@transaction_isolation;</span><br></pre></td></tr></table></figure>
<p>即可解决。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>html中的符号</title>
    <url>/2020/04/10/%E5%85%B6%E4%BB%96/html%E4%B8%AD%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<p><img src="/images/html-symbol1.png" alt="1"><br><img src="/images/html-symbol2.png" alt="2"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>类的继承关系如何在关系型数据库体现</title>
    <url>/2020/04/10/mysql/%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%A6%82%E4%BD%95%E5%9C%A8%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%93%E7%8E%B0/</url>
    <content><![CDATA[<p>在面向对象的编程中，使用对象的继承是一个非常普遍的做法，但是在关系数据库管理系统RDBMS中，使用的是外键表示实体（表）之间的关系，那么对于继承关系，该怎么在RDBMS中表示呢？一般来说有3种实现方式：</p>
<p>Concrete Table Inheritance（具体表继承）</p>
<p>Single Table Inheritance（单表继承）</p>
<p>Class Table Inheritance（类表继承）</p>
<p>比如在一个教务系统中，有老师学生2个对象，这两个对象都是“人”对象的子类，所以我们可以建立一个Person表，该表有人的公共属性：姓名、性别等，还有就是数据的唯一标识，一个ID。而教师对象有教师的特有属性，比如职称，学生有学生的特有属性，比如学号。所以我们可以建立Person、Teacher、Student3个表，其关系在PowerDesigner中如图所示：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161529499985.png" alt="1"></p>
<h2 id="1-具体表继承。"><a href="#1-具体表继承。" class="headerlink" title="1.具体表继承。"></a>1.具体表继承。</h2><p>不建立父对象，将父对象的所有属性转移到子对象中，为每个子对象建立对于的表。如果使用这种方法，那么就只需要建立Teacher表和Student表，不需要Person表，在PowerDesigner中，双击继承节点，打开属性窗口，取消“Generate Parent”选项，选中“Generate children”并选择“Inherit all attributes”，如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/20110816152954537.png" alt="2"></p>
<p>生成的数据库表将如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161529572781.png" alt="3"></p>
<h2 id="2-单表继承。"><a href="#2-单表继承。" class="headerlink" title="2.单表继承。"></a>2.单表继承。</h2><p>在一个宽表中列出所有父对象和子对象的属性，同时用一个标识列表示该行数据存储的是哪个子类的数据。在PowerDesigner中，修改继承节点的属性，取消“Generate children”，选中“Generate parent”，然后在下面添加一个标识列，叫PersonType，如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161529591993.png" alt="4"><br>生成的数据库表，在一个宽表中表示如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161530015383.png" alt="5"></p>
<p>可以看到Person中的列集成了Person、Teacher、Student这3个表的所有列，同时还多了一个列PersonType，这个列就是用来区分这行数据到底表示的是一个学生还是一个老师。</p>
<h2 id="3-类表继承。"><a href="#3-类表继承。" class="headerlink" title="3.类表继承。"></a>3.类表继承。</h2><p>对父对象和每个子对象建立一个对应的表，然后在子表中设置该子表的主键为与父表关联的外键。在PowerDesigner中，对于继承节点的属性，允许生成父和子表，另外，将“Inherit only primary attributes”选中。如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161530043450.png" alt="6"><br>生成的数据库表如图所示：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/studyzy/201108/201108161530181026.png" alt="7"></p>
<p>这里可以看到，Teacher的主键和Student的主键同时又是该表的外键，连接到Person表。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>一个包含各种算法的好网站</title>
    <url>/2020/04/10/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB%E5%90%84%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%A5%BD%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p>包括排序，查找、各种数据结构都有<br>码一下<br><a href="https://www.geeksforgeeks.org" target="_blank" rel="noopener">https://www.geeksforgeeks.org</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>跳表</title>
    <url>/2020/04/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%B7%B3%E8%A1%A8/</url>
    <content><![CDATA[<p>本文大部分内容借鉴自<a href="https://baijiahao.baidu.com/s?id=1633338040568845450&amp;wfr=spider&amp;for=pc，感谢大神的辛勤劳动！" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1633338040568845450&amp;wfr=spider&amp;for=pc，感谢大神的辛勤劳动！</a></p>
<p>跳表就是跳跃的表，其实归根结底是好多层的链表，最底层是正常的数据链表，往上走是代表性的索引</p>
<p>越往上走一个索引代表的节点就越多，其实跳表和B* 树有些类似，</p>
<p>B* 树</p>
<p><img src="https://img-blog.csdnimg.cn/20200312205851392.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="1"></p>
<p>跳表：</p>
<p>越往上走，一个值能代表的范围越广。</p>
<p><img src="https://img-blog.csdnimg.cn/20200312210012776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt=""></p>
<p>都是：如果在当前层大于本节点，小于下一个节点，则往下走，否则继续往前走</p>
<p>跳表。跳表是redis的一个核心组件，也同时被广泛地运用到了各种缓存地实现当中，它的主要优点，就是可以跟红黑树、AVL等平衡树一样，做到比较稳定地插入、查询与删除。理论插入查询删除的算法时间复杂度为O(logN)。<br><img src="https://img-blog.csdnimg.cn/20200312205831229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="3"></p>
<p>什么是跳表</p>
<p>链表，相信大家都不陌生，维护一个有序的链表是一件非常简单的事情，我们都知道，在一个有序的链表里面，查询跟插入的算法复杂度都是O(n)。<br><img src="https://img-blog.csdnimg.cn/20200312205831176.png" alt="4"></p>
<p>我们能不能进行优化呢，比如我们一次比较两个呢？那样不就可以把时间缩小一半？<br><img src="https://img-blog.csdnimg.cn/20200312205831220.png" alt="5"></p>
<p>同理，如果我们4个4个比，那不就更快了？<br><img src="https://img-blog.csdnimg.cn/20200312205831280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="6"></p>
<p>跳表就是这样的一种数据结构，结点是跳过一部分的，从而加快了查询的速度。跳表跟红黑树又有什么差别呢？既然两者的算法复杂度差不多，为什么Redis要使用跳表而不使用红黑树呢？跳表相对于红黑树，主要有这几个优点：1.代码相对简单，手写个跳表还有可能，手写个红黑树试试？</p>
<p>2.如果我们要查询一个区间里面的值，用平衡树可能会麻烦。这里的麻烦指的是实现和理解上，平衡二叉树查询一段区间也是可以做到的。3.删除一段区间，这个如果是平衡二叉树，就会相当困难，毕竟设计到树的平衡问题，而跳表则没有这种烦恼。好了，相信你对跳表已经有一些认识了，我们来简单介绍平衡二叉树的几个基本操作。</p>
<p><strong>查询</strong></p>
<p>假如我们要查询11，那么我们从最上层出发，发现下一个是5，再下一个是13，已经大于11，所以进入下一层，下一层的一个是9，查找下一个，下一个又是13，再次进入下一层。最终找到11。<br><img src="https://img-blog.csdnimg.cn/20200312205831286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="7"></p>
<p>是不是非常的简单？我们可以把查找的过程总结为一条三目表达式（下一个是否大于结果？下一个：下一层）。理解跳表的查询过程非常重要，试试看查询其他数字，只要你理解了查询，后面两种都非常简单。</p>
<p><strong>插入</strong></p>
<p>插入的时候，首先要进行查询，然后从最底层开始，插入被插入的元素。然后看看从下而上，是否需要逐层插入。可是到底要不要插入上一层呢？我们都知道，我们想每层的跳跃都非常高效，越是平衡就越好（第一层1级跳，第二层2级跳，第3层4级跳，第4层8级跳）。但是用算法实现起来，确实非常地复杂的，并且要严格地按照2地指数次幂，我们还要对原有地结构进行调整。所以跳表的思路是抛硬币，听天由命，产生一个随机数，50%概率再向上扩展，否则就结束。这样子，每一个元素能够有X层的概率为0.5^(X-1)次方。反过来，第X层有多少个元素的数学期望大家也可以算一下。</p>
<p><strong>删除</strong></p>
<p>同插入一样，删除也是先查找，查找到了之后，再从下往上逐个删除。比较简单，就不再赘叙。</p>
<p>跳表和二叉搜索树比较：<br><img src="https://img-blog.csdnimg.cn/20200313112143915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="8"></p>
<p><strong>总结</strong></p>
<p>跳表，用了计算机中一场非常用的解决问题的思路，随机。随机在深度学习与人工智能领域运用得非常的广泛。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>220. Contains Duplicate III</title>
    <url>/2020/04/10/%E7%AE%97%E6%B3%95/220.%20Contains%20Duplicate%20III/</url>
    <content><![CDATA[<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Medium</span><br><span class="line"></span><br><span class="line">Given an <span class="built_in">array</span> of <span class="built_in">int</span>egers, find <span class="keyword">out</span> whether there are two distinct indices i <span class="keyword">and</span> j <span class="keyword">in</span> the <span class="built_in">array</span> such that the absolute difference between nums[i] <span class="keyword">and</span> nums[j] <span class="keyword">is</span> at most t <span class="keyword">and</span> the absolute difference between i <span class="keyword">and</span> j <span class="keyword">is</span> at most k.</span><br><span class="line"></span><br><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span>, t = <span class="number">0</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span>, t = <span class="number">2</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Example <span class="number">3</span>:</span><br><span class="line"></span><br><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], k = <span class="number">2</span>, t = <span class="number">3</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">给定一个整数数组，找出数组中是否有两个不同的索引i和j，使得nums[i]和nums[j]之间的绝对值差最大为t, i和j之间的绝对值差最大为k。</span><br></pre></td></tr></table></figure>

<p>笨办法就是双重循环，如果下标绝对值符合后再看数值是否符合，会超时</p>
<p>网上找的中文解释都没看懂。</p>
<p>使用TreeSet数据结构，可以借助TreeSet中有用的函数</p>
<p>TreeSet.floor(x) 表示TreeSet中小于或等于x的最大元素<br>TreeSet.ceiling(x) 表示TreeSet中大于或等于x的最小元素</p>
<p>对于数组中任意一个数nums[i], 与其绝对值差小于等于为t的区间为 [nums[i]-t，nums[i]+t],  数轴表示如下</p>
<pre><code>    I__________I__________I
nums[i]-t   nums[i]      nums[i]+t</code></pre><p>使用TreeSet的floor和ceiling函数，可以得到是否有数字在上述区间内<br>即：f = floor(nums[i] + t) 且 f&gt;=nums[i]，说明f在[ nums[i], nums[i]+t]内<br>   c = ceiling(nums[i] - t) 且 c&lt;=nums[i]，说明c在[ nums[i]-t, nums[i]]内</p>
<p>如果存在f或者c，然后要保证的是 它们的索引和i差距小于k，则只需维持TreeSet中始终只保留窗口大小为k的元素即可（在访问nums[i]时，TreeSet中始终只保留nums[i-k]到nums[i-1] ）。</p>
<p>这样，只要存在f或者c，就存在满足条件的值，因为TreeSet中元素的坐标都满足和i的约束关系，直接返回。<br>若不存在，则把nums[i]加入TreeSet，删去nums[i-k]（因为下一个要访问的是nums[i+1]，nums[i-k]与nums[i+1]的坐标约束不满足），继续遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> TreeSet&lt;Integer&gt; values = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Integer floor = values.floor(nums[i] + t); <span class="comment">//set中是否有满足 小于或等于 nums[i]+t 的数字</span></span><br><span class="line">            <span class="keyword">final</span> Integer ceil = values.ceiling(nums[i] - t); <span class="comment">//set中是否有满足 大于或等于 nums[i]-t 的数字</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果有这样的数字，且TreeSet中元素坐标都与i满足约束条件，那么就有满足题意的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((floor != <span class="keyword">null</span> &amp;&amp; floor &gt;= nums[ind])</span><br><span class="line">                    || (ceil != <span class="keyword">null</span> &amp;&amp; ceil &lt;= nums[ind])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            values.add(nums[i]);</span><br><span class="line">            <span class="comment">//保证TreeSet中的坐标和i的差都小于等于k</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123; </span><br><span class="line">                values.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>不重复打印排序数组中相加和为给定值的所有二元组和三元组</title>
    <url>/2020/04/23/%E7%AE%97%E6%B3%95/%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%93%E5%8D%B0%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E5%85%83%E7%BB%84%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84/</url>
    <content><![CDATA[<h2 id="不重复打印排序数组中相加和为给定值的所有二元组和三元组"><a href="#不重复打印排序数组中相加和为给定值的所有二元组和三元组" class="headerlink" title="不重复打印排序数组中相加和为给定值的所有二元组和三元组"></a>不重复打印排序数组中相加和为给定值的所有二元组和三元组</h2><p>给定排序数组arr和整数k，不重复打印arr中所有相加和为k的不降序二元组。<br>例如，arr=[-8,-4,-3,0,1,2,4,5,8,9],k=10,打印结果为：<br>1,9<br>2,8</p>
<p>1.利用双指针法，设置遍历left=0和right=length-1<br>2.比较arr[left]+arr[right]的值(sum)与k的大小<br>    如果sum等于k，打印arr[left],arr[right], left++,right–.<br>    如果sum大于k，right–<br>    如果sum小于k，left++<br>3.如果left&lt; right,则一直重复步骤2，否则过程结束<br>为了保证不重复打印，只需在打印前增加一个检查：arr[left]是否与它前一个值相等，如果相等就不打印<br>解释：因为整体过程是两头向中间压缩的过程，如果arr[left]+arr[right]=k,又有arr[left]==arr[left-1],那么之前一定打印过这个二元组，则不用再重复打印<br>时间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUniquePair</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left]+arr[right]&lt;k)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[left]+arr[right]&gt;k)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="number">0</span> || arr[left-<span class="number">1</span>]!=arr[left])&#123;</span><br><span class="line">                System.out.println(arr[left]+<span class="string">","</span>+arr[right]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="三元组的问题类似于二元组的求解过程"><a href="#三元组的问题类似于二元组的求解过程" class="headerlink" title="三元组的问题类似于二元组的求解过程"></a>三元组的问题类似于二元组的求解过程</h2><p>例如 arr=[-8,-4,-3,0,1,2,4,5,8,9] k=10<br>当三元组的第一个值为-8时，寻找-8后面的子数组中所有相加为18的不重复二元组<br>当三元组的第一个值为-4时，寻找-4后面的子数组中所有相加为14的不重复二元组<br>当三元组的第一个值为-3时，寻找-3后面的子数组中所有相加为13的不重复二元组<br>依次类推：<br>如果不重复打印？首先保证每次寻找过程开始前，选定的三元组中第一个值不重复，其次就是原问题的打印检查一样，保证不重复打印二元组<br>时间复杂度为O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUniqueTriad</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span> || arr[i]!=arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">            printRest(arr, i, i+<span class="number">1</span>, arr.length-<span class="number">1</span>, k-arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRest</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> f, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l]+arr[r]&lt;k)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[l]+arr[r]&gt;k)&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l==f+<span class="number">1</span> || arr[l-<span class="number">1</span>]!=arr[l])&#123;</span><br><span class="line">                System.out.println(arr[f]+<span class="string">","</span>+arr[l]+<span class="string">","</span>+arr[r]);</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>只用位运算不用算术运算实现整数的加减乘除运算</title>
    <url>/2020/04/10/%E7%AE%97%E6%B3%95/%E5%8F%AA%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E4%B8%8D%E7%94%A8%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E6%95%B4%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="只用位运算不用算术运算实现整数的加减乘除运算"><a href="#只用位运算不用算术运算实现整数的加减乘除运算" class="headerlink" title="只用位运算不用算术运算实现整数的加减乘除运算"></a>只用位运算不用算术运算实现整数的加减乘除运算</h1><p>给定两个32位整数a和b，可正，可负，可0，不能使用算术运算符，分别实现a和b的加减乘除运算<br>不考虑溢出</p>
<h2 id="用位运算实现加法"><a href="#用位运算实现加法" class="headerlink" title="用位运算实现加法"></a>用位运算实现加法</h2><p>如果不考虑进位，a^b就是正确结果。<br>在只算进位的情况下，也就是只考虑a加b的过程中进位产生的值是什么，结果就是(a&amp;b)&lt;&lt;1，因为在第i位只有1与1相加才会产生进位。</p>
<p>把完全不考虑进位的相加值与只考虑进位的产生值再相加，就是最终的结果，也就是说，一直重复这样的过程，直到进位产生的值完全消失，说明所有的过程都加完了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=a;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        sum = a^b;</span><br><span class="line">        b = (a&amp;b)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        a = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="用位运算实现减法运算"><a href="#用位运算实现减法运算" class="headerlink" title="用位运算实现减法运算"></a>用位运算实现减法运算</h2><p>实现a-b只要实现a+(-b)即可，根据二进制数在机器中表达的规则，得到一个数的相反数，就是这个数的二进制数表达取反加1的结果，，得到b的相反数-b后，再与a进行加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negNum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用位运算实现乘法运算"><a href="#用位运算实现乘法运算" class="headerlink" title="用位运算实现乘法运算"></a>用位运算实现乘法运算</h2><p>a&times;b的结果可以写成：a&times;2^0&times;b0+a&times;2^1&times;b1+…+a&times;2^31&times;b31<br>其中，bi为0或1代表整数b的二进制数表达中第i位的值，</p>
<p>举例：a=22=000010110，b=13=000001101，res=0<br>b的最右侧为1，所以res=res+a，同时b右移一位，a左移一位(左移一位即乘2)<br>a=000101100, b=000000110<br>b最右侧为0，所以res不变，b右移一位，a左移一位<br>a=001011000，b=000000011<br>b最右侧为1，res=res+a，同时b右移一位，a左移一位。<br>a=010110000，b=000000001<br>b最右侧为1，res=res+a，同时b右移一位，a左移一位。<br>a=101100000，b=000000000<br>此时b为0，过程停止，返回res=100011110，即286<br>不管a和b是正，负，还是0，上述过程都是对的，因为都满足a&times;2^0&times;b0+a&times;2^1&times;b1+…+a&times;2^31&times;b31</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((b&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = add(res,a);</span><br><span class="line">        &#125;</span><br><span class="line">        a &lt;&lt; =<span class="number">1</span>;</span><br><span class="line">        b &gt;&gt;&gt; = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用位运算实现除法运算，其实就是乘法的逆运算。"><a href="#用位运算实现除法运算，其实就是乘法的逆运算。" class="headerlink" title="用位运算实现除法运算，其实就是乘法的逆运算。"></a>用位运算实现除法运算，其实就是乘法的逆运算。</h2><p>其实就是找到a能包含的最大部分（指b* 2^x ）然后让a减去这个最大部分，再让剩下的a找到次大部分，并依次找下去。以上过程只适用于a和b都不是负数的时候，所以，如果a和b中有一个为负数或都为负数时，可以先把a和b转成正数，计算完后再看res的真实符号是什么就可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = isNeg(a)?negNum(a):a;</span><br><span class="line">    <span class="keyword">int</span> y = isNeg(b)?negNum(b):b;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">31</span>; i &gt; -<span class="number">1</span>; i= minus(i, <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&gt;=y)&#123;</span><br><span class="line">            res |= (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            x = minus(x, y&lt;&lt;i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNeg(a) ^ isNeg(b)?negNum(res):res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法可以计算绝大多数情况，但32位整数最小值为-2147483648，最小值的绝对值比最大值的绝对值大1，所以，如果a或b等于最小值，是转不成相应正数的，总结如下：<br>1.如果a和b都不为最小值，直接使用上述过程，返回div(a,b)<br>2.如果a和b都为最小值，a/b的结果为1，直接返回1<br>3.如果a不为最小值，b为最小值，a/b结果为0，直接 返回0<br>4.如果a为最小值，b不为最小值，只能把最小值增加一点，计算出一个结果，然后根据这个结果修正一下，得到最终结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"divisor is 0"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a==Integer.MIN_VALUE &amp;&amp; b==Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b==Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==Integer.MIN_VALUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = div(add(a, <span class="number">1</span>), b);</span><br><span class="line">        <span class="keyword">return</span> add(res, div(minus(a, multi(res, b)), b));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> div(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>找众数</title>
    <url>/2020/04/22/%E7%AE%97%E6%B3%95/%E6%89%BE%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h2 id="众数1"><a href="#众数1" class="headerlink" title="众数1"></a>众数1</h2><p>给定一个整型数组arr，打印其中出现次数大于一半的数，如果没有这样的数，打印提示信息<br>用计数器cnt来表示当前出现次数最多的数的次数，tmp表示该数，如果有满足条件的数，那么最终tmp一定是该数，因为其他的数都能被抵消</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMainNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp==arr[i])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">1</span>)&#123;</span><br><span class="line">                tmp = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp==arr[i])</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;arr.length)&#123;</span><br><span class="line">        System.out.println(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"no main number"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="众数2"><a href="#众数2" class="headerlink" title="众数2"></a>众数2</h2><p>给定一个整型数组arr， 再给定一个整数K，打印所有出现次数大于N/K的数，如果没有这样的数，打印这样的数<br>出现次数大于N/K的数至多只有 K-1个（如果有K个，那么总数一定会多于N个）<br>摩尔投票法：<br>一次在数组中删掉K个不同的数，不停地删除，直到剩下的数的种类不足K，那么，如果某些数在数组中出现次数大于N/K，则这些数最后一定会被生下来，具体过程如下：<br>遍历到arr[i]，看arr[i]是否与已经被选出的某一个候选相同。<br>如果与某一个候选相同，就把属于那个候选的点数统计+1<br>如果与所有候选都不相同，先看当前的候选是否满了，K-1就是满，否则就是不满<br>    如果不满，把arr[i]作为一个新的候选，属于它的点数初始化为1<br>    如果已满，说明此时已经发现了K个不同的数，arr[i]就是第K个，此时把每一个候选各自的点数都-1，表示每个候选需要付出一个自己的点数，如果某些候选的点数在-1后等于0，则需要删除这些候选，候选又变成不满的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findMainNumber2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="comment">//都初始化为第一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res[i] = arr[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag2 = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[j] == arr[i]) &#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">                flag1 = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res[j] = arr[i];</span><br><span class="line">                    cnt[j] = <span class="number">1</span>;</span><br><span class="line">                    flag2 = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag1 &amp;&amp; flag2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                cnt[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证res中每个数是不是确实满足条件</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = arr.length / k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        cnt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] == res[i]) &#123;</span><br><span class="line">                cnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[i] &gt; t) &#123;</span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                System.out.print(res[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(<span class="string">","</span> + res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"no main number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>未排序数组中累加和小于或等于给定值的最长子数组长度</title>
    <url>/2020/04/29/%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8E%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="未排序数组中累加和小于或等于给定值的最长子数组长度"><a href="#未排序数组中累加和小于或等于给定值的最长子数组长度" class="headerlink" title="未排序数组中累加和小于或等于给定值的最长子数组长度"></a>未排序数组中累加和小于或等于给定值的最长子数组长度</h2><p>给定一个无序数组arr，其中元素可正可负可0，给定一个整数k，求arr所有子数组中累加和小于或等于k的最长子数组长度。<br>例如：arr=[3,-2,-4,0,6], k=-2，相加和小于或等于-2的最长子数组为3,-2,-4,0 所以结果返回4<br>依次求以数组的每个位置结尾的，累加和小于或等于k的最长子数组长度，其中最长的那个子数组长度就是我们要的结果。</p>
<p>假如处理到位置30，从位置0到位置30的累加和是100（sum[0..30]=100）,现在想求以位置30结尾的、累加和小于或等于10的最长子数组长度。再假设从位置0开始累加到位置10的时候，累加和第一次大于或等于90(sum[0..10]&gt;=90)，那么可以知道以位置30结尾的相加和小于或等于10的最长子数组就是arr[11..30]。也就是说，如果从0位置到j位置的累加和为sum[0..j]，此时想求以j位置结尾的相加和小于或等于k的最长子数组长度。那么只要知道大于或等于sum[0..j]-k这个值的累加和最早出现在j之前的什么位置就可以，假设那个位置是i位置，那么arr[i+1..j]就是j位置结尾的相加和小于或等于k的最长数组。</p>
<p>由于不是具体值，而是范围值，所以不能直接用hashmap，为了方便地找到大于或等于某一个值的累加和最早出现的位置，可以按照如下方法生成辅助数组helpArr。<br>    1.首先生成arr每个位置从左到右的累加和数组sumArr。以[1,2,-1,5,-2]为例，生成的sumArr=[0,1,3,2,7,5]。注意，sumArr中第一个数为0，表示当没有任何一个数时的累加和为0.<br>    2.生成sumArr的左侧最大值数组helpArr，sumArr={0,1,3,2,7,5} -&gt; {0,1,3,3,7,7}。因为我们只关心大于或等于某个值的累加和最早出现的位置，而累加和3出现在2之前，并且大于或等于3必然大于2，所以当前要保留一个更大的、出现更早的累加和。<br>    3.helpArr是sumArr每个位置上的左侧最大值数组，那么它当然是有序的，在这样一个有序的数组中，就可以二分查找大于或等于某一个值的累加和最早出现的位置。例如，在[0,1,3,3,7,7]中查找大于或等于4这个值的位置，就是第一个7的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    h[<span class="number">0</span>] = sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=arr.length;i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        h[i+<span class="number">1</span>] = Math.max(sum, h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=arr.length;i++)&#123;</span><br><span class="line">        sum+=arr[i];</span><br><span class="line">        pre = getLessIndex(h, sum-k);</span><br><span class="line">        len = pre == -<span class="number">1</span>?<span class="number">0</span>:i-pre+<span class="number">1</span>;</span><br><span class="line">        res = Math.max(res, len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = arr.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        mid = (low+high)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&gt;=num)&#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>找到无序数组中最小的k个数</title>
    <url>/2020/04/15/%E7%AE%97%E6%B3%95/%E6%89%BE%E5%88%B0%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p>找到无序数组中最小的k个数：<br>给定一个无序的整型数组arr，找到其中最小的k个数<br>如果数组arr长度为N，排序后自然可以得到最小的k个数，此时时间复杂度与排序的时间复杂度相同，均为O(NlogN)。本题要求读者实现时间复杂度为O(Nlogk)和O(N)的方法</p>
<h2 id="O-Nlogk"><a href="#O-Nlogk" class="headerlink" title="O(Nlogk):"></a>O(Nlogk):</h2><p>一直维护有k个数的大根堆，这个堆代表目前选出的k个最小的数，在堆里的k个元素中堆顶的元素是最小的k个数里最大的那个。接下来遍历整个数组，遍历的过程中看档期数是否比堆顶元素小，如果是，就把堆顶元素替换成档期的数，然后从堆顶的位置调整整个堆，让替换操作后堆的最大元素继续处在堆顶的位置；如果不是，则不进行任何操作，继续遍历下一个数；在遍历完成后，堆中的k个数就是所有数组中最小的k个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMinKNumsByHeap(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span> || k&gt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] kHeap = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;kHeap[<span class="number">0</span>])&#123;</span><br><span class="line">            kHeap[<span class="number">0</span>] = arr[i];</span><br><span class="line">            heapify(kHeap, <span class="number">0</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kHeap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    arr[index] = value;</span><br><span class="line">    <span class="keyword">while</span>(index!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &lt; arr[index])&#123;</span><br><span class="line">            swap(arr, parent, index);</span><br><span class="line">            index = parent;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = index * <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = index * <span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> largest = index;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; heapSize)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[left] &gt; arr[index])&#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest])&#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(largest!=index)&#123;</span><br><span class="line">            swap(arr, largest, index);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = largest;</span><br><span class="line">        left = index * <span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        right = index * <span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="O-N-：BFPRT算法："><a href="#O-N-：BFPRT算法：" class="headerlink" title="O(N)：BFPRT算法："></a>O(N)：BFPRT算法：</h2><p>在时间复杂度O(n)内，从无序的数组中找到第k小的数，显而易见的是，如果我们找到了第k小的数，那么想求arr中最小的k个数，就算再遍历一遍数组的而工作量而已。<br>假设BFPRT算法的函数是int select(int[] arr, k)，该函数的功能为在arr中找到第k小的数，然后返回该数，select(arr, k)过程如下：</p>
<ol>
<li>将arr中的n个元素划分成n/5组，每组5个元素，如果最后的组不够5个元素，那么最后剩下的元素为一组(n%5个元素)。</li>
<li>对每个组进行插入排序，只针对每个组最多五个元素之间的组内排序，组与组之间并不排序，排序后找到每个组的中位数，如果组的元素个数为偶数，则规定找到下中位数</li>
<li>步骤2中一共会找到n/5个中位数，让这些中位数组成一个新的数组，记为mArr，递归调用select(mArr, mArr.length/2),意义是找到mArr这个数组中的中位数，即mArr中第mArr.length/2小的数</li>
<li>假设步骤3中递归调用select(mArr, mArr.length/2)后，返回的数为x，根据这个x划分整个arr数组（partition过程），划分的过程为：在arr中，比x小的数都在x的左边，大于x的数都在x的右边，x在中间。假设划分完成后，x在arr中的位置记为i：</li>
<li>如果i==k，说明x为整个数组中第k小的数，直接返回<br>如果i&lt; k,说明x处在第k小的数的左边，则应该在x的右边寻找第k小的数，所以递归调用select函数， 在左半区寻找第k小的数。<br>如果i&gt;k,说明x处在第k小的数的右边，应该在x的左边寻找第k小的数，所以递归调用select函数，在右半区寻找第(i-k小的数)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getMinKNumsByBFPRT(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span> || k &gt; arr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到第k小的数</span></span><br><span class="line">    <span class="keyword">int</span> minKth = getMinKthByBFPRT(arr, k);</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把所有小于minKth的数放入res中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;minKth)&#123;</span><br><span class="line">            res[index++] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不够，则说明要填充这个数</span></span><br><span class="line">    <span class="keyword">for</span>(; index!=res.length;index++)&#123;</span><br><span class="line">        res[index] = minKth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinKthByBFPRT</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> K)</span></span>&#123;</span><br><span class="line">    <span class="comment">//为了不修改原数组，在拷贝数组上操作</span></span><br><span class="line">    <span class="keyword">int</span>[] copyArr = copyArray(arr);</span><br><span class="line">    <span class="keyword">return</span> select(copyArr, <span class="number">0</span>, copyArr.length-<span class="number">1</span>, K-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=res.length;i++)&#123;</span><br><span class="line">        res[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心筛选函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin == end)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到中间数字</span></span><br><span class="line">    <span class="keyword">int</span> pivot = medianOfMedians(arr, begin, end);</span><br><span class="line">    <span class="comment">//以这个数字为枢轴，对大于他和小于他的数进行左右分开，也就是说，枢轴会被放置到它应该在的位置上</span></span><br><span class="line">    <span class="keyword">int</span>[] pivotRange = partition(arr, begin, end ,pivot);</span><br><span class="line">    <span class="comment">//如果这个枢轴就是要找的数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=pivotRange[<span class="number">0</span>] &amp;&amp; i&lt;=pivotRange[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&lt;pivotRange[<span class="number">0</span>])&#123; <span class="comment">//如果i小于这个枢轴索引，说明i对应的数应该在前面，则继续筛选</span></span><br><span class="line">        <span class="keyword">return</span> select(arr, begin, pivotRange[<span class="number">0</span>]-<span class="number">1</span>, i);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果i大于这个枢轴索引，说明i对应的数应该在后面，则继续筛选</span></span><br><span class="line">        <span class="keyword">return</span> select(arr, pivotRange[<span class="number">1</span>]+<span class="number">1</span>, end, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">medianOfMedians</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="comment">//把整个数组5个5个分为一组</span></span><br><span class="line">    <span class="keyword">int</span> num = end - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> offset = num % <span class="number">5</span> ==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//mArr是所有小区间中中间数组成的新数组</span></span><br><span class="line">    <span class="keyword">int</span>[] mArr = <span class="keyword">new</span> <span class="keyword">int</span>[num/<span class="number">5</span>+offset];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;mArr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> beginI = begin+i*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> endI = beginI + <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//mArr[i]是这个小区间内排序后的中间数</span></span><br><span class="line">        mArr[i] = getMedian(arr, beginI, Math.min(end, endI));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续进行筛选，最终找出的是整个数组中最中间的数（但是却不用把整个数组进行排序）</span></span><br><span class="line">    <span class="keyword">return</span> select(mArr, <span class="number">0</span>, mArr.length-<span class="number">1</span>, mArr.length / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对数组进行划分，即找到枢轴值的位置，并且让该值左边都是小于他，右边都是大于他</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end, <span class="keyword">int</span> pivotValue)&#123;</span><br><span class="line">    <span class="keyword">int</span> small = begin-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = begin;</span><br><span class="line">    <span class="keyword">int</span> big = end +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur!=big)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur] &lt; pivotValue)&#123;</span><br><span class="line">            swap(arr, ++small, cur++);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[cur] &gt; pivotValue)&#123;</span><br><span class="line">            swap(arr, cur, --big);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] range = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    range[<span class="number">0</span>] = small + <span class="number">1</span>;</span><br><span class="line">    range[<span class="number">1</span>] = big - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对arr进行插入排序，然后找到最中间的数，返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMedian</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    insertionSort(arr, begin, end);</span><br><span class="line">    <span class="keyword">int</span> sum = end + begin;</span><br><span class="line">    <span class="keyword">int</span> mid = (sum/<span class="number">2</span>) + (sum % <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[mid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=begin+<span class="number">1</span>; i!=end+<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j!=begin;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j-<span class="number">1</span>]&gt;arr[j])&#123;</span><br><span class="line">                swap(arr, j-<span class="number">1</span>, j);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[index1];</span><br><span class="line">    arr[index1] = arr[index2];</span><br><span class="line">    arr[index2] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>未排序数组中累加和为给定值的最长子数组系列问题</title>
    <url>/2020/04/27/%E7%AE%97%E6%B3%95/%E6%9C%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="未排序数组中累加和为给定值的最长子数组系列问题"><a href="#未排序数组中累加和为给定值的最长子数组系列问题" class="headerlink" title="未排序数组中累加和为给定值的最长子数组系列问题"></a>未排序数组中累加和为给定值的最长子数组系列问题</h2><p>给定一个无序数组arr，其中元素可正可负可0，给定一个整数k，求arr所有子数组累加和为k的最长子数组长度</p>
<p>s(i)代表子数组arr[0..i]所有元素的累加和，那么子数组arr[j..i]（0&lt;=j&lt;=i&lt; arr.length）的累加和为s(i)-s(j-1),解法：<br>1.设置变量sum=0,表示从0位置开始一直加到i位置所有元素的和，设置变量len=0，表示累加和为k的最长子数组长度，设置哈希表map，key表示从arr最左边开始累加过程中出现过的sum值，对应的value值则表示sum值最早出现的位置。<br>2.从左到右开始遍历，遍历的当前元素为arr[i].<br>    1) 令sum=sum+arr[i],即之前所有元素的累加和s(i)，在map中查看是否存在sum-k.<br>        》如果sum-k存在，从map中取出sum-k对应的value值，记为j，j代表从左到右不断累积啊的过程中第一次出现sum-k这个累加和的位置。根据之前的结论，arr[j+1..i]的累加和为s(i)-s(j)，此时s(i)=sum，又有s(j)=sum-k,所以arr[j+1..i]的累加和为k，同时因为map中只记录每一个累加和最早出现的位置，所以此时的arr[j+1..i]是必须以arr[i]结尾的所有子数组中，最长的累加和为k的子数组，如果该子数组的长度大于len，就更新len。<br>        》如果sum-k不存在，说明在必须以arr[i]结尾的情况下没有累加和为k的子数组。<br>    2）检查当前的sum(即s(i))是否在map中，如果不存在，说明此时的sum值是第一次出现<br>3.继续遍历下一个元素，直到所有元素都遍历完。</p>
<p>大体上过程如下，但还有很重要的问题，根据arr[j+1..i]的累加和为s(i)-s(j).如果从0位置开始累加，会导致j+1&gt;=1，即所有从0位置开始的子数组都没考虑过，所有应该从-1这个位置开始累加，也就是遍历前先把(0,-1)这个记录放进map，这个记录的意义是如果任何一个数也不加时，累加和为0，这样，从0位置开始的子数组就被我们考虑到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLen</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sum-k))&#123;</span><br><span class="line">            len = Math.max(i-map.get(sum-k), len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(sum))&#123;</span><br><span class="line">            map.put(sum, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="给定一个无序数组arr，其中元素可正可负可0，求arr中所有的子数组中正数与负数个数相等的最长子数组长度"><a href="#给定一个无序数组arr，其中元素可正可负可0，求arr中所有的子数组中正数与负数个数相等的最长子数组长度" class="headerlink" title="给定一个无序数组arr，其中元素可正可负可0，求arr中所有的子数组中正数与负数个数相等的最长子数组长度"></a>给定一个无序数组arr，其中元素可正可负可0，求arr中所有的子数组中正数与负数个数相等的最长子数组长度</h2><p>》方法一：<br>    如果遍历到arr[i],0到i中的正数为x个，负数为y个，若0到j中的正数为x1个，负数为y1个。假设arr[j+1..i]之间的正数与负数相等。则有x-x1=y-y1，故有x-y=x1-y1。因此如果遍历到arr[i]处，找到最前面也满足正数-负数=x-y的位置即可。<br>    因此，用一个HashMap，key为x-y，value为第一次出现该key的位置，遍历到arr[i]，如果map中有x-y，则len=max（i-map.get(x-y), len）如果没有key，则说明是第一次出现key，则把key和i放入map中</p>
<p>》方法二：<br>    用第一道题的方法，先把数组arr中的正数全变成1，负数全变成-1，0不变，然后求累加和为0的最长子数组长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLen2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;  <span class="comment">//正数个数</span></span><br><span class="line">    <span class="keyword">int</span> nag = <span class="number">0</span>;  <span class="comment">//负数个数</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">//没有数字时，看作正负个数相等，位置为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;<span class="number">0</span>) pos++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&lt;<span class="number">0</span>) nag++;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(pos-nag))&#123;</span><br><span class="line">            len = Math.max(i-map.get(pos-nag), len);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(pos-nag, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="给定一个无序数组arr，其中元素只是1或0，求arr所有子数组中0和1个数相等的最长子数组长度。"><a href="#给定一个无序数组arr，其中元素只是1或0，求arr所有子数组中0和1个数相等的最长子数组长度。" class="headerlink" title="给定一个无序数组arr，其中元素只是1或0，求arr所有子数组中0和1个数相等的最长子数组长度。"></a>给定一个无序数组arr，其中元素只是1或0，求arr所有子数组中0和1个数相等的最长子数组长度。</h2><p>》方法一：<br>    核心思想和上题一样，只不过把记录正负换成记录1和0<br>》方法二：<br>    用第一道题的方法，先把数组arr中的0全变成-1，1不变，然后求累加和为0的最长子数组长度即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLen3</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;  <span class="comment">//正数个数</span></span><br><span class="line">    <span class="keyword">int</span> zero = <span class="number">0</span>;  <span class="comment">//负数个数</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>, -<span class="number">1</span>); <span class="comment">//没有数字时，看作1和0个数相等，位置为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==<span class="number">1</span>) one++;</span><br><span class="line">        <span class="keyword">else</span> zero++;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(one-zero))&#123;</span><br><span class="line">            len = Math.max(i-map.get(one-zero), len);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(one-zero, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis中对于association的理解</title>
    <url>/2020/04/10/java/mybatis/Mybatis%E4%B8%AD%E5%AF%B9%E4%BA%8Eassociation%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>mybatis是先处理sql，把sql执行完后把结果表映射到resultMap或者resultType上</p>
<p>如下面的：</p>
<p>一个project对应一个user</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    User user;</span><br><span class="line">    ItemState state;</span><br><span class="line">    Set&lt;User&gt; signer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">project</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">    user_id <span class="built_in">int</span>,</span><br><span class="line">    state enum(<span class="string">'created'</span>, <span class="string">'planned'</span>, <span class="string">'started'</span>, <span class="string">'finished'</span>),</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innoDB</span>, <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>user表：<br>+———-+————-+——+—–+———+—————-+<br>| Field    | Type        | Null | Key | Default | Extra          |<br>+———-+————-+——+—–+———+—————-+<br>| id       | int(11)     | NO   | PRI | NULL    | auto_increment |<br>| username | varchar(20) | NO   | MUL | NULL    |                |<br>| password | varchar(18) | NO   |     | NULL    |                |<br>+———-+————-+——+—–+———+—————-+</p>
<p>当给定一个userid，要查询其对应的project及其对应的user。<br>首先如果结果集不是简单的POJO（POJO其属性不含其它bean的类型），就不能简单使用resultType，因为复杂映射映射不出来。要使用resultMap，且使用association和collection</p>
<blockquote>
<p>下面称association和collection为“复杂映射”</p>
</blockquote>
<p>所有的复杂映射都是根据结果表进行映射</p>
<p>如要使用userid去查询project及其对应的user，有以下办法：</p>
<h4 id="用法一："><a href="#用法一：" class="headerlink" title="用法一："></a>用法一：</h4><p>ProjectMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ljy.inspector.dao.ProjectDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"projectMap"</span> <span class="attr">type</span>=<span class="string">"com.ljy.inspector.entity.Project"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"state"</span> <span class="attr">property</span>=<span class="string">"state"</span> <span class="attr">typeHandler</span>=<span class="string">"com.ljy.inspector.type_handler.ItemStateHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">select</span>=<span class="string">"com.ljy.inspector.dao.UserDao.findById"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUserId"</span> <span class="attr">resultMap</span>=<span class="string">"projectMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        from project as p</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            p.user_id = #&#123;userId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ljy.inspector.dao.UserDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserMap"</span> <span class="attr">type</span>=<span class="string">"com.ljy.inspector.entity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"password"</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findById"</span> <span class="attr">resultType</span>=<span class="string">"com.ljy.inspector.entity.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user AS u</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            u.id = #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>association中嵌套select语句，这样的执行顺序是：先执行上层select找出resultMap中除了复杂映射的其他部分，默认开启部分自动映射，因此其他部分会被自动映射，除了有的映射不到，需要使用类型处理器，如ItemState。接着执行association中的select语句，并且将user_id作为参数传入findById，user_id就会被当做findById中的 #{id} (即使名字不一样，但就是这么做的)<br>这样做的话，会得到正确的结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"czxczc"</span>,</span><br><span class="line">            <span class="attr">"state"</span>: <span class="string">"CREATED"</span>,</span><br><span class="line">            <span class="attr">"user"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"username"</span>: <span class="string">"123"</span>,</span><br><span class="line">                <span class="attr">"password"</span>: <span class="string">"11111111"</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这样做相当于把查询分了两步：<br>1.在project中先select查询user_id为给定值的所有元组（行），把能自动映射或者指定了类型处理器的属性先映射到Project对象上</p>
<p>2.再根据上述元组中的user_id属性去select查询user表中id为userid中的行，并把查询结果集映射到User对象上，并且把这个User对象赋给上面的Project对象的user属性。</p>
<p>整体就是两步select，根据第一步查询出的结果的某个字段去进行第二步查询。<br>先构建出第一步查询的结果对象obj1，然后把第二步查询的结果对象obj2赋给obj1对应的属性。</p>
<p>（先得到结果表1，对其进行映射，再使用其中的某字段得到结果表2，再对结果表2进行映射，将映射结果2嵌入映射结果1的属性中。整个过程产生了两张结果表，因为有两个select）</p>
<h4 id="用法二："><a href="#用法二：" class="headerlink" title="用法二："></a>用法二：</h4><p>ProjectMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ljy.inspector.dao.ProjectDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"projectMap"</span> <span class="attr">type</span>=<span class="string">"com.ljy.inspector.entity.Project"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"state"</span> <span class="attr">property</span>=<span class="string">"state"</span> <span class="attr">typeHandler</span>=<span class="string">"com.ljy.inspector.type_handler.ItemStateHandler"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"user"</span> <span class="attr">javaType</span>=<span class="string">"com.ljy.inspector.entity.User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"u_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"username"</span> <span class="attr">property</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"base_user"</span>&gt;</span></span><br><span class="line">        p.*, u.id as u_id, u.username, u.password</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByUserId"</span> <span class="attr">resultMap</span>=<span class="string">"projectMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"base_user"</span>/&gt;</span></span><br><span class="line">        from project as p,user as u</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            p.user_id = #&#123;userId&#125;</span><br><span class="line">            and</span><br><span class="line">            u.id = #&#123;userId&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="attr">"name"</span>: <span class="literal">null</span>,</span><br><span class="line">            <span class="attr">"state"</span>: <span class="string">"CREATED"</span>,</span><br><span class="line">            <span class="attr">"user"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="attr">"username"</span>: <span class="string">"123"</span>,</span><br><span class="line">                <span class="attr">"password"</span>: <span class="literal">null</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>   这种方法是执行一次select查询，一次查询两个表，然后再对这个联合结果表进行映射，这种方式完全是按照sql的思想理念去做的，只有最后才是对联合结果表进行一次映射。<br>   <u>这种方式的resultMap会自行关闭自动映射，原因在于结果表只有一张，</u>如果两张表中有名称相同的字段，会产生歧义（如project的叫id，user的也叫id）。在sql查询中，这种情况不会有问题，结果表可以有两个列都叫id，但是对于映射来说列名是唯一标签，所以会产生歧义。所以这种情况下，要对有歧义的列名起别名，如上面的sql标签，将user中的id别名为u_id，那么最终产生的结果表中，只有一列叫id，即project.id，而user.id的这一列叫u_id，所以在association中列名叫做u_id。<br>   这样得出一张结果表后，先整体映射为指定的对象类型，再把其中要映射为属性或者需要处理的列去映射成相应的属性。而把需要映射为association的列摘出来，根据提供的对象类型把它们映射成相应的对象，赋给上层的对象的属性</p>
<p>方法二还有一种做法是指定association的resultMap属性，两者其实是一样的。本质上都是从一张结果表中取结果列取映射。</p>
<p>所以对于association需要注意的点：</p>
<p>1.如果使用了select属性，则本质上要进行两次查询，得到两张结果表，因为是从不同的表中查询（相同也无所谓）且每次只查询一个表，所以二者互不干涉，所以不存在字段歧义的问题，自动映射会开启。<br>2.如果使用resultMap属性，或者association本身当做一个resultMap，则本质是对多张表的<u>一次</u>联合查询，只产生一张结果表。然后对这张结果表一次进行映射。可能存在字段歧义问题，自动映射会关闭（如果没有指明映射关系的字段会得到空值）。此时要把产生歧义的字段起别名，并且把所有需要映射的字段都显式写出来。</p>
<p>所有的mybatis的resultMap，不管其结构有多复杂，本质都是执行完sql后对结果表再进行映射（归根结底要很清晰执行完sql语句后结果表是什么样子），其中的column的名称是结果表的column名称而不是原表的colum名称（虽然不起别名的话二者相同）。只要明确这一点，很多问题就能迎刃而解。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Mybatis解决n+1问题</title>
    <url>/2020/04/10/java/mybatis/Mybatis%E8%A7%A3%E5%86%B3n+1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>简介<br>在orm框架中，比如hibernate和mybatis都可以设置关联对象，比如user对象关联dept<br>假如查询出n个user，那么需要做n次查询dept，查询user是一次select，查询user关联的<br>dept，是n次，所以是n+1问题，其实叫1+n更为合理一些。</p>
<p>mybatis配置<br>UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"testmaven.entity.User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"age"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"age"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span> <span class="attr">property</span>=<span class="string">"deptId"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">fetchType</span>=<span class="string">"eager"</span> <span class="attr">select</span>=<span class="string">"testmaven.mapper.DeptMapper.selectByPrimaryKey"</span> &gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DeptMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByPrimaryKey"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Integer"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">select</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">from dept</span><br><span class="line"></span><br><span class="line">where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到user通过association中的dept_id关联了dept，查询user后，比如查询到4个user，那么会执行4次查询dept；</p>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.selectByExample(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>打印jdbc log我们能看到，查询到4个user，然后执行了4次查询dept<br><img src="https://img-blog.csdn.net/20180321223842327?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3cwNTk4MDU5OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="select1"></p>
<p>1+n带来的问题<br>查询主数据，是1次查询，查询出n条记录；根据这n条主记录，查询从记录，共需要n次，所以叫数据库1+n问题；这样会带来性能问题，比如，查询到的n条记录，我可能只用到其中1条，但是也执行了n次从记录查询，这是不合理的。为了解决这个问题，出现了懒加载，懒加载就是用到的时候再查询；我们设置association元素中的fetchType fetchType=lazy</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">fetchType</span>=<span class="string">"lazy"</span> <span class="attr">select</span>=<span class="string">"testmaven.mapper.DeptMapper.selectByPrimaryKey"</span> &gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">我们再做测试</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">User u = list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(u.getClass());</span><br><span class="line"></span><br><span class="line">System.out.println(u.getName());</span><br></pre></td></tr></table></figure>
<p>jdbc log<br><img src="https://img-blog.csdn.net/20160831220618291" alt="jdbc log" title="jdbc log"></p>
<p>懒加载 减少了性能消耗，一定程度上缓解了1+n带来的性能问题</p>
<blockquote>
<p>总结<br>1+n问题是什么？应该怎样解决？</p>
</blockquote>
<blockquote>
<p>1+n是执行一次查询获取n条主数据后，由于关联引起的执行n次查询从数据；它带来了性能问题；一般来说，通过懒加载 可以部分缓解1+n带来的性能问题</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis的懒加载</title>
    <url>/2020/04/10/java/mybatis/mybatis%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="MyBatis-是否支持延迟加载（懒加载）？延迟加载的原理是什么？"><a href="#MyBatis-是否支持延迟加载（懒加载）？延迟加载的原理是什么？" class="headerlink" title="MyBatis 是否支持延迟加载（懒加载）？延迟加载的原理是什么？"></a>MyBatis 是否支持延迟加载（懒加载）？延迟加载的原理是什么？</h1><p>延迟加载的原理的是调用的时候触发加载，而不是在初始化的时候就加载信息。比如调用 a. getB(). getName()，这个时候发现 a. getB() 的值为 null，此时会单独触发事先保存好的关联 B 对象的 SQL，先查询出来 B，然后再调用 a. setB(b)，而这时候再调用 a. getB(). getName() 就有值了，这就是延迟加载的基本原理。其本质是将整个查询的结果包装成一个代理，当要进行属性加载时，调用其被代理的一些方法，再从数据库中查<br>MyBatis 支持延迟加载，设置 lazyLoadingEnabled=true 即可（全局懒加载）。或者单独属性的懒加载(fetchType=lazy)</p>
<p>如果使用了config文件<br>则设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true”/&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">    ...</span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;/settings&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果是在application.properties中加载配置，则使用：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis.configuration.lazy-loading-enabled</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意，二者只能有一个！</strong></p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">注意！如果在application.properties中指定了配置文件，那就不能再在application.properties中设置任何mybatis的配置，</span><br><span class="line">也就是不能再设置任何以 “mybatis.<span class="keyword">configuration</span>.XXX” 开头的属性</span><br><span class="line">否则会报错：</span><br><span class="line"><span class="keyword">Property</span> <span class="symbol">'configuration</span>' <span class="keyword">and</span> <span class="symbol">'configLocation</span>' can <span class="keyword">not</span> specified <span class="keyword">with</span> together</span><br></pre></td></tr></table></figure>

<p>可以在resultMap中具体的association或者collection中可以用fetchType=lazy/eager 来覆盖掉全局的懒加载属性</p>
<p>对于fetchType的使用，可以不开启lazyLoadingEnabled的情况下单独使用，也是生效的，也可以在开启lazyLoadingEnabled的情况下使用，这样设置了fetchType的属性的加载策略会忽略全局的加载策略。</p>
<p>对于级联查询，就可以单独使用fetchType=lazy的方式来解决N+1的问题</p>
<p>如果设置了懒加载（不论是fetchtype还是lazyLoadingEnabled），那么实体类会产生了一个代理，代理中有一个handler属性，这个属性类没有实现序列化接口，无法被加到json中，所以需要在类上注解@JsonIgnoreProperties(value = {“handler”})来把它忽略掉<br>如果不加这个注解，会报如下错：</p>
<blockquote>
<p>Could not write JSON: No serializer found for class org.apache.ibatis.executor.loader.javassist.JavassistProxyFactory$EnhancedResultObjectProxyImpl and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS);</p>
</blockquote>
<p>有时候懒加载看起来没起作用，实际上是一些方法被暗地调用导致懒属性被加载<br>lazyLoadTriggerMethods属性可以设置当调用对象的某些方法可能会导致该对象属性的懒加载被触发，</p>
<p>默认值：equals,clone,hashCode,toString（也就是说，当调用对象的这些方法时，对象的懒属性都会被加载）<br>配置文件中加入了这个设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span> <span class="attr">value</span>=<span class="string">"”/&gt;  </span></span></span><br><span class="line"><span class="tag"><span class="string">&lt;!-- 表示调用任何方法都不会触发懒加载，除非直接调用该对象的被懒加载的属性及其方法（如A.b，或者A.b.getName() 这样） --&gt;</span></span></span><br></pre></td></tr></table></figure>

<p> 附上文档上的说明：<br>lazyLoadTriggerMethods：指定哪个对象的方法触发一次延迟加载。<br>比如，当我打印对象时，由于触发了 toString 方法，所以触发了一次懒加载，该对象的所有级联属性就会被加载</p>
<p><strong>陷阱：</strong><br>有的时候这些方法可能会被框架在无意中自动触发而导致懒属性被加载(尤其是toString和hashCode，很多时候不知道在哪就被调用了，结果看起来好像是懒加载没起作用)，所以如果不是很明确地需要触发加载的方法时，最好把lazyLoadTriggerMethods这个属性设为空，或者设置为自己能控制调用的方法。</p>
<p>关于对象转化成Json传输时懒加载不起作用的问题<br>在设置了懒加载后，在本地验证的时候，懒加载确实是起作用的，但是，当把对象转为json传输的时候，由于要调用相应属性来完成序列化，所以仍然是要对其属性进行加载的。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line">    List&lt;B&gt; b;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span> = <span class="string">A</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> …<span class="attr">property</span>=<span class="string">b</span> <span class="attr">ofType</span>=<span class="string">B</span> <span class="attr">fetchType</span>=<span class="string">lazy</span> <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>在本地跑单元测试时，可以发现a对象的b属性只要不调用，而且不去调用A对象可能会触发懒加载的方法，则b属性始终为空，除非像调用了类似a.b，即要用到相应的属性时，才会触发读数据库加载数据。但是呢，如果把对象a当做json去传输时，它的b对象也是会被加载的，因为在序列化时，会调用相应的属性及其方法，这时就会触发加载去数据库读b的数据。那么想让a对象传输时不加载且不传输b的话，解决办法如下：</p>
<p>首先是要设置懒加载，即要么开启全局的懒加载lazyLoadingEnabled”设置，要么单独对A的属性b设置fetchType=lazy<br>    在A的类上标注@JsonIgnoreProperties(value = {“handler”, “b”}) 这个意思是json序列化时要忽略掉哪些属性，首先handler是必须要忽略的，因为懒加载后对象其实是一个代理，被自动加上了handler属性，它没有实现序列化接口，所以要排除；而且把b属性给排除掉，表明序列化时会忽略b属性，那么序列化时就不会调用任何关于b的方法了。这样的话，在客户端得到的A对象中是没有b属性的，而且查看sql的调用，发现也是没有去查找B表的。</p>
<pre><code> 但要注意的是，如果不开启懒加载开关，只是设置了@JsonIgnoreProperties，那么其实相应的属性还是会被加载（即会去查相应属性的表），但查到属性后，不把它序列化到json中，所以客户端还是看不到这个属性，但事实上对于数据库来说是已经查了的。

而如果不标注忽略属性，仅仅把想要不序列化的对象设置为transient，是不起作用的，还是会被序列化，这里猜测应该是序列化为json时和普遍意义上的序列化还是有所差别的，还是对调用对应属性的方法，这样就还是会触发懒加载</code></pre>]]></content>
      <categories>
        <category>java</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>Model、ModelMap、ModelAndView的使用和区别</title>
    <url>/2020/04/13/java/spring/Model%E3%80%81ModelMap%E3%80%81ModelAndView%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在学习SSM框架中的SpringMVC时常常看到在控制层Controller中有的使用ModelAndView进行数据模型的传输，有的使用Model进行数据模型传输，为何有两种不同度类型进行传输呢？</p>
<h2 id="一-ModelAndView"><a href="#一-ModelAndView" class="headerlink" title="一.ModelAndView"></a>一.ModelAndView</h2><p>若返回类型为ModelAndView类型，需要方法结束时，定义ModelAndView,将model和view分别进行设置，代码方法如下：<br>-数据传递：ModelAndView通过addObject方法向页面传递数据；<br>-数据获取：JSP页面可以通过el表达式或C标签库的方法获取数据（与Model的获取方式相同）；<br>-return：return返回的是ModelAndView对象；</p>
<p>ModelAndView设置跳转地址有两个方式：<br>    第一种：在new ModelAndView时添加地址参数，如：<br>        ModelAndView mav = new ModelAndView(“test”);<br>    第二种：使用ModelAndView的setViewname(String)方法去设置，如：<br>　　　　　　mav.setViewName(“test”);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/products"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">products</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Product&gt; ps = productService.listProducts();</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	mav.addObject(<span class="string">"ps"</span>, ps);</span><br><span class="line">    mav.setViewName(<span class="string">"products"</span>); <span class="comment">//视图名称(视图的全名称为products.html 或 products.jsp)</span></span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤：</p>
<p>1.首先是创建ModelAndView对象，再调用addObject方法，参数一为该数据命名，参数二为传入实际数据列表</p>
<p>2.再调用setViewName方法设置jsp页面的路径，这里的地址前缀和后缀一般是定义好的（就像thymeleaf，前缀是classpath:/templates,后缀是.html, 要是设置的话，如果是springboot可以在配置文件中设置，mvc可以在web.xml中设置），可直接简写如上。如未有定义可以使用上方以注释的路径进行传入</p>
<p>3.最后返回modelAndView数据</p>
<h2 id="二-Model"><a href="#二-Model" class="headerlink" title="二.Model"></a>二.Model</h2><p>若方法返回String类型，则要使用Model,表示返回逻辑视图名，真正视图（jsp或html路径）=前缀+逻辑视图名+后缀，代码如下：</p>
<p>-数据传递：Model是通过addAttribute方法向页面传递数据的；<br>-数据获取：JSP页面可以通过el表达式或C标签库的方法获取数据，当然html页面也可以获取，具体就用thymeleaf的标签来做<br>-return：return返回的是指定的页面名称；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/products"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">products</span><span class="params">(Model m)</span> </span>&#123;</span><br><span class="line">	List&lt;Product&gt; ps = productService.listProducts();</span><br><span class="line">	m.addAttribute(<span class="string">"ps"</span>, ps);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"products"</span>;  <span class="comment">////视图名称(视图的全名称为products.html 或 products.jsp)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要步骤：</p>
<p>1.在方法括号中定义Model类型</p>
<p>2.调用addAttribute方法，参数一为给数据命名，参数二为传入上面获取到的数据</p>
<p>3.最后返回jsp页面的路径</p>
<h2 id="三-ModelMap的使用"><a href="#三-ModelMap的使用" class="headerlink" title="三.ModelMap的使用"></a>三.ModelMap的使用</h2><p>　　ModelMap的使用与Model相同，ModelMap是一种特殊的Model，一般来说，Model可以接收各种类型的数据，如果接收的数据是List，那么这个时候Model实际上是ModelMap。</p>
<h2 id="Model与ModelAndView的区别"><a href="#Model与ModelAndView的区别" class="headerlink" title="Model与ModelAndView的区别"></a>Model与ModelAndView的区别</h2><p>　　第一点：Model只是用来传输数据的，并不会进行业务的寻址。ModelAndView 却是可以进行业务寻址的；所以Model的返回值是视图名称，而ModelAndView的返回值是ModelAndView对象；</p>
<p>　　第二点：Model是每一次请求可以自动创建，但是ModelAndView 是需要我们自己去new的。所以使用Model时Controller方法的参数是Model。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>rabbitmq笔记</title>
    <url>/2020/04/10/java/rabbitmq/rabbitmq%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="》如果没有交换机，那么routekey就必须是队列名，否则通道不知道要把消息传到哪个队列中去"><a href="#》如果没有交换机，那么routekey就必须是队列名，否则通道不知道要把消息传到哪个队列中去" class="headerlink" title="》如果没有交换机，那么routekey就必须是队列名，否则通道不知道要把消息传到哪个队列中去"></a>》如果没有交换机，那么routekey就必须是队列名，否则通道不知道要把消息传到哪个队列中去</h2><h2 id="》RabbitMQ-默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。"><a href="#》RabbitMQ-默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。" class="headerlink" title="》RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。"></a>》RabbitMQ 默认将消息顺序发送给下一个消费者，这样，每个消费者会得到相同数量的消息。即轮询（round-robin）分发消息。</h2><p>假如信息a已经被发送给了消费者1，那么一定会等到信息a的ack返回后，才会把信息b发送给消费者2(即下一个消费者)，不管消费者1空闲与否或者其他消费者空闲与否，这里应该叫“轮流，顺上来”的概念<br>即默认情况下，当一个信息被发送给一个消费者，那么下一个信息一定会被发送给下一个消费者，而不是其他消费者。<br>当然，只有1个消费者时，由于它自己就是下一个消费者，那就一直是它获得消息<br>怎样才能做到按照每个消费者的能力分配消息呢？联合使用 Qos 和 Acknowledge 就可以做到。<br>basicQos 方法设置了当前信道最大预获取（prefetch）消息数量为1。消息从队列异步推送给消费者，消费者的 ack 也是异步发送给队列，从队列的视角去看，总是会有一批消息已推送但尚未获得 ack 确认，Qos 的 prefetchCount 参数就是用来限制这批未确认消息数量的。设为1时，队列只有在收到消费者发回的上一条消息 ack 确认后，才会向该消费者发送下一条消息。prefetchCount 的默认值为0，即没有限制，队列会将所有消息尽快发给消费者。</p>
<ol>
<li><p>轮询分发 ：使用任务队列的优点之一就是可以轻易的并行工作。如果我们积压了好多工作，我们可以通过增加工作者（消费者）来解决这一问题，使得系统的伸缩性更加容易。在默认情况下，RabbitMQ将逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息。这种方式分发消息机制称为Round-Robin（轮询）。</p>
</li>
<li><p>公平分发 ：虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将消息发给轮询指定的消费者。</p>
</li>
</ol>
<p>为了解决这个问题，我们使用basicQos( prefetchCount = 1)方法，来限制RabbitMQ只发不超过1条的消息给同一个消费者。当消息处理完毕后，有了反馈，才会进行第二次发送。<br>还有一点需要注意，使用非公平分发，必须关闭自动应答，改为手动应答。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同一时刻服务器只会发一条消息给消费者</span></span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启这行 表示使用手动确认模式</span></span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">同时改为手动确认：</span><br><span class="line"><span class="comment">// 监听队列，false表示手动返回完成状态，true表示自动</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">这样的话，消费快的消费者能得到更多的消息</span><br></pre></td></tr></table></figure>

<h2 id="》如果交换机设置为fanout类型，那么routekey是不会起作用的，交换机一定会把它收到的所有消息都发给所有与它绑定的队列，只有当类型为topic或direct时才会起作用"><a href="#》如果交换机设置为fanout类型，那么routekey是不会起作用的，交换机一定会把它收到的所有消息都发给所有与它绑定的队列，只有当类型为topic或direct时才会起作用" class="headerlink" title="》如果交换机设置为fanout类型，那么routekey是不会起作用的，交换机一定会把它收到的所有消息都发给所有与它绑定的队列，只有当类型为topic或direct时才会起作用"></a>》如果交换机设置为fanout类型，那么routekey是不会起作用的，交换机一定会把它收到的所有消息都发给所有与它绑定的队列，只有当类型为topic或direct时才会起作用</h2><h2 id="》消息无法由exchange路由到合适的队列的处理方法（这种情况一定是direct或topic，fanout不存在这种问题）"><a href="#》消息无法由exchange路由到合适的队列的处理方法（这种情况一定是direct或topic，fanout不存在这种问题）" class="headerlink" title="》消息无法由exchange路由到合适的队列的处理方法（这种情况一定是direct或topic，fanout不存在这种问题）"></a>》消息无法由exchange路由到合适的队列的处理方法（这种情况一定是direct或topic，fanout不存在这种问题）</h2><h3 id="》1-设置mandatory参数为true"><a href="#》1-设置mandatory参数为true" class="headerlink" title="》1.设置mandatory参数为true"></a>》1.设置mandatory参数为true</h3><pre><code>上一篇文章中我们知道，生产者将消息发送到RabbitMQ的交换器中通过RoutingKey与BindingKey的匹配将之路由到具体的队列中以供消费者消费。那么当我们通过匹配规则找不到队列的时候，消息将何去何从呢?Rabbit给我们提供了两种方式。mandatory与备份交换器。
mandatory参数是channel.BasicPublish方法中的参数。其主要功能是消息传递过程中不可达目的地时将消息返回给生产者。当mandatory 参数设为true 时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ 会调用BasicReturn 命令将消息返回给生产者。当mandatory 参数设置为false 时。则消息直接被丢弃。其运转流程与实现代码如下(以C# RabbitMQ.Client 3.6.9为例):
注意，这和死信队列没关系，死信是已经在队列中的内容过期后的处理措施，这个mandatory是交换器把这个消息路由不到任何消息队列的处理方法。</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line">String message = <span class="string">"hello world"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">"eee"</span>, <span class="string">""</span>, <span class="keyword">true</span>, properties, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">"[x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"replyCode="</span>+replyCode + <span class="string">" replyText="</span>+replyText+<span class="string">" exchange="</span>+exchange + <span class="string">" routeKey="</span>+routingKey+<span class="string">" body="</span>+<span class="keyword">new</span> String(body));  <span class="comment">//#1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">注意，由于是异步的，如果主线程先结束了，#1处的代码可能还没执行就整体结束了。</span><br></pre></td></tr></table></figure>

<h3 id="》设置备份exchange"><a href="#》设置备份exchange" class="headerlink" title="》设置备份exchange"></a>》设置备份exchange</h3><pre><code>当消息不能路由到队列时，通过mandatory设置参数,我们可以将消息返回给生产者处理。但这样会有一个问题，就是生产者需要开一个回调的函数来处理不能路由到的消息，这无疑会增加生产者的处理逻辑。备份交换器(Altemate Exchange)则提供了另一种方式来处理不能路由的消息。备份交换器可以将未被路由的消息存储在RabbitMQ中，在需要的时候去处理这些消息。其主要实现代码如下:</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">arguments.put(<span class="string">"alternate-exchange"</span>, <span class="string">"backup"</span>);</span><br><span class="line"><span class="comment">//普通交换器和普通队列</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"normal"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">channel.queueDeclare(<span class="string">"q1"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"q1"</span>, <span class="string">"normal"</span>, <span class="string">"r1"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//备份交换器和备份队列</span></span><br><span class="line">channel.exchangeDeclare(<span class="string">"backup"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">"qb"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueBind(<span class="string">"qb"</span>, <span class="string">"backup"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">channel.basicPublish(<span class="string">"normal"</span>, <span class="string">""</span>, <span class="keyword">null</span>, <span class="string">"abcdef"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p>备份交换器其实和普通的交换器没有太大的区别，为了方便使用，建议设置为fanout类型，若设置为direct 或者topic的类型。需要注意的是，消息被重新发送到备份交换器时的路由键和从生产者发出的路由键是一样的。考虑这样一种情况，如果备份交换器的类型是direct,并且有一个与其绑定的队列，假设绑定的路由键是key1，当某条携带路由键为key2 的消息被转发到这个备份交换器的时候，备份交换器没有匹配到合适的队列，则消息丢失。如果消息携带的路由键为key1，则可以存储到队列中。<br>对于备份交换器，有以下几种特殊情况:</p>
<ul>
<li>如果设置的备份交换器不存在，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器没有绑定任何队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器没有任何匹配的队列，客户端和RabbitMQ 服务端都不会有异常出现，此时消息会丢失。</li>
<li>如果备份交换器和mandatory参数一起使用，那么mandatory参数无效。</li>
</ul>
<h2 id="》设置消息的TTL："><a href="#》设置消息的TTL：" class="headerlink" title="》设置消息的TTL："></a>》设置消息的TTL：</h2><pre><code>目前有两种方法可以设置消息的TTL。第一种方法是通过队列属性设置，队列中所有消息都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的TTL可以不同。如果两种方法一起使用，则消息的TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间一旦超过设置的TTL值时，就会变成&quot;死信&quot; (Dead Message) ，消费者将无法再收到该消息。(有关死信队列请往下看)</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：给队列参数上加上x-message-ttl属性，这样所有进入该队列的消息都会有统一的过期时间</span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>);</span><br><span class="line">arguments.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"eee"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">方法二：给消息上加上属性：</span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">                .expiration(<span class="string">"20000"</span>) <span class="comment">//表示20000ms</span></span><br><span class="line">                .build();</span><br><span class="line">        String message = <span class="string">"hello world"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">"eee"</span>, <span class="string">""</span>, properties, message.getBytes());</span><br></pre></td></tr></table></figure>
<p>注意:对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。Why?在第一种方法里，队列中己过期的消息肯定在队列头部， RabbitMQ 只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</p>
<h2 id="》设置队列的TTL"><a href="#》设置队列的TTL" class="headerlink" title="》设置队列的TTL"></a>》设置队列的TTL</h2><pre><code>注意，这里和上述通过队列设置消息的TTL不同。上面删除的是消息，而这里删除的是队列。通过channel.queueDeclare 方法中的x-expires参数可以控制队列被自动删除前处于未使用状态的时间。这个未使用的意思是队列上没有任何的消费者，队列也没有被重新声明，并且在过期时间段内也未调用过channel.basicGet命令。
设置队列里的TTL可以应用于类似RPC方式的回复队列，在RPC中，许多队列会被创建出来，但是却是未被使用的(有关RabbitMQ实现RPC请往下看)。RabbitMQ会确保在过期时间到达后将队列删除，但是不保障删除的动作有多及时。在RabbitMQ 重启后， 持久化的队列的过期时间会被重新计算。用于表示过期时间的x-expires参数以毫秒为单位， 井且服从和x-message-ttl一样的约束条件，不同的是它不能设置为0(会报错)。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line">arguments.put(<span class="string">"x-expires"</span>, <span class="number">2000</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"eee"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br></pre></td></tr></table></figure>

<h2 id="》死信队列"><a href="#》死信队列" class="headerlink" title="》死信队列"></a>》死信队列</h2><pre><code>DLX(Dead-Letter-Exchange)死信交换器，当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX ，绑定DLX的队列就称之为死信队列。</code></pre><p>消息变成死信主要有以下几种情况:</p>
<ul>
<li>消息被拒绝(BasicReject/BasicNack) ，井且设置requeue 参数为false;</li>
<li>消息过期;</li>
<li>队列达到最大长度。<br>  DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ 就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息、以进行相应的处理。<br>  通过在channel.queueDeclare 方法中设置x-dead-letter-exchange参数来为这个队列添加DLX。其示例代码如下:</li>
</ul>
<h2 id="》对于队列参数的设置，map的内容必须是在声明队列之前就有了，不能设置了arguments后再往map中放东西"><a href="#》对于队列参数的设置，map的内容必须是在声明队列之前就有了，不能设置了arguments后再往map中放东西" class="headerlink" title="》对于队列参数的设置，map的内容必须是在声明队列之前就有了，不能设置了arguments后再往map中放东西"></a>》对于队列参数的设置，map的内容必须是在声明队列之前就有了，不能设置了arguments后再往map中放东西</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//死信队列配置  ----------------</span></span><br><span class="line">String dlxExchangeName = <span class="string">"dlx.exchange"</span>;</span><br><span class="line">String dlxQueueName = <span class="string">"dlx.queue"</span>;</span><br><span class="line">String dlxRoutingKey = <span class="string">"#"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为队列设置队列交换器</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>, dlxExchangeName); <span class="comment">//只能设置死信交换器，不能直接把死信队列与其他队列绑定</span></span><br><span class="line"><span class="comment">// 设置队列中的消息 3s 钟后过期</span></span><br><span class="line">arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">3000</span>);</span><br><span class="line">channel.exchangeDeclare(<span class="string">"eee"</span>, <span class="string">"fanout"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);  </span><br><span class="line"><span class="comment">//给arguments中设置内容不能放在这句后面不然参数不起作用</span></span><br><span class="line">channel.queueBind(QUEUE_NAME, <span class="string">"eee"</span>, <span class="string">"”);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 创建死信交换器和队列</span></span><br><span class="line"><span class="string">channel.exchangeDeclare(dlxExchangeName, "</span>topic<span class="string">", true, false, null);</span></span><br><span class="line"><span class="string">channel.queueDeclare(dlxQueueName, true, false, false, null);</span></span><br><span class="line">channel.queueBind(dlxQueueName, dlxExchangeName, "#");</span><br></pre></td></tr></table></figure>

<h3 id="》必须有一个交换器与之绑定。死信队列一定要持久化，但设置死信队列的队列不一定要持久化"><a href="#》必须有一个交换器与之绑定。死信队列一定要持久化，但设置死信队列的队列不一定要持久化" class="headerlink" title="》必须有一个交换器与之绑定。死信队列一定要持久化，但设置死信队列的队列不一定要持久化**"></a>》必须有一个交换器与之绑定。死信队列一定要持久化，但设置死信队列的队列不一定要持久化**</h3><p>死信队列和死信交换器的声明和普通队列，交换器没什么区别（除了一定要持久化），表明它是死信交换器的位置是把它的名字设置为一个其他队列的“x-dead-letter-exchange” 参数 </p>
<h3 id="》可以用过期队列-死信队列-来模拟延迟队列"><a href="#》可以用过期队列-死信队列-来模拟延迟队列" class="headerlink" title="》可以用过期队列+死信队列 来模拟延迟队列**"></a>》可以用过期队列+死信队列 来模拟延迟队列**</h3><pre><code>生产者将消息发送到过期时间为n的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器被转发到死信队列中。而消费者从死信队列中消费消息。这个时候就达到了生产者发布了消息在讲过了n时间后消费者消费了消息，起到了延迟消费的作用。
 延迟队列在我们的项目中可以应用于很多场景，如：下单后两个消息取消订单，七天自动收货，七天自动好评，密码冻结后24小时解冻，以及在分布式系统中消息补偿机制(1s后补偿,10s后补偿，5m后补偿......)。</code></pre><h2 id="》优先级队列"><a href="#》优先级队列" class="headerlink" title="》优先级队列:"></a>》优先级队列:</h2><p>  就像我们生活中的“特殊”人士一样，我们的业务上也存在一些“特殊”消息，可能需要优先进行处理，在生活上我们可能会对这部分特殊人士开辟一套VIP通道，而Rabbit同样也有这样的VIP通道(前提是在3.5的版本以后)，即优先级队列，队列中的消息会有优先级。优先级高的消息具备优先被消费的特权。针对这些VIP消息，我们只需做两件事:<br>我们只需做两件事情：<br>    1.将队列声明为优先级队列，即在创建队列的时候添加参数 x-max-priority 以指定最大的优先级，值为0-255（整数）。<br>    2.为优先级消息添加优先级。<br>其示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.exchangeDeclare(<span class="string">"exchange.priority"</span>, <span class="string">"direct"</span>, <span class="keyword">true</span>);<span class="comment">//定义交换器</span></span><br><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 为队列设置队列交换器</span></span><br><span class="line">arguments.put(<span class="string">"x-dead-letter-exchange"</span>, dlxExchangeName);</span><br><span class="line"><span class="comment">// 设置队列中的消息 ms 钟后过期</span></span><br><span class="line">arguments.put(<span class="string">"x-message-ttl"</span>, <span class="number">10000</span>);</span><br><span class="line">arguments.put(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);args.Add(<span class="string">"x-max-priority"</span>, <span class="number">10</span>);<span class="comment">//定义优先级队列的最大优先级为10</span></span><br><span class="line">channel.queueDeclare(<span class="string">"queue.priority"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, args);<span class="comment">//定义优先级队列</span></span><br><span class="line">channel.queueBind(<span class="string">"queue.priority"</span>, <span class="string">"exchange.priority"</span>, <span class="string">"priorityKey"</span>);<span class="comment">//队列交换器绑定</span></span><br><span class="line">AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .priority(<span class="number">8</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="keyword">var</span> message = “testMsg8<span class="string">";</span></span><br><span class="line"><span class="string">//发布消息</span></span><br><span class="line"><span class="string">channel.BasicPublish("</span>exchange.priority<span class="string">", "</span>priorityKey<span class="string">", properties, message);</span></span><br></pre></td></tr></table></figure>
<p>注意：没有指定优先级的消息会将优先级以0对待。 对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待。对于相同优先级的消息，后进的排在前面。如果在消费者的消费速度大于生产者的速度且Broker 中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker 中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。<br>    关于优先级队列，好像违背了队列这种数据结构先进先出的原则，其具体是怎么实现的在这里就不过多讨论。</p>
<p>何时创建队列<br>    从前面的文章我们知道，RabbitMQ可以选择在生产者创建队列，也可以在消费者端创建队列，也可以提前创建好队列，而生产者消费者直接使用即可。<br>    RabbitMQ的消息存储在队列中，交换器的使用并不真正耗费服务器的性能，而队列会。如在实际业务应用中，需要对所创建的队列的流量、内存占用及网卡占用有一个清晰的认知，预估其平均值和峰值，以便在固定硬件资源的情况下能够进行合理有效的分配。<br>    按照RabbitMQ官方建议，生产者和消费者都应该尝试创建(这里指声明操作)队列。这虽然是一个很好的建议，但是在我看来这个时间上没有最好的方案，只有最适合的方案。我们往往需要结合业务、资源等方面在各种方案里面选择一个最适合我们的方案。<br>    如果业务本身在架构设计之初己经充分地预估了队列的使用情况，完全可以在业务程序上线之前在服务器上创建好(比如通过页面管理、RabbitMQ命令或者更好的是从配置中心下发)，这样业务程序也可以免去声明的过程，直接使用即可。预先创建好资源还有一个好处是，可以确保交换器和队列之间正确地绑定匹配。很多时候，由于人为因素、代码缺陷等，发送消息的交换器并没有绑定任何队列，那么消息将会丢失:或者交换器绑定了某个队列，但是发送消息时的路由键无法与现存的队列匹配，那么消息也会丢失。当然可以配合mandatory参数或者备份交换器(关于mandatory参数的使用详细可参考我的上一篇文章) 来提高程序的健壮性。与此同时，预估好队列的使用情况非常重要，如果在后期运行过程中超过预定的阈值，可以根据实际情况对当前集群进行扩容或者将相应的队列迁移到其他集群。迁移的过程也可以对业务程序完全透明。此种方法也更有利于开发和运维分工，便于相应资源的管理。如果集群资源充足，而即将使用的队列所占用的资源又在可控的范围之内，为了增加业务程序的灵活性，也完全可以在业务程序中声明队列。至于是使用预先分配创建资源的静态方式还是动态的创建方式，需要从业务逻辑本身、公司运维体系和公司硬件资源等方面考虑。<br>也就是说，如果预先创建好了队列或者交换器，就不用再queueDeclare或exchangeDeclare了，直接用即可。</p>
<h2 id="》持久化策略"><a href="#》持久化策略" class="headerlink" title="》持久化策略"></a>》持久化策略</h2><p>持久化及策略#<br>    作为一个内存中间件，在保证了速度的情况下，不可避免存在如内存数据库同样的问题，即丢失问题。持久化可以提高RabbitMQ 的可靠性，以防在异常情况(重启、关闭、宕机等)下的数据丢失。RabbitMQ的持久化分为三个部分:交换器的持久化、队列的持久化和消息的持久化。</p>
<ol>
<li>交换器的持久化<br> 交换器的持久化是通过在声明队列是将durable 参数置为true 实现的(该参数默认为false)。如果交换器不设置持久化，那么在RabbitMQ 服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。</li>
<li>队列的持久化<br> 队列的持久化是通过在声明队列时将durable 参数置为true 实现的(该参数默认为false)，如果队列不设置持久化，那么在RabbitMQ 服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。正所谓”皮之不存，毛将焉附”，队列都没有了，消息又能存在哪里呢?</li>
<li>消息的持久化<br> 队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式(BasicProperties中的DeliveryMode属性)设置为2即可实现消息的持久化。<br> 因此，消息如果要想在Rabbit重启、关闭、宕机时能够恢复，需要做到以下三点:</li>
</ol>
<ul>
<li>把消息的投递模式设置为2</li>
<li>发送到持久化的交换器</li>
<li>到达持久化的队列<br>  注意:RabbitMQ 确保持久化消息能从服务器重启中恢复的方式是将它们写入磁盘上的一个持久化日志文件中。当发布一条持久化消息到持久化交换器时，Rabbit会在日志提交到日志文件后才发送响应(开启生产者确认机制)。之后，如果消息到了非持久化队列，它会自动从日志文件中删除，并且无法在服务器重启后恢复。因此单单只设置队列持久化，重启之后消息会丢失;单单只设置消息的持久化，重启之后队列消失，继而消息也丢失。单单设置消息持久化而不设置队列的持久化是毫无意义的。当从持久化队列中消费了消息后(并且确认后)，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。而在消费持久化消息之前，若RabbitMQ服务器重启，会自动重建交换器、队列以及绑定，重播持久化日志文件中的消息到合适的队列或者交换器上(取决于宕机时，消息处在路由的哪个环节)。<br>  为了保障消息不会丢失，也许我们可以简单粗暴的将所有的消息标记为持久化，但这样我们会付出性能的代价。写入磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。<br>  将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗?</li>
<li>从消费者来说，如果在订阅消费队列时将noAck参数设置为true ，那么当消费者接收到相关消息之后，还没来得及处理就宕机了，这样也算数据丢失。</li>
<li>在持久化的消息正确存入RabbitMQ 之后，还需要有一段时间(虽然很短，但是不可忽视〉才能存入磁盘之中。RabbitMQ 并不会为每条消息都进行同步存盘的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将会丢失。<br>  关于第一个问题，可以通过消费者确认机制来解决。而第二个问题可以通过生产者确认机制来解决，也可以使用镜像队列机制(镜像队列机制，将在运维篇总结)。生产者确认消费者确认请往下看。</li>
</ul>
<h2 id="》生产者确认机制"><a href="#》生产者确认机制" class="headerlink" title="》生产者确认机制"></a>》生产者确认机制</h2><pre><code>上文我们知道，在使用RabbitMQ的时候，可以通过消息持久化操作来解决因为服务器的异常崩溃而导致的消息丢失，除此之外，我们还会遇到一个问题，当消息的生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢?如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，也就是默认情况下生产者是不知道消息有没有正确地到达服务器。如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达服务器，何谈持久化?
RabbitMQ针对这个问题，提供了两种解决方式:</code></pre><ul>
<li>通过事务机制实现:</li>
<li>通过发送方确认(publisher confirm)机制实现。</li>
</ul>
<h3 id="1-RabbitMQ-事务机制"><a href="#1-RabbitMQ-事务机制" class="headerlink" title="1.RabbitMQ 事务机制#"></a>1.RabbitMQ 事务机制#</h3><pre><code>RabbitMQ 客户端中与事务机制相关的方法有三个:channel.txSelect(用于将当前信道设置为事务模式);channel.txCommit(用于提交事务)，channel.txRollback(用于回滚事务)。在通过channel.txSelect方法开启事务之后，我们便可以发布消息给RabbitMQ了，如果事务提交成功，则消息一定到达了RabbitMQ 中，如果在事务提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行channel.txRollback方法来实现事务回滚。示例代码如下所示:（如果在事务提交后异常，则就算执行rollback也不能回滚了）</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.basicPublish(<span class="string">"eee"</span>, <span class="string">"r1"</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">"dasd12*(!@*#!"</span>.getBytes());</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(<span class="string">"rollback"</span>);</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>事务确实能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚，与此同时可以进行消息重发。但是使用事务同样会带来一些问题。</code></pre><ul>
<li>会阻塞，发布者必须等待broker处理每个消息。</li>
<li>事务是重量级的，每次提交都需要fsync()，需要耗费大量的时间</li>
<li>事务非常耗性能，会降低RabbitMQ的消息吞吐量。</li>
</ul>
<h3 id="2-发送方确认机制"><a href="#2-发送方确认机制" class="headerlink" title="2.发送方确认机制#"></a>2.发送方确认机制#</h3><pre><code>前面介绍了RabbitMQ可能会遇到的一个问题，即消息发送方(生产者〉并不知道消息是否真正地到达了RabbitMQ。随后了解到在AMQP协议层面提供了事务机制来解决这个问题，但是采用事务机制实现会严重降低RabbitMQ的消息吞吐量，这里就引入了一种轻量级的方式一发送方确认(publisher confirm)机制。生产者将信道设置成confirm确认)模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID( 从1开始)，一旦消息被投递到所有匹配的队列之后（或者是没有合适的队列而被丢弃。总之是消息确确实实到了rabbitmq上），RabbitMQ就会发送一个确认(BasicAck) 给生产者(包含消息的唯一ID)，这就使得生产者知晓消息已经正确到达了目的地了。（注意，一旦消息到了rabbitmq(即到了队列或者被丢弃)就返回确认，而不是等到被消费）如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">》同步方法：</span><br><span class="line">channel.confirmSelect();   <span class="comment">//一定要写明这句，表示将信道设置为确认模式，否则会报错：Confirms not selected</span></span><br><span class="line">String message = <span class="string">"qazwsx"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">"eee"</span>, <span class="string">""</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line"><span class="keyword">boolean</span> result = channel.waitForConfirms();</span><br><span class="line"><span class="keyword">if</span>(result)&#123;</span><br><span class="line">    System.out.println(<span class="string">"arrived"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"no way"</span>);</span><br><span class="line">&#125;</span><br><span class="line">》异步方法：</span><br><span class="line">channel.confirmSelect();   <span class="comment">////一定要写明这句，表示将信道设置为确认模式，否则confrimListener的ack/nack方法不会被调用</span></span><br><span class="line">String message = <span class="string">"qazwsx"</span>;</span><br><span class="line">channel.basicPublish(<span class="string">"eee"</span>, <span class="string">"r1"</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"arrived"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"no way"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<pre><code>关于生产者确认机制同样会有一些问题，broker（也就是rabbitmq系统，exchange和queue等的统称）不能保证消息会被confirm，只知道将会进行confirm。这样如果broker与生产者之间的连接断开，导致生产者不能收到确认消息，可能会重复进行发布。总之，生产者确认模式给客户端提供了一种较为轻量级的方式，能够跟踪哪些消息被broker处理，哪些可能因为broker宕掉或者网络失败的情况而重新发布。
注意:事务机制和publisher confirm机制两者是互斥的，不能共存。如果企图将已开启事务模式的信道再设置为publisher confirm模式， RabbitMQ会报错,或者如果企图将已开启publisher confirm模式的信道设置为事务模式， RabbitMQ也会报错。在性能上来看，而到底应该选择事务机制还是Confirm机制，则需要结合我们的业务场景。</code></pre><h2 id="》消费者确认机制"><a href="#》消费者确认机制" class="headerlink" title="》消费者确认机制"></a>》消费者确认机制</h2><p>由于生产者和消费者不直接通信,生产者只负责把消息发送到队列,消费者只负责从队列获取消息(不管是push还是pull)。<br>消息被”消费”后,是需要从队列中删除的.那怎么确认消息被”成功消费”了呢?<br>是消费者从队列获取到消息后,broker 就从队列中删除该消息?<br>那如果消费者收到消息后,还没来得及”消费”它,或者说还没来得及进行业务逻辑处理时,消费者所在的信道或者连接因某种原因断开了,那这条消息岂不是就被无情的抛弃了…<br>我们更期望的是,消费者从队列获取到消息后,broker 暂时不删除该条消息,等到消费者”成功消费”掉该消息后,再删除它。<br>所以需要一个机制来确认生产者发送的消息被消费者”成功消费”。<br>RabbitMQ 提供了一种叫做”消费者确认”的机制.<br>    如上，消费者在消费消息的同时，Rabbit会同步给予消费者一个DeliveryTag，这个DeliveryTag就像我们数据库中的主键，消费者在消费完毕后拿着这个DeliveryTag去Rabbit确认或拒绝这个消息。<br>消费者确认<br>消费者确认分两种:自动确认和手动确认.<br>在自动确认模式中,消息在发送到消费者后即被认为”成功消费”.这种模式可以降低吞吐量（只要消费者可以跟上）,以降低交付和消费者处理的安全性.这种模式通常被称为“即发即忘”.与手动确认模型不同,如果消费者的TCP连接或通道在真正的”成功消费”之前关闭,则服务器发送的消息将丢失.因此,自动消息确认应被视为不安全,并不适用于所有工作负载.   channel.basicConsume(QUEUE_NAME, true, consumer); //第二个参数是autoAck，为true则证明开启自动确认。<br>使用自动确认模式时需要考虑的另一件事是消费者过载.手动确认模式通常与有界信道预取(BasicQos方法)一起使用,该预取限制了信道上未完成（“进行中”）的消息的数量.但是,自动确认没有这种限制.因此,消费者可能会被消息的发送速度所淹没,可能会导致消息积压并耗尽堆或使操作系统终止其进程.某些客户端库将应用TCP反压(停止从套接字读取,直到未处理的交付积压超过某个限制).因此,仅建议能够以稳定的速度有效处理消息的消费者使用自动确认模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueueingConsumer consumer = <span class="keyword">new</span> QueueingConsumer(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动确认：</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//手动确认：拉模式：只有当broker收到消费确认后，才从队列中删除这一条消息。</span></span><br><span class="line">channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">channel.basicQos(<span class="number">1</span>);</span><br><span class="line">QueueingConsumer.Delivery delivery = consumer.nextDelivery();</span><br><span class="line">String message = <span class="keyword">new</span> String(delivery.getBody());</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="keyword">false</span>); <span class="comment">//发出消费者确认</span></span><br><span class="line">basicAck(deliveryTag, multiple):</span><br><span class="line">第一个参数deliveryTag</span><br><span class="line">    就是接受的消息的deliveryTag,可以通过delivery.getEnvelope().getDeliveryTag()获得</span><br><span class="line">第二个参数 multiple</span><br><span class="line">    如果为<span class="keyword">true</span>，确认之前接受到的消息；如果为<span class="keyword">false</span>，只确认当前消息。</span><br><span class="line">    如果为<span class="keyword">true</span>就表示连续取得多条消息才发会确认，和计算机网络的中tcp协议接受分组的累积确认十分相似，能够提高效率。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicReject</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> requeue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple, <span class="keyword">boolean</span> requeue)</span></span>;</span><br><span class="line">* deliveryTag:可以看作消息的编号，它是一个<span class="number">64</span>位的长整型值，最大值是<span class="number">9223372036854775807</span>。</span><br><span class="line">* requeue:如果requeue 参数设置为<span class="keyword">true</span>，则RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者;如果requeue 参数设置为<span class="keyword">false</span>，则RabbitMQ立即会把消息从队列中移除，而不会把它发送给新的消费者。</span><br><span class="line">* BasicReject命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用Basic.Nack这个命令。</span><br><span class="line">* multiple:在BasicAck中，multiple 参数设置为<span class="keyword">true</span> 则表示确认deliveryTag编号之前所有已被当前消费者确认的消息。在BasicNack中，multiple 参数设置为<span class="keyword">true</span> 则表示拒绝deliveryTag 编号之前所有未被当前消费者确认的消息。</span><br><span class="line">说明:将channel.BasicReject 或者channel.BasicNack中的requeue设置为<span class="keyword">false</span> ，可以启用<span class="string">"死信队列"</span>的功能。</span><br><span class="line">上述requeue，都会将消息重新存入队列发送给下一个消费者(也有可能是其它消费者)。关于requeue还有下面一种用法。可以选择是否补发给当前的consumer。</span><br><span class="line"><span class="comment">//补发消息 true退回到queue中 /false只补发给当前的consumer</span></span><br><span class="line">channel.basicRecover(<span class="keyword">true</span>);</span><br><span class="line">    注意：RabbitMQ仅仅通过Consumer的连接中断来确认该Message并没有被正确处理。也就是说，RabbitMQ给了Consumer足够长的时间来做数据处理。如果忘记了ack，那么后果很严重。当Consumer退出时，Message会重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，这个“内存泄漏”是致命的。</span><br></pre></td></tr></table></figure>

<h2 id="》消息传输保障"><a href="#》消息传输保障" class="headerlink" title="》消息传输保障"></a>》消息传输保障</h2><p>消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题，一般消息中间件的消息传输保障分为三个层级。</p>
<ul>
<li>At most once: 最多一次。消息可能会丢失，但绝不会重复传输。</li>
<li>At least once: 最少一次。消息绝不会丢失，但可能会重复传输。</li>
<li>Exactly once: 恰好一次。每条消息肯定会被传输一次且仅传输一次。<br>  RabbitMQ 支持其中的”最多一次”和”最少一次”。其中”最少一次”投递实现需要考虑以下这个几个方面的内容:</li>
</ul>
<ol>
<li>消息生产者需要开启事务机制或者publisher confirm 机制，以确保消息可以可靠地传输到RabbitMQ 中。</li>
<li>消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。</li>
<li>消息和队列都需要进行持久化处理，以确保RabbitMQ服务器在遇到异常情况时不会造成消息丢失。</li>
<li>消费者在消费消息的同时需要将autoAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。<br> “最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这样很难确保消息不会重复消费。<br> “恰好一次”是RabbitMQ目前无法保障的(目前我也不知道哪个中间件能够保证)。消费者在消费完一条消息之后向RabbitMQ 发送确认BasicAck命令，此时由于网络断开或者其他原因造成RabbitMQ并没有收到这个确认命令，那么RabbitMQ不会将此条消息标记删除。在重新建立连接之后，消费者还是会消费到这一条消息，这就造成了重复消费。再考虑一种情况，生产者在使用publisher confirm机制的时候，发送完一条消息等待RabbitMQ 返回确认通知，此时网络断开，生产者捕获到异常情况，为了确保消息可靠性选择重新发送，这样RabbitMQ中就有两条同样的消息，在消费的时候，消费者就会重复消费。而解决重复消费可以通过消费者幂等等方式来解决。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
        <category>rabbitmq</category>
      </categories>
  </entry>
  <entry>
    <title>springboot 静态资源无法访问以及添加静态资源无法立即访问</title>
    <url>/2020/04/10/java/spring/springboot%20%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E7%AB%8B%E5%8D%B3%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="springboot-静态资源无法访问"><a href="#springboot-静态资源无法访问" class="headerlink" title="springboot 静态资源无法访问"></a>springboot 静态资源无法访问</h2><blockquote>
<p>在一个项目中WebMvcConfigurationSupport只能存在一个，多个的时候，只有一个会生效。（按名称排序后第一个的）</p>
</blockquote>
<p>1.SpringBoot 的 @EnableAutoConfiguration 会启用自动配置类 </p>
<p>2.WebMvcAutoConfiguration，该类配置了一些默认的静态资源映射</p>
<ul>
<li>自动映射 localhost:8080/** 为以下路径<pre><code>classpath:/resources/
classpath:/static/
classpath:/public/
classpath:/META-INF/resources/</code></pre><ol start="2">
<li>自动映射 localhost:8080/webjars/** 为以下路径<br> classpath:/META-INF/resources/webjars/</li>
</ol>
</li>
</ul>
<p>此时，我们不需要多做什么，只要将静态资源放入 src/main/resources 目录下的 resources、static 或 public 文件夹下，即可通过 url 定位相关资源，例如 localhost:8080/index.html 可定位至 src/main/resources/static/index.html</p>
<p><strong>但是！</strong><br>一旦使用继承了WebMvcConfigurationSupport或者WebMvcConfigurerAdapter的自定义配置类，即使没有重写addResourceHandlers方法，默认配置都会被不被采用。如果要采用原本默认的配置，则需要webmvc配置类中重写如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoWebMvcConfigurerAdapter</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置静态资源处理</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">"/**"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"resources/"</span>, <span class="string">"static/"</span>, <span class="string">"public/"</span>, </span><br><span class="line">                <span class="string">"META-INF/resources/"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:resources/"</span>, <span class="string">"classpath:static/"</span>, </span><br><span class="line">                <span class="string">"classpath:public/"</span>, <span class="string">"classpath:META-INF/resources/"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"file:///tmp/webapps/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过试验得证：如果不使用WebMvcConfigurationSupport，则使用application.properties中的默认配置<br>如果重写了application.properties中的配置，则使用重写后的配置，如：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations=resources<span class="regexp">/, static/</span>, <span class="keyword">public</span><span class="regexp">/, \ META-INF/</span>resources<span class="regexp">/, resources/</span>, <span class="keyword">classpath</span>:<span class="keyword">static</span><span class="regexp">/, public/</span>, <span class="keyword">classpath</span>:META-INF<span class="regexp">/resources/</span>, \<span class="keyword">file</span>:<span class="comment">///tmp/webapps/</span></span><br><span class="line"></span><br><span class="line">spring.mvc.<span class="keyword">static</span>-path-pattern=<span class="comment">/**</span></span><br></pre></td></tr></table></figure>

<p>一旦使用了WebMvcConfigurationSupport（或WebMvcConfigurerAdapter）那么必须要重写addResourceHandlers来配置资源映射，此时application.properties中关于静态资源访问的配置将失效（除非对url写了响应的controller来处理，那是另一回事）</p>
<h2 id="当添加了静态资源后，无法立即访问的问题"><a href="#当添加了静态资源后，无法立即访问的问题" class="headerlink" title="当添加了静态资源后，无法立即访问的问题"></a>当添加了静态资源后，无法立即访问的问题</h2><p>如果访问项目中的静态资源，访问的所有的东西其实都是target目录中的，这是经过编译的，如果对项目目录下的静态资源进行修改（增删改），由于target下的东西没有受影响，所以没法立即生效，比如往/resouces/static下增加一张图片，通过url无法立即访问到，必须重启项目。其实重启就是让资源文件经过编译（其实资源文件根本不编译）后，加到target中，那么这样就很麻烦，要是想对一个静态资源修改后能立即通过url访问到要如何做呢？<br>解决办法将静态资源放在非项目类路径下即可，例如 “file:///Users/mytest/inspector/independent_resources/“);，并且在资源处理器中加上路径即可。<br>file:// 后面跟的必须是文件系统的绝对路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(<span class="string">"/**”)</span></span><br><span class="line"><span class="string">//**********/</span></span><br><span class="line"><span class="string">        .addResourceLocations("</span>resources/<span class="string">", "</span><span class="keyword">static</span>/<span class="string">", "</span><span class="keyword">public</span>/<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>META-INF/resources/<span class="string">")</span></span><br><span class="line"><span class="string">        .addResourceLocations("</span>classpath:resources/<span class="string">", "</span>classpath:<span class="keyword">static</span>/<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>classpath:<span class="keyword">public</span>/<span class="string">", "</span>classpath:META-INF/resources/<span class="string">")</span></span><br><span class="line"><span class="string">//**********/</span></span><br><span class="line"><span class="string">        //如果要让添加的静态资源立即生效，则不能把它放到项目资源里面，应该放在外面，比如下面的目录</span></span><br><span class="line"><span class="string">        //这样一旦静态资源添加到这个目录，则直接从该位置获取，而不是从编译的target位置获取</span></span><br><span class="line"><span class="string">        .addResourceLocations("</span>file:<span class="comment">///Users/mytest/inspector/independent_resources/");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********之间的是项目类的路径，不用管，最下面的是非项目类的路径</span></span><br><span class="line"><span class="comment">这样的话，在项目运行时，往/Users/mytest/inspector/independent_resources/目录下添加一个111.png后，在浏览器中通过localhost:8080/111.png就可访问到这个图片了。</span></span><br><span class="line"><span class="comment">如果不添加这个，在项目运行时，往项目的src/main/resources 下添加一个111.png后，不能立即通过浏览器访问到这个图片，因为项目类的所有资源和文件必须编译为target版本后才对外服务，而添加资源后不重启项目无法重新编译，target中的东西没有更新。</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://blog.csdn.net/rui18300072030/article/details/74923580" target="_blank" rel="noopener">https://blog.csdn.net/rui18300072030/article/details/74923580</a></p>
<blockquote>
<p>因此，需要修改后立即生效的文件，尤其是非代码文件（除去html，css这种）最好是放在项目类的外部，放在文件系统的绝对路径下。如果文件必须放在项目中，但又必须得立即生效，<br>那么对项目中的同一个资源目录，即添加其相对路径，又添加其绝对路径：</p>
</blockquote>
<p>如果文件必须放在项目中，但又必须得立即生效，那么用下面的方法：<br>对项目中的同一个资源目录，即添加其相对路径，又添加其绝对路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">registry.addResourceHandler(<span class="string">"/**"</span>)</span><br><span class="line">        .addResourceLocations(<span class="string">"classpath:static/"</span>)</span><br><span class="line"> .addResourceLocations(<span class="string">"file:///Users/mytest/inspector/src/main/resources/static/"</span>);</span><br></pre></td></tr></table></figure>
<p>上面两个路径其实是同一个，但通过上面相对路径访问的是target中的东西。在运行时添加一个文件后，target没有更新，通过相对路径就访问不到，但实际上文件系统是更新了，所以用下面的绝对路径直接访问文件系统中的文件就可。</p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>循环引用&amp;使用aop时注入属性失效的问题</title>
    <url>/2020/04/10/java/spring/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8&amp;%E4%BD%BF%E7%94%A8aop%E6%97%B6%E6%B3%A8%E5%85%A5%E5%B1%9E%E6%80%A7%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>结论：如果一个对象要被生成代理，那么不要对它的属性或方法进行注入，这些都会变成null（构造器注入是可以的）</p>
<p>首先第一个问题：</p>
<blockquote>
<p>如果循环引用的对象需要被拦截，即要创建代理怎么办？</p>
</blockquote>
<blockquote>
<p>假如A依赖B，B依赖A，（A有一个属性B b，B有一个属性A a）且A需要被aop拦截，需要创建代理去替代本身：<br>假如首先创建A，先用构造方法创建了一个A的早期实例，把它放在singletonFactories中，然后调用populateBean去给它填充属性时，发现需要创建B，然后去进入创建B的流程,在创建完B实例后，须去填充B的a属性<br>applyPropertyValues<br>-&gt;resolveValueIfNecessary(BeanDefinitionValueResolver)尝试去获取a的实例，已经有实例了，但在去获取的过程中，会发现a是一个factorybean，此时要去检查是否需要对它生成代理，发现需要，则生成代理后放入二级缓存，并从三级缓存中删除原始实例，填充到B的属性中。接着去完成B的创建</p>
</blockquote>
<blockquote>
<p>B创建完后，回到A的创建流程，把这个创建完成的B填充到A的属性b，然后会检查A是不是有早期引用（检查二级和三级缓存），发现有（即是那个代理对象），然后用代理对象把A给代替了放入容器中，但此时这个代理对象的属性是没有B的引用的!<br>在mvc中验证，此时调用A的b属性，得到的是空</p>
</blockquote>
<p>接下来是两个例子，分别是循环引用和非循环引用的场景；</p>
<p>首先是两个bean类：<br><img src="https://img-blog.csdnimg.cn/20200318114609956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="1"><br><img src="https://img-blog.csdnimg.cn/2020031811461055.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="2"></p>
<p>测试代码：<br><img src="https://img-blog.csdnimg.cn/20200318114610164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="3"></p>
<p>在不使用代理时：<br>输出：</p>
<blockquote>
<p>aop1:com.ljy.inspector.aop.Aop1Util@1fe8f5e8<br>aop2:com.ljy.inspector.aop.Aop2Util@2e0ad709<br>1.2= com.ljy.inspector.aop.Aop2Util@2e0ad709<br>2.1= com.ljy.inspector.aop.Aop1Util@1fe8f5e8</p>
</blockquote>
<p>添加切面：（即会对aop1util 创建代理）<br><img src="https://img-blog.csdnimg.cn/20200318114610212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="4"></p>
<p>再执行测试代码：</p>
<blockquote>
<p>aop1:com.ljy.inspector.aop.Aop1Util@56b1e527<br>aop2:com.ljy.inspector.aop.Aop2Util@6b25ef1c<br>1.2= null<br>2.1= com.ljy.inspector.aop.Aop1Util@56b1e527</p>
</blockquote>
<blockquote>
<p>如果出现了循环引用，原始对象并不会把自己已经创建好的属性赋给用来替代它的那个代理对象.</p>
</blockquote>
<p>那么如果不循环引用的话呢？我们知道，正常给一个对象创建代理是在<br>initializeBean()-&gt;applyBeanPostProcessorsAfterInitialization()中，也就是后置处理中。<br>经过验证，就算不循环引用，前期的创建的属性在创建了代理后仍会被清空。</p>
<p>对于两个工具类：<br><img src="https://img-blog.csdnimg.cn/20200318114610111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="5"><br><img src="https://img-blog.csdnimg.cn/202003181146107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="6"><br>测试代码：<br><img src="https://img-blog.csdnimg.cn/20200318114610147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="7"><br>结果：</p>
<blockquote>
<p>aop1:com.ljy.inspector.aop.Aop1Util@56b1e527<br>aop2:com.ljy.inspector.aop.Aop2Util@4e974b9e<br>1.2= null</p>
</blockquote>
<p>可以进入堆栈中看：<br>在创建aop1util时，当执行完populateBean时，它的“aop2Util”属性就已经被填充了，此时它仍是正常的实例<br><img src="https://img-blog.csdnimg.cn/20200318114610355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="8"><br>在进入initialzeBean后，执行完前置处理后，可以看到这个bean仍然没有变化：（在initialzeBean中以wrappedBean为准）<br><img src="https://img-blog.csdnimg.cn/20200318114610342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="9"></p>
<p>但一经过后置处理，可以看到wrappedBean已经变成了代理对象，而且其aop2util属性是空<br><img src="https://img-blog.csdnimg.cn/20200318114610381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="10"></p>
<p><strong>结论：如果一个对象要被生成代理，那么不要对它的属性或方法进行注入，这些都会变成null（构造器注入是可以的,因为构造器注入时创建代理对象时必须要调用其父类（也就是被代理类）的构造函数，此时就会把要注入的对象注入了）</strong></p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
  <entry>
    <title>springMVC处理请求流程</title>
    <url>/2020/04/10/java/spring/springMVC%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>Dispatcher接收到了客户的请求，遍历所有的HandlerMapping集合，找出被@Controller注解的bean和被@Request注解的类和方法，根据请求的路径，参数等一系列条件，找到符合条件的HandlerMapping，并得到Handler执行链，其中包括拦截器和controller方法，是一条拦截+处理链。</p>
<p>dispatcherServlet让把请求放进入链中，先执行所有拦截器的preHandle方法，执行完后准备去真正的handle方法（即controller的对应方法）。首先使用解析类解析handle方法的参数，包括@RequestParam、@RequestBody、@PathVariable注解的参数，从请求中提取出这些参数的值，并把它们连同请求一起交给handle方法，在handle中执行真正的业务逻辑。在handle方法处理结束之后，再使用一些处理类处理handle方法的返回值，处理完后合并进响应，再去执行所有拦截器的postHandle方法。之后把返回值交给dispatcherServlet，如果返回的是一个ModelAndView，则把它交给视图解析器去解析，由它解析出相应的视图（即html、jsp、xml等）并写到响应中，此时还要执行所有拦截器的afterCompletion再做处理。</p>
<p>然后，把最终处理完成的响应返回给客户。</p>
<p>另：过滤器在dispatcherServlet的前面，如果有过滤器，则请求进来时先进过滤器链，再进dispatcherServlet。响应走时先通过dispatcherServlet，然后再通过过滤器链<br><img src="https://img-blog.csdnimg.cn/20200211165844244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc1Mjg1NA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
  </entry>
</search>
